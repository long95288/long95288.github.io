<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>基础算法2 · 风兮木落</title><meta name="description" content="华为精英202010OD[第一题]题意:给一个数n,寻找两个质数相乘等于n,按从小到大输出这两个数。例子输入
115
输出:
13 5
输入:
127
输出:
1-1 -1

题解123456789101112131415161718192021222324252627282930313233343"><meta name="og:description" content="华为精英202010OD[第一题]题意:给一个数n,寻找两个质数相乘等于n,按从小到大输出这两个数。例子输入
115
输出:
13 5
输入:
127
输出:
1-1 -1

题解123456789101112131415161718192021222324252627282930313233343"><meta name="twitter:site" content="风兮木落"><meta name="twitter:title" content="基础算法2"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">long blogs</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">进一步有进一步惊喜</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://long95288.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>基础算法2</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-08-11</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/算法/" title="算法">算法</a><span>&nbsp;</span></span></p><p class="post-abstract"><h4 id="华为精英202010OD-第一题"><a href="#华为精英202010OD-第一题" class="headerlink" title="华为精英202010OD[第一题]"></a>华为精英202010OD[第一题]</h4><p>题意:给一个数n,寻找两个质数相乘等于n,按从小到大输出这两个数。<br>例子<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br></pre></td></tr></table></figure>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找由两个素数相乘得到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isP</span><span class="params">(n <span class="type">int</span>, pMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _,ok := pMap[n];ok&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">2</span>; j &lt; n; j ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> n % j == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pMap[n] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 计算所有的素数</span></span><br><span class="line">    <span class="keyword">var</span> inputN = <span class="number">0</span></span><br><span class="line">    fmt.Scanf(<span class="string">&quot;%d&quot;</span>, &amp;inputN)</span><br><span class="line">    <span class="comment">//fmt.Printf(&quot;%d&quot;, inputN)</span></span><br><span class="line">    pMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    max := inputN</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= max; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> isP(i, pMap) &amp;&amp; max % i == <span class="number">0</span> &#123;</span><br><span class="line">            sub :=  max / i</span><br><span class="line">            <span class="keyword">if</span> isP(sub, pMap) &#123;</span><br><span class="line">                <span class="comment">//fmt.Println(pMap)</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; sub &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;%d %d&quot;</span>, i, sub)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;%d %d&quot;</span>, sub, i)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;-1 -1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题:大数据会占用非常多的时间，导致超时。</p>
<h3 id="华为精英202010OD-第二题"><a href="#华为精英202010OD-第二题" class="headerlink" title="华为精英202010OD[第二题]"></a>华为精英202010OD[第二题]</h3><p>题意: 返回特定水仙花个数,如果没有对应的水仙花数。返回最后一个水仙花乘上个数m。<br>例子:<br>输入:第一行是位数，第二行是第n个水仙花数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><code>100 - 999</code><br><code>153</code>为第一个水仙花数。<br>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">153</span><br></pre></td></tr></table></figure>

<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFlowers</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    ns := strconv.Itoa(n)</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,i := <span class="keyword">range</span> ns &#123;</span><br><span class="line">        ni,_ := strconv.Atoi(<span class="type">string</span>(i))</span><br><span class="line">        tmp := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>; j &lt; <span class="built_in">len</span>(ns); j++&#123;</span><br><span class="line">            tmp *= ni</span><br><span class="line">        &#125;</span><br><span class="line">        ret += tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1 数字位数</span></span><br><span class="line">    <span class="comment">// 2 第几个水仙花</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">0</span></span><br><span class="line">    fmt.Scan(&amp;n)</span><br><span class="line">    fmt.Scan(&amp;m)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">7</span> || n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    start := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; n - <span class="number">1</span>;i ++&#123;</span><br><span class="line">        start *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    end := <span class="number">10</span> * start <span class="number">-1</span></span><br><span class="line">    <span class="comment">//fmt.Printf(&quot;%d %d\n&quot;, start, end)</span></span><br><span class="line">    <span class="comment">// 计算数据</span></span><br><span class="line">    <span class="keyword">for</span> i := start;i &lt;= end;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> isFlowers(i) &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; m &#123;</span><br><span class="line">                fmt.Println(res[m])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt;= <span class="number">0</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; m &#123;</span><br><span class="line">        fmt.Println(res[<span class="built_in">len</span>(res) <span class="number">-1</span>] * m)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(res[m])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="华为精英202010OD-第三题"><a href="#华为精英202010OD-第三题" class="headerlink" title="华为精英202010OD[第三题]"></a>华为精英202010OD[第三题]</h3><p>模拟内存申请和释放。<br>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">REQUEST=10</span><br><span class="line">REQUEST=20</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟内存分配</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mem <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstp <span class="type">int</span></span><br><span class="line">    lastp <span class="type">int</span></span><br><span class="line">    callocable <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Memory <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstP <span class="type">int</span></span><br><span class="line">    lastP <span class="type">int</span></span><br><span class="line">    callocTable []mem</span><br><span class="line">    idleTable []mem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocMem</span><span class="params">(m Memory, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(m.idleTable); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> m.idleTable[i].lastp - m.idleTable[i].firstp + <span class="number">1</span> &gt; n &#123;</span><br><span class="line">            m.callocTable = <span class="built_in">append</span>(m.callocTable, mem&#123;</span><br><span class="line">                firstp:     m.idleTable[i].firstp,</span><br><span class="line">                lastp:      m.idleTable[i].firstp + n - <span class="number">1</span>,</span><br><span class="line">                callocable: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">            p := strconv.Itoa(m.idleTable[i].firstp)</span><br><span class="line">            m.idleTable[i].firstp = m.idleTable[i].firstp + n</span><br><span class="line">            <span class="keyword">return</span> p</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freeMem</span><span class="params">(m Memory, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(m.callocTable); i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> m.callocTable[i].firstp == n &#123;</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">0</span>; j &lt; <span class="built_in">len</span>(m.idleTable); j++ &#123;</span><br><span class="line">                <span class="keyword">if</span> m.idleTable[j].lastp + <span class="number">1</span> == m.callocTable[i].firstp &#123;</span><br><span class="line">                    m.idleTable[j].lastp = m.callocTable[i].lastp</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> m.idleTable[j].firstp == m.callocTable[i].lastp + <span class="number">1</span> &#123;</span><br><span class="line">                    m.idleTable[j].firstp = m.callocTable[i].firstp</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m.idleTable = <span class="built_in">append</span>(m.idleTable, m.callocTable[i])</span><br><span class="line">            m.callocTable = <span class="built_in">append</span>(m.callocTable[ :i], m.callocTable[i+<span class="number">1</span>:]...)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 维护一个分配表和空闲表</span></span><br><span class="line">    op := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    m := Memory&#123;</span><br><span class="line">        firstP:      <span class="number">0</span>,</span><br><span class="line">        lastP:       <span class="number">99</span>,</span><br><span class="line">        callocTable: []mem&#123;&#125;,</span><br><span class="line">        idleTable: []mem&#123;&#123;</span><br><span class="line">            firstp:     <span class="number">0</span>,</span><br><span class="line">            lastp:      <span class="number">99</span>,</span><br><span class="line">            callocable: <span class="literal">false</span>,</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    <span class="keyword">for</span> str,err := in.ReadString(<span class="string">&#x27;\n&#x27;</span>);err == <span class="literal">nil</span>;str,err = in.ReadString(<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        str = strings.Replace(str,<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        str = strings.Replace(str,<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == str &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        op = <span class="built_in">append</span>(op, str)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(op); i++&#123;</span><br><span class="line">        cmd :=strings.Split(op[i], <span class="string">&quot;=&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;REQUEST&quot;</span> == cmd[<span class="number">0</span>] &#123;</span><br><span class="line">            n,_ := strconv.Atoi(cmd[<span class="number">1</span>])</span><br><span class="line">            fmt.Println(allocMem(m, n))</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="string">&quot;RELEASE&quot;</span> == cmd[<span class="number">0</span>] &#123;</span><br><span class="line">            n, _ := strconv.Atoi(cmd[<span class="number">1</span>])</span><br><span class="line">            fmt.Println(freeMem(m, n))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="409-最长回文串-简单"><a href="#409-最长回文串-简单" class="headerlink" title="409. 最长回文串[简单]"></a>409. 最长回文串[简单]</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>
<p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p>
<p>注意:<br>假设字符串的长度不会超过 1010。</p>
<p>示例 1:</p>
<p>输入:<br>“abccccdd”</p>
<p>输出:<br>7</p>
<p>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindrome">https://leetcode-cn.com/problems/longest-palindrome</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>存储字母出现的次数,偶数直接加起来，奇数去掉一位之后再加起来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mapP := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        mapP[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> mapP&#123;</span><br><span class="line">        ret += (v/<span class="number">2</span>)*<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-50-第一个只出现一次的字符-简单"><a href="#剑指-Offer-50-第一个只出现一次的字符-简单" class="headerlink" title="剑指 Offer 50. 第一个只出现一次的字符[简单]"></a>剑指 Offer 50. 第一个只出现一次的字符[简单]</h3><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例:</p>
<p>s &#x3D; “abaccdeff”<br>返回 “b”</p>
<p>s &#x3D; “”<br>返回 “ “</p>
<p>限制：</p>
<p>0 &lt;&#x3D; s 的长度 &lt;&#x3D; 50000</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 两次遍历</span></span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v:= <span class="keyword">range</span> s &#123;</span><br><span class="line">        sMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> v2,_ := sMap[v];v2 == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">byte</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="463-岛屿的周长-简单"><a href="#463-岛屿的周长-简单" class="headerlink" title="463. 岛屿的周长[简单]"></a>463. 岛屿的周长[简单]</h3><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p>
<p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p> </p>
<p>示例 :</p>
<p>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p>
<p>输出: 16</p>
<p>解释: 它的周长是下面图片中的 16 个黄色的边：</p>
<p>通过次数49,973提交次数70,121</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter">https://leetcode-cn.com/problems/island-perimeter</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">islandPerimeter</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是陆地，计算相邻的四个格子，如果相邻的格子是0或者是边界,添加一条边</span></span><br><span class="line">    m := <span class="built_in">len</span>(grid)</span><br><span class="line">    n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt; m;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;n;j++&#123;</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 左 上 右 下</span></span><br><span class="line">                <span class="keyword">if</span> j - <span class="number">1</span> &lt; <span class="number">0</span> || (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j <span class="number">-1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &lt; <span class="number">0</span> || (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> j + <span class="number">1</span> &gt;= n || (j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ret += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &gt;= m || (i + <span class="number">1</span> &lt; m &amp;&amp; grid[i+ <span class="number">1</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="500-键盘行-简单"><a href="#500-键盘行-简单" class="headerlink" title="500. 键盘行[简单]"></a>500. 键盘行[简单]</h3><p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<p>示例：</p>
<p>输入: [“Hello”, “Alaska”, “Dad”, “Peace”]<br>输出: [“Alaska”, “Dad”]</p>
<p>注意：</p>
<p>你可以重复使用键盘上同一字符。<br>你可以假设输入的字符串将只包含字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/keyboard-row">https://leetcode-cn.com/problems/keyboard-row</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findWords</span><span class="params">(words []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    m1Str := <span class="string">&quot;qwertyuiopQWERTYUIOP&quot;</span></span><br><span class="line">    m2Str := <span class="string">&quot;asdfghjklASDFGHJKL&quot;</span></span><br><span class="line">    m3Str := <span class="string">&quot;zxcvbnmZXCVBNM&quot;</span></span><br><span class="line">    </span><br><span class="line">    m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> m1Str&#123;</span><br><span class="line">        m1[v] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> m2Str&#123;</span><br><span class="line">        m2[v] = <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> m3Str &#123;</span><br><span class="line">        m3[v] = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> words &#123;</span><br><span class="line">        </span><br><span class="line">        flag := <span class="number">-1</span></span><br><span class="line">        count := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> _,ok := m1[<span class="type">rune</span>(item[<span class="number">0</span>])];ok &#123;</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _,ok := m2[<span class="type">rune</span>(item[<span class="number">0</span>])];ok &#123;</span><br><span class="line">            flag = <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _,ok := m3[<span class="type">rune</span>(item[<span class="number">0</span>])];ok &#123;</span><br><span class="line">            flag = <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> item &#123;</span><br><span class="line">            <span class="keyword">switch</span> flag &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> _,ok := m1[v];ok&#123;</span><br><span class="line">                    count ++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> _,ok := m2[v];ok&#123;</span><br><span class="line">                    count ++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> _,ok := m3[v];ok&#123;</span><br><span class="line">                    count ++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> flag != <span class="number">-1</span> &amp;&amp; count == <span class="built_in">len</span>(item) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5539-按照频率将数组升序排序-简单"><a href="#5539-按照频率将数组升序排序-简单" class="headerlink" title="5539. 按照频率将数组升序排序[简单]"></a>5539. 按照频率将数组升序排序[简单]</h3><p>给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 </p>
<p>请你返回排序后的数组。</p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2,2,2,3]<br>输出：[3,1,1,2,2,2]<br>解释：’3’ 频率为 1，’1’ 频率为 2，’2’ 频率为 3 。<br>示例 2：</p>
<p>输入：nums &#x3D; [2,3,1,3,2]<br>输出：[1,3,3,2,2]<br>解释：’2’ 和 ‘3’ 频率都为 2 ，所以它们之间按照数值本身降序排序。<br>示例 3：</p>
<p>输入：nums &#x3D; [-1,1,-6,4,5,-6,1,4,1]<br>输出：[5,-1,4,4,-6,-6,1,1,1]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>-100 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">frequencySort</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 计算出现频率</span></span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    nLen := <span class="built_in">len</span>(nMap)</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i &lt; nLen; i++&#123;</span><br><span class="line">        minVal := <span class="number">101</span></span><br><span class="line">        tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> nMap&#123;</span><br><span class="line">            <span class="keyword">if</span> v &lt; minVal &#123;</span><br><span class="line">                minVal = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> nMap &#123;</span><br><span class="line">            <span class="keyword">if</span> v == minVal &#123;</span><br><span class="line">                <span class="keyword">for</span> j := <span class="number">0</span> ; j &lt; minVal; j++&#123;</span><br><span class="line">                    tmpV := k</span><br><span class="line">                    tmp = <span class="built_in">append</span>(tmp, tmpV)</span><br><span class="line">                    <span class="built_in">delete</span>(nMap, k)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Ints(tmp)</span><br><span class="line">        <span class="keyword">for</span> y := <span class="built_in">len</span>(tmp) <span class="number">-1</span>; y &gt;= <span class="number">0</span>; y--&#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, tmp[y])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="575-分糖果-简单"><a href="#575-分糖果-简单" class="headerlink" title="575. 分糖果[简单]"></a>575. 分糖果[简单]</h3><p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<p>示例 1:</p>
<p>输入: candies &#x3D; [1,1,2,2,3,3]<br>输出: 3<br>解析: 一共有三种种类的糖果，每一种都有两个。<br>     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。<br>示例 2 :</p>
<p>输入: candies &#x3D; [1,1,2,3]<br>输出: 2<br>解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。<br>注意:</p>
<p>数组的长度为[2, 10,000]，并且确定为偶数。<br>数组中数字的大小在范围[-100,000, 100,000]内。<br>通过次数28,693提交次数42,364</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distribute-candies">https://leetcode-cn.com/problems/distribute-candies</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">distributeCandies</span><span class="params">(candies []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> candies &#123;</span><br><span class="line">        m[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(<span class="built_in">len</span>(m), <span class="built_in">len</span>(candies) / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="594-最长和谐子序列-简单"><a href="#594-最长和谐子序列-简单" class="headerlink" title="594. 最长和谐子序列[简单]"></a>594. 最长和谐子序列[简单]</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>示例 1:</p>
<p>输入: [1,3,2,2,5,2,3,7]<br>输出: 5<br>原因: 最长的和谐数组是：[3,2,2,2,3].<br>说明: 输入的数组长度最大不超过20,000.</p>
<p>通过次数17,044提交次数34,875</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-harmonious-subsequence">https://leetcode-cn.com/problems/longest-harmonious-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h4><p>  计算各个数字的个数,寻找相邻为1和的最大值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLHS</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 和谐数组</span></span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> nMap &#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := nMap[k - <span class="number">1</span>];ok &#123;</span><br><span class="line">            <span class="keyword">if</span> v2 + v &gt; max &#123;</span><br><span class="line">                max = v2 + v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v2, ok := nMap[k + <span class="number">1</span>];ok &#123;</span><br><span class="line">            <span class="keyword">if</span> v2 + v &gt; max &#123;</span><br><span class="line">                max = v2 + v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="599-两个列表的最小索引总和-简单"><a href="#599-两个列表的最小索引总和-简单" class="headerlink" title="599. 两个列表的最小索引总和[简单]"></a>599. 两个列表的最小索引总和[简单]</h3><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p>
<p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p>
<p>示例 1:</p>
<p>输入:<br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]<br>输出: [“Shogun”]<br>解释: 他们唯一共同喜爱的餐厅是“Shogun”。<br>示例 2:</p>
<p>输入:<br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“KFC”, “Shogun”, “Burger King”]<br>输出: [“Shogun”]<br>解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。<br>提示:</p>
<p>两个列表的长度范围都在 [1, 1000]内。<br>两个列表中的字符串的长度将在[1，30]的范围内。<br>下标从0开始，到列表的长度减1。<br>两个列表都没有重复的元素。<br>通过次数18,694提交次数36,230</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists">https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h4><p>先找最小索引，再找最小索引对应的元素</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRestaurant</span><span class="params">(list1 []<span class="type">string</span>, list2 []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> list1 &#123;</span><br><span class="line">        index := i</span><br><span class="line">        m1[v] = index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> list2 &#123;</span><br><span class="line">        index := i</span><br><span class="line">        m2[v] = index</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    minIndex := <span class="number">1</span> &lt;&lt; (<span class="number">32</span> <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        <span class="keyword">if</span> v2, ok := m2[k];ok &#123;</span><br><span class="line">            <span class="keyword">if</span> minIndex &gt; v + v2 &#123;</span><br><span class="line">                minIndex = v + v2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        <span class="keyword">if</span> v2, ok := m2[k];ok &amp;&amp; (v2 + v == minIndex) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="645-错误的集合-简单"><a href="#645-错误的集合-简单" class="headerlink" title="645. 错误的集合[简单]"></a>645. 错误的集合[简单]</h3><p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,2,4]<br>输出: [2,3]<br>注意:</p>
<p>给定数组的长度范围是 [2, 10000]。<br>给定的数组是无序的。<br>通过次数24,480提交次数58,029</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/set-mismatch">https://leetcode-cn.com/problems/set-mismatch</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findErrorNums</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找重复值</span></span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] += <span class="number">1</span></span><br><span class="line">        sum += v</span><br><span class="line">        <span class="keyword">if</span> mv,_ := nMap[v];mv == <span class="number">2</span> &#123;</span><br><span class="line">            tmp := v</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, tmp)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 计算差值</span></span><br><span class="line">    standard := (<span class="built_in">len</span>(nums) * (<span class="built_in">len</span>(nums) + <span class="number">1</span>)) / <span class="number">2</span></span><br><span class="line">    ret = <span class="built_in">append</span>(ret, (ret[<span class="number">0</span>] + (standard - sum)))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="941-有效的山脉数组-简单"><a href="#941-有效的山脉数组-简单" class="headerlink" title="941. 有效的山脉数组[简单]"></a>941. 有效的山脉数组[简单]</h3><p>给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。</p>
<p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p>
<p>A.length &gt;&#x3D; 3<br>在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得：<br>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]<br>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</p>
<p><img src="https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png"> </p>
<p> </p>
<p>示例 1：</p>
<p>输入：[2,1]<br>输出：false<br>示例 2：</p>
<p>输入：[3,5,5]<br>输出：false<br>示例 3：</p>
<p>输入：[0,3,2,1]<br>输出：true
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; A.length &lt;&#x3D; 10000<br>0 &lt;&#x3D; A[i] &lt;&#x3D; 10000 </p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-mountain-array">https://leetcode-cn.com/problems/valid-mountain-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validMountainArray</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 两端往中间,最后重合,说明是山峰</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(A) &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    end := <span class="built_in">len</span>(A) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line">        <span class="keyword">if</span> start + <span class="number">1</span> &lt;= end &amp;&amp; A[start + <span class="number">1</span>] &gt; A[start]&#123;</span><br><span class="line">            start ++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> end - <span class="number">1</span> &gt;= start &amp;&amp; A[end] &lt; A[end <span class="number">-1</span>] &#123;</span><br><span class="line">            end --</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start == end &amp;&amp; start != <span class="number">0</span> &amp;&amp; end != <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="690-员工的重要性-简单"><a href="#690-员工的重要性-简单" class="headerlink" title="690. 员工的重要性[简单]"></a>690. 员工的重要性[简单]</h3><p>给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。</p>
<p>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。</p>
<p>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。</p>
<p>示例 1:</p>
<p>输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出: 11<br>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 &#x3D; 11。<br>注意:</p>
<p>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/employee-importance">https://leetcode-cn.com/problems/employee-importance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getImportance</span><span class="params">(employees []*Employee, id <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    eMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Employee)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> employees&#123;</span><br><span class="line">        eMap[v.Id] = v</span><br><span class="line">    &#125;</span><br><span class="line">    e,_ := eMap[id]</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    ret += e.Importance</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> e.Subordinates&#123;</span><br><span class="line">        ret += getImportance(employees,v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="720-词典中最长的单词-简单"><a href="#720-词典中最长的单词-简单" class="headerlink" title="720. 词典中最长的单词[简单]"></a>720. 词典中最长的单词[简单]</h3><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p>
<p>若无答案，则返回空字符串。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：<br>words &#x3D; [“w”,”wo”,”wor”,”worl”, “world”]<br>输出：”world”<br>解释：<br>单词”world”可由”w”, “wo”, “wor”, 和 “worl”添加一个字母组成。<br>示例 2：</p>
<p>输入：<br>words &#x3D; [“a”, “banana”, “app”, “appl”, “ap”, “apply”, “apple”]<br>输出：”apple”<br>解释：<br>“apply”和”apple”都能由词典中的单词组成。但是”apple”的字典序小于”apply”。
 </p>
<p>提示：</p>
<p>所有输入的字符串都只包含小写字母。<br>words数组长度范围为[1,1000]。<br>words[i]的长度范围为[1,30]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-word-in-dictionary">https://leetcode-cn.com/problems/longest-word-in-dictionary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestWord</span><span class="params">(words []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> words &#123;</span><br><span class="line">        sMap[v] = <span class="built_in">len</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    haveResult := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> k,_ := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">        setable := <span class="literal">true</span></span><br><span class="line">        tmp := k</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; <span class="built_in">len</span>(tmp);i ++&#123;</span><br><span class="line">            <span class="keyword">if</span> _,ok := sMap[<span class="type">string</span>(tmp[:i])]; !ok&#123;</span><br><span class="line">                setable = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> setable &amp;&amp; !haveResult &#123;</span><br><span class="line">            result = tmp</span><br><span class="line">            haveResult = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> setable &amp;&amp; haveResult &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(result) &lt; <span class="built_in">len</span>(tmp)&#123;</span><br><span class="line">                result = tmp</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(result) == <span class="built_in">len</span>(tmp) &amp;&amp; result &gt; tmp &#123;</span><br><span class="line">                result = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> haveResult &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="748-最短补全词-简单"><a href="#748-最短补全词-简单" class="headerlink" title="748. 最短补全词[简单]"></a>748. 最短补全词[简单]</h3><p>给定一个字符串牌照 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。</p>
<p>如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为 补全词 。在所有完整词中，最短的单词我们称之为 最短补全词 。</p>
<p>单词在匹配牌照中的字母时要：</p>
<p>忽略牌照中的数字和空格。<br>不区分大小写，比如牌照中的 “P” 依然可以匹配单词中的 “p” 字母。<br>如果某个字母在牌照中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。<br>例如：licensePlate &#x3D; “aBc 12c”，那么它由字母 ‘a’、’b’ （忽略大写）和两个 ‘c’ 。可能的 补全词 是 “abccdef”、”caaacab” 以及 “cbca” 。</p>
<p>题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取单词列表中最靠前的一个。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：licensePlate &#x3D; “1s3 PSt”, words &#x3D; [“step”, “steps”, “stripe”, “stepple”]<br>输出：”steps”<br>说明：最短补全词应该包括 “s”、”p”、”s” 以及 “t”。在匹配过程中我们忽略牌照中的大小写。<br>“step” 包含 “t”、”p”，但只包含一个 “s”，所以它不符合条件。<br>“steps” 包含 “t”、”p” 和两个 “s”。<br>“stripe” 缺一个 “s”。<br>“stepple” 缺一个 “s”。<br>因此，”steps” 是唯一一个包含所有字母的单词，也是本样例的答案。<br>示例 2：</p>
<p>输入：licensePlate &#x3D; “1s3 456”, words &#x3D; [“looks”, “pest”, “stew”, “show”]<br>输出：”pest”<br>说明：存在 3 个包含字母 “s” 且有着最短长度的补全词，”pest”、”stew”、和 “show” 三者长度相同，但我们返回最先出现的补全词 “pest” 。<br>示例 3：</p>
<p>输入：licensePlate &#x3D; “Ah71752”, words &#x3D; [“suggest”,”letter”,”of”,”husband”,”easy”,”education”,”drug”,”prevent”,”writer”,”old”]<br>输出：”husband”<br>示例 4：</p>
<p>输入：licensePlate &#x3D; “OgEu755”, words &#x3D; [“enough”,”these”,”play”,”wide”,”wonder”,”box”,”arrive”,”money”,”tax”,”thus”]<br>输出：”enough”<br>示例 5：</p>
<p>输入：licensePlate &#x3D; “iMSlpe4”, words &#x3D; [“claim”,”consumer”,”student”,”camera”,”public”,”never”,”wonder”,”simple”,”thought”,”use”]<br>输出：”simple”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; licensePlate.length &lt;&#x3D; 7<br>licensePlate 由数字、大小写字母或空格 ‘ ‘ 组成<br>1 &lt;&#x3D; words.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 15<br>words[i] 由小写英文字母组成</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-completing-word">https://leetcode-cn.com/problems/shortest-completing-word</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-13"><a href="#解法-13" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestCompletingWord</span><span class="params">(licensePlate <span class="type">string</span>, words []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    lMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    ulicensePlate  := strings.ToUpper(licensePlate)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> ulicensePlate &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span> &#123;</span><br><span class="line">            lMap[v] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    minLen := <span class="number">1</span> &lt;&lt; (<span class="number">32</span> <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, str := <span class="keyword">range</span> words &#123;</span><br><span class="line">        uStr := strings.ToUpper(str)</span><br><span class="line">        uStrMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> uStr &#123;</span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span> &#123;</span><br><span class="line">                uStrMap[v] += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setAble := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> lMap &#123;</span><br><span class="line">            <span class="keyword">if</span> v2,ok := uStrMap[k]; !ok || v2 &lt; v &#123;</span><br><span class="line">                setAble = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> setAble &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(str) &lt; minLen &#123;</span><br><span class="line">                minLen = <span class="built_in">len</span>(str)</span><br><span class="line">                result = str</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="705-设计哈希集合-简单"><a href="#705-设计哈希集合-简单" class="headerlink" title="705. 设计哈希集合[简单]"></a>705. 设计哈希集合[简单]</h3><p>不使用任何内建的哈希表库设计一个哈希集合</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<p>add(value)：向哈希集合中插入一个值。<br>contains(value) ：返回哈希集合中是否存在这个值。<br>remove(value)：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p>
<p>示例:</p>
<p>MyHashSet hashSet &#x3D; new MyHashSet();<br>hashSet.add(1);        <br>hashSet.add(2);        <br>hashSet.contains(1);    &#x2F;&#x2F; 返回 true<br>hashSet.contains(3);    &#x2F;&#x2F; 返回 false (未找到)<br>hashSet.add(2);          <br>hashSet.contains(2);    &#x2F;&#x2F; 返回 true<br>hashSet.remove(2);          <br>hashSet.contains(2);    &#x2F;&#x2F; 返回  false (已经被删除)</p>
<p>注意：</p>
<p>所有的值都在 [0, 1000000]的范围内。<br>操作的总数目在[1, 10000]范围内。<br>不要使用内建的哈希集合库。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashset">https://leetcode-cn.com/problems/design-hashset</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-14"><a href="#解法-14" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyHashSet <span class="keyword">struct</span> &#123;</span><br><span class="line">    keys []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashSet &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashSet&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span></span> Add(key <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> this.keys&#123;</span><br><span class="line">        <span class="keyword">if</span> key == v &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.keys = <span class="built_in">append</span>(this.keys, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span></span> Remove(key <span class="type">int</span>)  &#123;</span><br><span class="line">    tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> this.keys &#123;</span><br><span class="line">        <span class="keyword">if</span> key == v &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.keys = tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashSet)</span></span> Contains(key <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> this.keys &#123;</span><br><span class="line">        <span class="keyword">if</span> v == key &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="706-设计哈希映射-简单"><a href="#706-设计哈希映射-简单" class="headerlink" title="706. 设计哈希映射[简单]"></a>706. 设计哈希映射[简单]</h3><p>不使用任何内建的哈希表库设计一个哈希映射</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<p>put(key, value)：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。<br>get(key)：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。<br>remove(key)：如果映射中存在这个键，删除这个数值对。</p>
<p>示例：</p>
<p>MyHashMap hashMap &#x3D; new MyHashMap();<br>hashMap.put(1, 1);          <br>hashMap.put(2, 2);        <br>hashMap.get(1);            &#x2F;&#x2F; 返回 1<br>hashMap.get(3);            &#x2F;&#x2F; 返回 -1 (未找到)<br>hashMap.put(2, 1);         &#x2F;&#x2F; 更新已有的值<br>hashMap.get(2);            &#x2F;&#x2F; 返回 1<br>hashMap.remove(2);         &#x2F;&#x2F; 删除键为2的数据<br>hashMap.get(2);            &#x2F;&#x2F; 返回 -1 (未找到) </p>
<p>注意：</p>
<p>所有的值都在 [0, 1000000]的范围内。<br>操作的总数目在[1, 10000]范围内。<br>不要使用内建的哈希库。<br>通过次数18,111提交次数31,074</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-hashmap">https://leetcode-cn.com/problems/design-hashmap</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-15"><a href="#解法-15" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyHashMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 双数组</span></span><br><span class="line">    keys []<span class="type">int</span></span><br><span class="line">    values []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyHashMap &#123;</span><br><span class="line">    <span class="keyword">return</span> MyHashMap&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** value will always be non-negative. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> this.keys&#123;</span><br><span class="line">        <span class="keyword">if</span> v == key &#123;</span><br><span class="line">            this.values[i] = value</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.keys = <span class="built_in">append</span>(this.keys, key)</span><br><span class="line">    this.values = <span class="built_in">append</span>(this.values, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> this.keys&#123;</span><br><span class="line">        <span class="keyword">if</span> v == key &#123;</span><br><span class="line">            <span class="keyword">return</span> this.values[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyHashMap)</span></span> Remove(key <span class="type">int</span>)  &#123;</span><br><span class="line">    newKeys := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    newValues := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> this.keys &#123;</span><br><span class="line">        <span class="keyword">if</span> v == key&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        newKeys = <span class="built_in">append</span>(newKeys,v)</span><br><span class="line">        newValues = <span class="built_in">append</span>(newValues, this.values[i])</span><br><span class="line">    &#125;</span><br><span class="line">    this.keys = newKeys</span><br><span class="line">    this.values = newValues</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Put(key,value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Get(key);</span></span><br><span class="line"><span class="comment"> * obj.Remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="811-子域名访问计数-简单"><a href="#811-子域名访问计数-简单" class="headerlink" title="811. 子域名访问计数[简单]"></a>811. 子域名访问计数[简单]</h3><p>一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。</p>
<p>给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。</p>
<p>接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。</p>
<p>示例 1:<br>输入:<br>[“9001 discuss.leetcode.com”]<br>输出:<br>[“9001 discuss.leetcode.com”, “9001 leetcode.com”, “9001 com”]<br>说明:<br>例子中仅包含一个网站域名：”discuss.leetcode.com”。按照前文假设，子域名”leetcode.com”和”com”都会被访问，所以它们都被访问了9001次。<br>示例 2<br>输入:<br>[“900 google.mail.com”, “50 yahoo.com”, “1 intel.mail.com”, “5 wiki.org”]<br>输出:<br>[“901 mail.com”,”50 yahoo.com”,”900 google.mail.com”,”5 wiki.org”,”5 org”,”1 intel.mail.com”,”951 com”]<br>说明:<br>按照假设，会访问”google.mail.com” 900次，”yahoo.com” 50次，”intel.mail.com” 1次，”wiki.org” 5次。<br>而对于父域名，会访问”mail.com” 900+1 &#x3D; 901次，”com” 900 + 50 + 1 &#x3D; 951次，和 “org” 5 次。<br>注意事项：</p>
<p> cpdomains 的长度小于 100。<br>每个域名的长度小于100。<br>每个域名地址包含一个或两个”.”符号。<br>输入中任意一个域名的访问次数都小于10000。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subdomain-visit-count">https://leetcode-cn.com/problems/subdomain-visit-count</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-16"><a href="#解法-16" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subdomainVisits</span><span class="params">(cpdomains []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 依次解析</span></span><br><span class="line">    cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> cpdomains&#123;</span><br><span class="line">        count,_ :=strconv.Atoi(strings.Split(v,<span class="string">&quot; &quot;</span>)[<span class="number">0</span>])</span><br><span class="line">        cMap[strings.Split(v,<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]] += count</span><br><span class="line">        tmp := v</span><br><span class="line">        index := strings.Index(tmp, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> index != <span class="number">-1</span> &#123;</span><br><span class="line">            tmp = <span class="type">string</span>(tmp[index + <span class="number">1</span>:])</span><br><span class="line">            cMap[tmp] += count</span><br><span class="line">            index = strings.Index(tmp, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> cMap&#123;</span><br><span class="line">        tmp := strconv.Itoa(v)</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, tmp + <span class="string">&quot; &quot;</span> + k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5561-获取生成数组中的最大值-简单"><a href="#5561-获取生成数组中的最大值-简单" class="headerlink" title="5561. 获取生成数组中的最大值[简单]"></a>5561. 获取生成数组中的最大值[简单]</h3><p>给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：</p>
<p>nums[0] &#x3D; 0<br>nums[1] &#x3D; 1<br>当 2 &lt;&#x3D; 2 * i &lt;&#x3D; n 时，nums[2 * i] &#x3D; nums[i]<br>当 2 &lt;&#x3D; 2 * i + 1 &lt;&#x3D; n 时，nums[2 * i + 1] &#x3D; nums[i] + nums[i + 1]<br>返回生成数组 nums 中的 最大 值。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 7<br>输出：3<br>解释：根据规则：<br>  nums[0] &#x3D; 0<br>  nums[1] &#x3D; 1<br>  nums[(1 * 2) &#x3D; 2] &#x3D; nums[1] &#x3D; 1<br>  nums[(1 * 2) + 1 &#x3D; 3] &#x3D; nums[1] + nums[2] &#x3D; 1 + 1 &#x3D; 2<br>  nums[(2 * 2) &#x3D; 4] &#x3D; nums[2] &#x3D; 1<br>  nums[(2 * 2) + 1 &#x3D; 5] &#x3D; nums[2] + nums[3] &#x3D; 1 + 2 &#x3D; 3<br>  nums[(3 * 2) &#x3D; 6] &#x3D; nums[3] &#x3D; 2<br>  nums[(3 * 2) + 1 &#x3D; 7] &#x3D; nums[3] + nums[4] &#x3D; 2 + 1 &#x3D; 3<br>因此，nums &#x3D; [0,1,1,2,1,3,2,3]，最大值 3<br>示例 2：</p>
<p>输入：n &#x3D; 2<br>输出：1<br>解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1<br>示例 3：</p>
<p>输入：n &#x3D; 3<br>输出：2<br>解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2</p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 100</p>
<h4 id="解法-17"><a href="#解法-17" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaximumGenerated</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    max := <span class="number">-1</span> &lt;&lt; (<span class="number">32</span> <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> i ==<span class="number">0</span> &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>&#123;</span><br><span class="line">            nums[i] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &gt;= <span class="number">2</span> * i &amp;&amp; <span class="number">2</span> * i &gt;= <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">                nums[<span class="number">2</span> * i] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &gt;= (<span class="number">2</span> * i + <span class="number">1</span>) &amp;&amp; (<span class="number">2</span> * i + <span class="number">1</span>) &gt;= <span class="number">2</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span>) &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">                nums[<span class="number">2</span> * i + <span class="number">1</span>] = nums[i] + nums[i + <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123;</span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5562-字符频次唯一的最小删除次数-中等"><a href="#5562-字符频次唯一的最小删除次数-中等" class="headerlink" title="5562. 字符频次唯一的最小删除次数[中等]"></a>5562. 字符频次唯一的最小删除次数[中等]</h3><p>如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。</p>
<p>给你一个字符串 s，返回使 s 成为 优质字符串 需要删除的 最小 字符数。</p>
<p>字符串中字符的 频次 是该字符在字符串中的出现次数。例如，在字符串 “aab” 中，’a’ 的频次是 2，而 ‘b’ 的频次是 1 。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “aab”<br>输出：0<br>解释：s 已经是优质字符串。<br>示例 2：</p>
<p>输入：s &#x3D; “aaabbbcc”<br>输出：2<br>解释：可以删除两个 ‘b’ , 得到优质字符串 “aaabcc” 。<br>另一种方式是删除一个 ‘b’ 和一个 ‘c’ ，得到优质字符串 “aaabbc” 。<br>示例 3：</p>
<p>输入：s &#x3D; “ceabaacb”<br>输出：2<br>解释：可以删除两个 ‘c’ 得到优质字符串 “eabaab” 。<br>注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。）</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s 仅含小写英文字母</p>
<h4 id="解法-18"><a href="#解法-18" class="headerlink" title="解法"></a>解法</h4><p> 首先，计算各个字符出现的频次。然后根据频次进行从小到大排序。<br> 排序之后的数据，例如1,2,3,4,5.前面的没有比后面的大，优质数据。<br> 如果出现1,2,3,4,5,7,7。这种情况,从右往左比较，7 &#x3D; 7,需要将7-1达到6 7。这时候整个数据组需要考虑的最大值就是6.6再和5比较,5再和4比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDeletions</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(sMap))</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">        nums[index] = v</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    step := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(nums) <span class="number">-2</span>; i &gt;= <span class="number">0</span>; i -- &#123;</span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]&#123;</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            nums[i] -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="961-重复-N-次的元素-简单"><a href="#961-重复-N-次的元素-简单" class="headerlink" title="961. 重复 N 次的元素[简单]"></a>961. 重复 N 次的元素[简单]</h3><p>在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。</p>
<p>返回重复了 N 次的那个元素。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,3]<br>输出：3<br>示例 2：</p>
<p>输入：[2,1,2,5,3,2]<br>输出：2<br>示例 3：</p>
<p>输入：[5,1,5,2,5,3,5,4]<br>输出：5</p>
<p>提示：</p>
<p>4 &lt;&#x3D; A.length &lt;&#x3D; 10000<br>0 &lt;&#x3D; A[i] &lt; 10000<br>A.length 为偶数</p>
<h4 id="解法-19"><a href="#解法-19" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedNTimes</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(A) / <span class="number">2</span></span><br><span class="line">    aMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> A &#123;</span><br><span class="line">        aMap[v] += <span class="number">1</span></span><br><span class="line">        v2,_ := aMap[v]</span><br><span class="line">        <span class="keyword">if</span> v2 &gt;= n &#123;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="953-验证外星语词典-简单"><a href="#953-验证外星语词典-简单" class="headerlink" title="953. 验证外星语词典[简单]"></a>953. 验证外星语词典[简单]</h3><p>某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。</p>
<p>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：words &#x3D; [“hello”,”leetcode”], order &#x3D; “hlabcdefgijkmnopqrstuvwxyz”<br>输出：true<br>解释：在该语言的字母表中，’h’ 位于 ‘l’ 之前，所以单词序列是按字典序排列的。<br>示例 2：</p>
<p>输入：words &#x3D; [“word”,”world”,”row”], order &#x3D; “worldabcefghijkmnpqstuvxyz”<br>输出：false<br>解释：在该语言的字母表中，’d’ 位于 ‘l’ 之后，那么 words[0] &gt; words[1]，因此单词序列不是按字典序排列的。<br>示例 3：</p>
<p>输入：words &#x3D; [“apple”,”app”], order &#x3D; “abcdefghijklmnopqrstuvwxyz”<br>输出：false<br>解释：当前三个字符 “app” 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 “apple” &gt; “app”，因为 ‘l’ &gt; ‘∅’，其中 ‘∅’ 是空白字符，定义为比任何其他字符都小（更多信息）。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; words.length &lt;&#x3D; 100<br>1 &lt;&#x3D; words[i].length &lt;&#x3D; 20<br>order.length &#x3D;&#x3D; 26<br>在 words[i] 和 order 中的所有字符都是英文小写字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/verifying-an-alien-dictionary">https://leetcode-cn.com/problems/verifying-an-alien-dictionary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-20"><a href="#解法-20" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAlienSorted</span><span class="params">(words []<span class="type">string</span>, order <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 字典序,</span></span><br><span class="line">    indexMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> order &#123;</span><br><span class="line">        indexMap[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i&lt;<span class="built_in">len</span>(words);i++&#123;</span><br><span class="line">        first := words[i - <span class="number">1</span>]</span><br><span class="line">        second := words[i]</span><br><span class="line">        wlen := <span class="built_in">len</span>(first)</span><br><span class="line">        wflag := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(second) &lt; wlen &#123;</span><br><span class="line">            wlen = <span class="built_in">len</span>(second)</span><br><span class="line">            wflag = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; wlen;j ++ &#123;</span><br><span class="line">            indexFirst,_ := indexMap[<span class="type">rune</span>(first[j])]</span><br><span class="line">            indexSecond,_:= indexMap[<span class="type">rune</span>(second[j])]</span><br><span class="line">            <span class="keyword">if</span> indexFirst &gt; indexSecond &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> indexFirst &lt; indexSecond &#123;</span><br><span class="line">                <span class="comment">// 字典序</span></span><br><span class="line">                wflag = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//// 相同的地方[aab aa]</span></span><br><span class="line">        <span class="keyword">if</span> wflag &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="970-强整数-简单"><a href="#970-强整数-简单" class="headerlink" title="970. 强整数[简单]"></a>970. 强整数[简单]</h3><p>给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i &gt;&#x3D; 0 且 j &gt;&#x3D; 0，那么我们认为该整数是一个强整数。</p>
<p>返回值小于或等于 bound 的所有强整数组成的列表。</p>
<p>你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 2, y &#x3D; 3, bound &#x3D; 10<br>输出：[2,3,4,5,7,9,10]<br>解释：<br>2 &#x3D; 2^0 + 3^0<br>3 &#x3D; 2^1 + 3^0<br>4 &#x3D; 2^0 + 3^1<br>5 &#x3D; 2^1 + 3^1<br>7 &#x3D; 2^2 + 3^1<br>9 &#x3D; 2^3 + 3^0<br>10 &#x3D; 2^0 + 3^2<br>示例 2：</p>
<p>输入：x &#x3D; 3, y &#x3D; 5, bound &#x3D; 15<br>输出：[2,4,6,8,10,14]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 100<br>1 &lt;&#x3D; y &lt;&#x3D; 100<br>0 &lt;&#x3D; bound &lt;&#x3D; 10^6</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/powerful-integers">https://leetcode-cn.com/problems/powerful-integers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-21"><a href="#解法-21" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">powerfulIntegers</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>, bound <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    rMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">20</span> &amp;&amp; <span class="type">int</span>(math.Pow(<span class="type">float64</span>(y),<span class="type">float64</span>(i))) &lt;= bound;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="number">20</span> &amp;&amp; <span class="type">int</span>(math.Pow(<span class="type">float64</span>(x),<span class="type">float64</span>(j)))&lt;=bound;j ++&#123;</span><br><span class="line">            a := <span class="type">int</span>(math.Pow(<span class="type">float64</span>(y),<span class="type">float64</span>(i))) + <span class="type">int</span>(math.Pow(<span class="type">float64</span>(x),<span class="type">float64</span>(j)))</span><br><span class="line">            <span class="keyword">if</span> a &lt;= bound &#123;</span><br><span class="line">                rMap[a] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,_ := <span class="keyword">range</span> rMap&#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1002-查找常用字符-简单"><a href="#1002-查找常用字符-简单" class="headerlink" title="1002. 查找常用字符[简单]"></a>1002. 查找常用字符[简单]</h3><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[“bella”,”label”,”roller”]<br>输出：[“e”,”l”,”l”]<br>示例 2：</p>
<p>输入：[“cool”,”lock”,”cook”]<br>输出：[“c”,”o”]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &lt;&#x3D; 100<br>1 &lt;&#x3D; A[i].length &lt;&#x3D; 100<br>A[i][j] 是小写字母<br>通过次数45,781提交次数61,532</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-common-characters">https://leetcode-cn.com/problems/find-common-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-22"><a href="#解法-22" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonChars</span><span class="params">(A []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//  为每个字符串建立map,然后取map中元素的并集</span></span><br><span class="line">    mapArr := []<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> A &#123;</span><br><span class="line">        tempMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> _,c := <span class="keyword">range</span> v &#123;</span><br><span class="line">            tempMap[c] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mapArr = <span class="built_in">append</span>(mapArr, tempMap)</span><br><span class="line">    &#125;</span><br><span class="line">    tmpM := mapArr[<span class="number">0</span>]</span><br><span class="line">    retMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> tmpM &#123;</span><br><span class="line">        minVal := v</span><br><span class="line">        addAble := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>;i&lt;<span class="built_in">len</span>(mapArr);i++&#123;</span><br><span class="line">            <span class="keyword">if</span> v2, ok := mapArr[i][k];!ok &#123;</span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> v2 &lt; minVal &#123;</span><br><span class="line">                    minVal = v2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> addAble&#123;</span><br><span class="line">            retMap[k] = minVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> retMap&#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; v;i++&#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, <span class="type">string</span>(k))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1160-拼写单词-简单"><a href="#1160-拼写单词-简单" class="headerlink" title="1160. 拼写单词[简单]"></a>1160. 拼写单词[简单]</h3><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p>
<p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</p>
<p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：words &#x3D; [“cat”,”bt”,”hat”,”tree”], chars &#x3D; “atach”<br>输出：6<br>解释：<br>可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 &#x3D; 6。<br>示例 2：</p>
<p>输入：words &#x3D; [“hello”,”world”,”leetcode”], chars &#x3D; “welldonehoneyr”<br>输出：10<br>解释：<br>可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 &#x3D; 10。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; words.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; words[i].length, chars.length &lt;&#x3D; 100<br>所有字符串中都仅包含小写英文字母<br>通过次数49,812提交次数72,556</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-23"><a href="#解法-23" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countCharacters</span><span class="params">(words []<span class="type">string</span>, chars <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> chars &#123;</span><br><span class="line">        cMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> words &#123;</span><br><span class="line">        vMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> _, c := <span class="keyword">range</span> v &#123;</span><br><span class="line">            vMap[c] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        addAble := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> k2, v2 := <span class="keyword">range</span> vMap&#123;</span><br><span class="line">            <span class="keyword">if</span> v3,ok := cMap[k2]; !ok || v3 &lt; v2 &#123;</span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> addAble &#123;</span><br><span class="line">            ret += <span class="built_in">len</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1078-Bigram-分词-简单"><a href="#1078-Bigram-分词-简单" class="headerlink" title="1078. Bigram 分词[简单]"></a>1078. Bigram 分词[简单]</h3><p>给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 “first second third” 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。</p>
<p>对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：text &#x3D; “alice is a good girl she is a good student”, first &#x3D; “a”, second &#x3D; “good”<br>输出：[“girl”,”student”]<br>示例 2：</p>
<p>输入：text &#x3D; “we will we will rock you”, first &#x3D; “we”, second &#x3D; “will”<br>输出：[“we”,”rock”]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; text.length &lt;&#x3D; 1000<br>text 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成<br>1 &lt;&#x3D; first.length, second.length &lt;&#x3D; 10<br>first 和 second 由小写英文字母组成<br>通过次数8,434提交次数13,664</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/occurrences-after-bigram">https://leetcode-cn.com/problems/occurrences-after-bigram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-24"><a href="#解法-24" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOcurrences</span><span class="params">(text <span class="type">string</span>, first <span class="type">string</span>, second <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    words := strings.Split(text, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; <span class="built_in">len</span>(words);&#123;</span><br><span class="line">        <span class="keyword">if</span> words[i <span class="number">-1</span>] == first &amp;&amp; words[i] == second &#123;</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(words) &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, words[i + <span class="number">1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1189-“气球”-的最大数量-简单"><a href="#1189-“气球”-的最大数量-简单" class="headerlink" title="1189. “气球” 的最大数量[简单]"></a>1189. “气球” 的最大数量[简单]</h3><p>给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。</p>
<p>字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：text &#x3D; “nlaebolko”<br>输出：1<br>示例 2：</p>
<p>输入：text &#x3D; “loonbalxballpoon”<br>输出：2<br>示例 3：</p>
<p>输入：text &#x3D; “leetcode”<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; text.length &lt;&#x3D; 10^4<br>text 全部由小写英文字母组成<br>通过次数14,925提交次数23,392</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-number-of-balloons">https://leetcode-cn.com/problems/maximum-number-of-balloons</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-25"><a href="#解法-25" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNumberOfBalloons</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    bMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> <span class="string">&quot;balloon&quot;</span>&#123;</span><br><span class="line">        bMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">1</span> &lt;&lt; (<span class="number">32</span> <span class="number">-1</span>)</span><br><span class="line">    tMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> text &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := bMap[v];ok &#123;</span><br><span class="line">            tMap[v] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> bMap&#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := tMap[k];!ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> v2 / v &lt; ret &#123;</span><br><span class="line">                ret = v2 / v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1207-独一无二的出现次数-简单"><a href="#1207-独一无二的出现次数-简单" class="headerlink" title="1207. 独一无二的出现次数[简单]"></a>1207. 独一无二的出现次数[简单]</h3><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [1,2,2,1,1,3]<br>输出：true<br>解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。<br>示例 2：</p>
<p>输入：arr &#x3D; [1,2]<br>输出：false<br>示例 3：</p>
<p>输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; arr[i] &lt;&#x3D; 1000<br>通过次数50,961提交次数69,561</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-number-of-occurrences">https://leetcode-cn.com/problems/unique-number-of-occurrences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-26"><a href="#解法-26" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniqueOccurrences</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    aMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        aMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> aMap&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := nMap[v];!ok &#123;</span><br><span class="line">            nMap[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-01-04-回文排列-简单"><a href="#面试题-01-04-回文排列-简单" class="headerlink" title="面试题 01.04. 回文排列[简单]"></a>面试题 01.04. 回文排列[简单]</h3><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<p> </p>
<p>示例1：</p>
<p>输入：”tactcoa”<br>输出：true（排列有”tacocat”、”atcocta”，等等）
 </p>
<p>通过次数20,609提交次数37,87</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-permutation-lcci">https://leetcode-cn.com/problems/palindrome-permutation-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-27"><a href="#解法-27" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPermutePalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 有个key值大于等于2便可以判定</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    oddNum := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> sMap&#123;</span><br><span class="line">        <span class="keyword">if</span> v % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            oddNum -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> oddNum &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1539-第-k-个缺失的正整数-简单"><a href="#1539-第-k-个缺失的正整数-简单" class="headerlink" title="1539. 第 k 个缺失的正整数[简单]"></a>1539. 第 k 个缺失的正整数[简单]</h3><p>给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。</p>
<p>请你找到这个数组里第 k 个缺失的正整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [2,3,4,7,11], k &#x3D; 5<br>输出：9<br>解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,…] 。第 5 个缺失的正整数为 9 。<br>示例 2：</p>
<p>输入：arr &#x3D; [1,2,3,4], k &#x3D; 2<br>输出：6<br>解释：缺失的正整数包括 [5,6,7,…] 。第 2 个缺失的正整数为 6 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 1000<br>1 &lt;&#x3D; k &lt;&#x3D; 1000<br>对于所有 1 &lt;&#x3D; i &lt; j &lt;&#x3D; arr.length 的 i 和 j 满足 arr[i] &lt; arr[j] <br>通过次数6,505提交次数12,027</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-missing-positive-number">https://leetcode-cn.com/problems/kth-missing-positive-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-28"><a href="#解法-28" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findKthPositive</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    aMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr&#123;</span><br><span class="line">        aMap[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lossNumber := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i &lt; <span class="number">10000</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := aMap[i];!ok&#123;</span><br><span class="line">            lossNumber +=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> lossNumber == k &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1365-有多少小于当前数字的数字-简单"><a href="#1365-有多少小于当前数字的数字-简单" class="headerlink" title="1365. 有多少小于当前数字的数字[简单]"></a>1365. 有多少小于当前数字的数字[简单]</h3><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j !&#x3D; i 且 nums[j] &lt; nums[i] 。</p>
<p>以数组形式返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [8,1,2,2,3]<br>输出：[4,0,1,1,3]<br>解释：<br>对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。<br>对于 nums[1]&#x3D;1 不存在比它小的数字。<br>对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。<br>对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。<br>对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。<br>示例 2：</p>
<p>输入：nums &#x3D; [6,5,4,8]<br>输出：[2,1,0,3]<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7]<br>输出：[0,0,0,0]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 500<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number">https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-29"><a href="#解法-29" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">smallerNumbersThanCurrent</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        t := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := v <span class="number">-1</span>;i &gt;= <span class="number">0</span>;i -- &#123;</span><br><span class="line">            <span class="keyword">if</span> n, ok := nMap[i];ok &#123;</span><br><span class="line">                t += n</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, t)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1512-好数对的数目-简单"><a href="#1512-好数对的数目-简单" class="headerlink" title="1512. 好数对的数目[简单]"></a>1512. 好数对的数目[简单]</h3><p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] &#x3D;&#x3D; nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p>
<p>返回好数对的数目。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1,1,3]<br>输出：4<br>解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始<br>示例 2：</p>
<p>输入：nums &#x3D; [1,1,1,1]<br>输出：6<br>解释：数组中的每组数字都是好数对<br>示例 3：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100<br>通过次数33,037提交次数38,800</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-pairs">https://leetcode-cn.com/problems/number-of-good-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-30"><a href="#解法-30" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numIdenticalPairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>;j &lt; <span class="built_in">len</span>(nums);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[j] &#123;</span><br><span class="line">                ret += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1625-执行操作后字典序最小的字符串-中等"><a href="#1625-执行操作后字典序最小的字符串-中等" class="headerlink" title="1625. 执行操作后字典序最小的字符串[中等]"></a>1625. 执行操作后字典序最小的字符串[中等]</h3><p>给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。</p>
<p>你可以在 s 上按任意顺序多次执行下面两个操作之一：</p>
<p>累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s &#x3D; “3456” 且 a &#x3D; 5，则执行此操作后 s 变成 “3951”。<br>轮转：将 s 向右轮转 b 位。例如，s &#x3D; “3456” 且 b &#x3D; 1，则执行此操作后 s 变成 “6345”。<br>请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。</p>
<p>如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，”0158” 字典序比 “0190” 小，因为不同的第一个位置是在第三个字符，显然 ‘5’ 出现在 ‘9’ 之前。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “5525”, a &#x3D; 9, b &#x3D; 2<br>输出：”2050”<br>解释：执行操作如下：<br>初态：”5525”<br>轮转：”2555”<br>累加：”2454”<br>累加：”2353”<br>轮转：”5323”<br>累加：”5222”<br>累加：”5121”<br>轮转：”2151”<br>累加：”2050”​​​​​​​​​​​​<br>无法获得字典序小于 “2050” 的字符串。<br>示例 2：</p>
<p>输入：s &#x3D; “74”, a &#x3D; 5, b &#x3D; 1<br>输出：”24”<br>解释：执行操作如下：<br>初态：”74”<br>轮转：”47”<br>累加：”42”<br>轮转：”24”​​​​​​​​​​​​<br>无法获得字典序小于 “24” 的字符串。<br>示例 3：</p>
<p>输入：s &#x3D; “0011”, a &#x3D; 4, b &#x3D; 2<br>输出：”0011”<br>解释：无法获得字典序小于 “0011” 的字符串。<br>示例 4：</p>
<p>输入：s &#x3D; “43987654”, a &#x3D; 7, b &#x3D; 3<br>输出：”00553311”
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s.length 是偶数<br>s 仅由数字 0 到 9 组成<br>1 &lt;&#x3D; a &lt;&#x3D; 9<br>1 &lt;&#x3D; b &lt;&#x3D; s.length - 1<br>通过次数2,071提交次数4,004</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations">https://leetcode-cn.com/problems/lexicographically-smallest-string-after-applying-operations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-31"><a href="#解法-31" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加偶数位操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aF</span><span class="params">(s <span class="type">string</span>, a <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    tmp2 := []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span> ; i &lt; <span class="built_in">len</span>(s); i += <span class="number">2</span> &#123;</span><br><span class="line">        tmp2N,_ := strconv.Atoi(<span class="type">string</span>(tmp2[i]))</span><br><span class="line">        tmp2[i] = <span class="type">byte</span>(<span class="string">&#x27;0&#x27;</span> + (tmp2N + a)%<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(tmp2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 累加奇数位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aF2</span><span class="params">(s <span class="type">string</span>, a <span class="type">int</span>)</span></span> <span class="type">string</span>  &#123;</span><br><span class="line">    tmp2 := []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(s); i += <span class="number">2</span> &#123;</span><br><span class="line">        tmp2N,_ := strconv.Atoi(<span class="type">string</span>(tmp2[i]))</span><br><span class="line">        tmp2[i] = <span class="type">byte</span>(<span class="string">&#x27;0&#x27;</span> + (tmp2N + a)%<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(tmp2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 轮转操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bF</span><span class="params">(s <span class="type">string</span>, b <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    tmp2 := []<span class="type">byte</span>(s)</span><br><span class="line">    tmp2B := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> tmp2[<span class="built_in">len</span>(tmp2) - b:] &#123;</span><br><span class="line">        tmp2B = <span class="built_in">append</span>(tmp2B, v)</span><br><span class="line">    &#125;</span><br><span class="line">    tmp2B = <span class="built_in">append</span>(tmp2B, tmp2[:<span class="built_in">len</span>(tmp2) - b]...)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(tmp2B)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLexSmallestString</span><span class="params">(s <span class="type">string</span>, a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    minNumstr := s</span><br><span class="line">    <span class="comment">// 一个数 经过10次累加之后,回到初始状态</span></span><br><span class="line">    <span class="comment">// 一个数 经过len(s)次轮转之后,回到初始状态</span></span><br><span class="line">    <span class="comment">// 对于偶数轮转来说: 累加只能改变奇数位,偶数位不会被累加。所有的枚举结果: len(s) * 10</span></span><br><span class="line">    <span class="comment">// 对于奇数轮转来说: 虽然累加只能改变奇数位,但是经过轮转之后,奇数位变成偶数位,偶数位变成奇数位。这时候,奇数位，偶数位都应该累加。</span></span><br><span class="line">    </span><br><span class="line">    tmp := s</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(s);i ++&#123;</span><br><span class="line">        <span class="comment">// 轮转</span></span><br><span class="line">        tmp = bF(tmp, b)</span><br><span class="line">        <span class="keyword">if</span> tmp &lt; minNumstr &#123;</span><br><span class="line">            minNumstr = tmp</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fmt.Println(tmp)</span></span><br><span class="line">        <span class="comment">//// 对轮转之后的结果进行累加</span></span><br><span class="line">        addStr := tmp</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="number">10</span>;j ++&#123;</span><br><span class="line">           <span class="comment">// 累加完偶数位</span></span><br><span class="line">           addStr= aF(addStr, a)</span><br><span class="line">           <span class="keyword">if</span> addStr &lt; minNumstr &#123;</span><br><span class="line">               minNumstr = addStr</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果是奇数,把奇数位也累加</span></span><br><span class="line">           <span class="keyword">if</span> b % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> k := <span class="number">0</span>;k &lt; <span class="number">10</span>;k ++ &#123;</span><br><span class="line">                   addStr = aF2(addStr, a)</span><br><span class="line">                   <span class="keyword">if</span> addStr &lt; minNumstr&#123;</span><br><span class="line">                       minNumstr = addStr</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNumstr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="228-汇总区间-简单"><a href="#228-汇总区间-简单" class="headerlink" title="228. 汇总区间[简单]"></a>228. 汇总区间[简单]</h3><p>给定一个无重复元素的有序整数数组 nums 。</p>
<p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
<p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p>
<p>“a-&gt;b” ，如果 a !&#x3D; b<br>“a” ，如果 a &#x3D;&#x3D; b
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [0,1,2,4,5,7]<br>输出：[“0-&gt;2”,”4-&gt;5”,”7”]<br>解释：区间范围是：<br>[0,2] –&gt; “0-&gt;2”<br>[4,5] –&gt; “4-&gt;5”<br>[7,7] –&gt; “7”<br>示例 2：</p>
<p>输入：nums &#x3D; [0,2,3,4,6,8,9]<br>输出：[“0”,”2-&gt;4”,”6”,”8-&gt;9”]<br>解释：区间范围是：<br>[0,0] –&gt; “0”<br>[2,4] –&gt; “2-&gt;4”<br>[6,6] –&gt; “6”<br>[8,9] –&gt; “8-&gt;9”<br>示例 3：</p>
<p>输入：nums &#x3D; []<br>输出：[]<br>示例 4：</p>
<p>输入：nums &#x3D; [-1]<br>输出：[“-1”]<br>示例 5：</p>
<p>输入：nums &#x3D; [0]<br>输出：[“0”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 20<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums 中的所有值都 互不相同<br>通过次数16,046提交次数29,801</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/summary-ranges">https://leetcode-cn.com/problems/summary-ranges</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-32"><a href="#解法-32" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">summaryRanges</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    tmp := []<span class="type">int</span>&#123;nums[<span class="number">0</span>]&#125;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span>; i &lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i - <span class="number">1</span>] + <span class="number">1</span> &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, nums[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不相等</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) &gt; <span class="number">1</span> &#123;</span><br><span class="line">                clip := fmt.Sprintf(<span class="string">&quot;%d-&gt;%d&quot;</span>,tmp[<span class="number">0</span>],tmp[<span class="built_in">len</span>(tmp)<span class="number">-1</span>])</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, clip)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">1</span>&#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,tmp[<span class="number">0</span>]))</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, nums[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tmp) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        clip := fmt.Sprintf(<span class="string">&quot;%d-&gt;%d&quot;</span>,tmp[<span class="number">0</span>],tmp[<span class="built_in">len</span>(tmp)<span class="number">-1</span>])</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, clip)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">1</span>&#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,tmp[<span class="number">0</span>]))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1122-数组的相对排序-简单"><a href="#1122-数组的相对排序-简单" class="headerlink" title="1122. 数组的相对排序[简单]"></a>1122. 数组的相对排序[简单]</h3><p>给你两个数组，arr1 和 arr2，</p>
<p>arr2 中的元素各不相同<br>arr2 中的每个元素都出现在 arr1 中<br>对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<p> </p>
<p>示例：</p>
<p>输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]<br>输出：[2,2,2,1,4,3,3,9,6,7,19]
 </p>
<p>提示：</p>
<p>arr1.length, arr2.length &lt;&#x3D; 1000<br>0 &lt;&#x3D; arr1[i], arr2[i] &lt;&#x3D; 1000<br>arr2 中的元素 arr2[i] 各不相同<br>arr2 中的每个元素 arr2[i] 都出现在 arr1 中<br>通过次数33,354提交次数48,291</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/relative-sort-array">https://leetcode-cn.com/problems/relative-sort-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-33"><a href="#解法-33" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relativeSortArray</span><span class="params">(arr1 []<span class="type">int</span>, arr2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    a1Map := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr1&#123;</span><br><span class="line">        a1Map[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr2 &#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := a1Map[v];ok &#123;</span><br><span class="line">            <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; v2 ;i ++&#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">delete</span>(a1Map, v)</span><br><span class="line">    &#125;</span><br><span class="line">    tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> a1Map&#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i&lt;v;i ++&#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(tmp)</span><br><span class="line">    ret = <span class="built_in">append</span>(ret, tmp...)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5550-拆炸弹-简单"><a href="#5550-拆炸弹-简单" class="headerlink" title="5550. 拆炸弹[简单]"></a>5550. 拆炸弹[简单]</h3><p>你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。</p>
<p>为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。</p>
<p>如果 k &gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。<br>如果 k &lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。<br>如果 k &#x3D;&#x3D; 0 ，将第 i 个数字用 0 替换。<br>由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。</p>
<p>给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！</p>
<p>示例 1：</p>
<p>输入：code &#x3D; [5,7,1,4], k &#x3D; 3<br>输出：[12,10,16,13]<br>解释：每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。<br>示例 2：</p>
<p>输入：code &#x3D; [1,2,3,4], k &#x3D; 0<br>输出：[0,0,0,0]<br>解释：当 k 为 0 时，所有数字都被 0 替换。<br>示例 3：</p>
<p>输入：code &#x3D; [2,4,9,3], k &#x3D; -2<br>输出：[12,5,6,13]<br>解释：解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。</p>
<p>提示：</p>
<p>n &#x3D;&#x3D; code.length<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>1 &lt;&#x3D; code[i] &lt;&#x3D; 100<br>-(n - 1) &lt;&#x3D; k &lt;&#x3D; n - 1</p>
<h4 id="解法-34"><a href="#解法-34" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrypt</span><span class="params">(code []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> k &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(code);i++&#123;</span><br><span class="line">            replace := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; k + i + <span class="number">1</span>;j ++&#123;</span><br><span class="line">                replace += code[j % <span class="built_in">len</span>(code)]</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, replace)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> k &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(code);i ++&#123;</span><br><span class="line">            replace := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j := i - <span class="number">1</span>;j &gt; i + k - <span class="number">1</span>;j --&#123;</span><br><span class="line">                replace += code[(j + <span class="built_in">len</span>(code)) % <span class="built_in">len</span>(code)]</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, replace)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> k == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;<span class="built_in">len</span>(code);i ++&#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5551-使字符串平衡的最少删除次数-中等"><a href="#5551-使字符串平衡的最少删除次数-中等" class="headerlink" title="5551. 使字符串平衡的最少删除次数[中等]"></a>5551. 使字符串平衡的最少删除次数[中等]</h3><p>给你一个字符串 s ，它仅包含字符 ‘a’ 和 ‘b’​​​​ 。</p>
<p>你可以删除 s 中任意数目的字符，使得 s 平衡 。我们称 s 平衡的 当不存在下标对 (i,j) 满足 i &lt; j 且 s[i] &#x3D; ‘b’ 同时 s[j]&#x3D; ‘a’ 。</p>
<p>请你返回使 s 平衡 的 最少 删除次数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “aababbab”<br>输出：2<br>解释：你可以选择以下任意一种方案：<br>下标从 0 开始，删除第 2 和第 6 个字符（”aababbab” -&gt; “aaabbb”），<br>下标从 0 开始，删除第 3 和第 6 个字符（”aababbab” -&gt; “aabbbb”）。<br>示例 2：</p>
<p>输入：s &#x3D; “bbaaaaabb”<br>输出：2<br>解释：唯一的最优解是删除最前面两个字符。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i] 要么是 ‘a’ 要么是 ‘b’​ 。​<br>通过次数976提交次数2,651</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced">https://leetcode-cn.com/problems/minimum-deletions-to-make-string-balanced</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-35"><a href="#解法-35" class="headerlink" title="解法"></a>解法</h4><p>从0到n建立分割点,分割点左边全是a,分割点右边全是b。然后计算删除最小分割点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumDeletions</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minDelete := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(s); i ++ &#123;</span><br><span class="line">        <span class="comment">// 获得a组</span></span><br><span class="line">        tmpLen := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt;= i;j ++&#123;</span><br><span class="line">            <span class="keyword">if</span> s[j] == <span class="string">&#x27;a&#x27;</span>&#123;</span><br><span class="line">                tmpLen += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得b组</span></span><br><span class="line">        <span class="keyword">for</span> k := i;k &lt; <span class="built_in">len</span>(s);k ++&#123;</span><br><span class="line">            <span class="keyword">if</span> s[k] == <span class="string">&#x27;b&#x27;</span>&#123;</span><br><span class="line">                tmpLen +=<span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) - tmpLen &lt; minDelete&#123;</span><br><span class="line">            minDelete = <span class="built_in">len</span>(s) - tmpLen</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDelete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码会超时,因为每个分割点都需要重新计算之前计算过的值。使用备忘录来减少计算量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumDeletions</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    minDelete := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 计算分割点0....n时a的个数</span></span><br><span class="line">    <span class="comment">// 计算分割点0....n时b的个数</span></span><br><span class="line">    <span class="comment">// 对于a,当前值为a,对应的分割点a值等于(i-1) + 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于b,从后往前数,计算过程和a一致</span></span><br><span class="line">    alen := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    blen := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="comment">//计算a</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>&#123;</span><br><span class="line">        alen[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(s);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;a&#x27;</span> &#123;</span><br><span class="line">            alen[i] = alen[i <span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alen[i] = alen[i <span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算b</span></span><br><span class="line">    <span class="keyword">if</span> s[<span class="built_in">len</span>(s) - <span class="number">1</span>] == <span class="string">&#x27;b&#x27;</span>&#123;</span><br><span class="line">        blen[<span class="built_in">len</span>(s) <span class="number">-1</span>] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s) - <span class="number">2</span>; i &gt;= <span class="number">0</span>;i --&#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;b&#x27;</span>&#123;</span><br><span class="line">            blen[i] = blen[i + <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            blen[i] = blen[i + <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) - (alen[i] + blen[i]) &lt; minDelete&#123;</span><br><span class="line">            minDelete = <span class="built_in">len</span>(s) - (alen[i] + blen[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> minDelete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402. 移掉K位数字"></a>402. 移掉K位数字</h3><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<p>num 的长度小于 10002 且 ≥ k。<br>num 不会包含任何前导零。<br>示例 1 :</p>
<p>输入: num &#x3D; “1432219”, k &#x3D; 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。<br>示例 2 :</p>
<p>输入: num &#x3D; “10200”, k &#x3D; 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 :</p>
<p>输入: num &#x3D; “10”, k &#x3D; 2<br>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。<br>通过次数37,724提交次数120,200</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits">https://leetcode-cn.com/problems/remove-k-digits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-36"><a href="#解法-36" class="headerlink" title="解法"></a>解法</h4><p>由于可以删除的次数有限,每删除一个字符,数字的位数就降低一位。所以，删除的时候肯定要在高位删除，怎么删除？如果当前的字符大于后面的字符，删除该字符的成效是最高的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeKdigits</span><span class="params">(num <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    tmp := []<span class="type">rune</span>(num)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; k;i ++&#123;</span><br><span class="line">        <span class="comment">// 删除高位肯定是赚的</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(tmp);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(tmp) - <span class="number">1</span> &#123;</span><br><span class="line">                tmp = tmp[:j]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> tmp[j] &gt; tmp[j + <span class="number">1</span>]&#123;</span><br><span class="line">                    tmp = <span class="built_in">append</span>(tmp[:j], tmp[j + <span class="number">1</span>:]...)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去零输出</span></span><br><span class="line">    ret := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">    deleteable := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> tmp&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;0&#x27;</span> &amp;&amp; deleteable&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            deleteable = <span class="literal">false</span></span><br><span class="line">            ret = <span class="built_in">append</span>(ret, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ret) &lt;= <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串-简单"><a href="#3-无重复字符的最长子串-简单" class="headerlink" title="3. 无重复字符的最长子串[简单]"></a>3. 无重复字符的最长子串[简单]</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。<br>通过次数726,574提交次数2,026,880</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-37"><a href="#解法-37" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    start,end := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(s);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 开始指针右移动</span></span><br><span class="line">            <span class="built_in">delete</span>(cMap, s[start])</span><br><span class="line">            start ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := end; j &lt; <span class="built_in">len</span>(s);j++&#123;</span><br><span class="line">            <span class="comment">// 尝试往右移动</span></span><br><span class="line">            <span class="keyword">if</span> _,ok := cMap[s[j]]; !ok &#123;</span><br><span class="line">                cMap[s[j]] = <span class="number">1</span></span><br><span class="line">                end ++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> end - start &gt; maxLen&#123;</span><br><span class="line">            maxLen = end - start</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1030-距离顺序排列矩阵单元格-简单"><a href="#1030-距离顺序排列矩阵单元格-简单" class="headerlink" title="1030. 距离顺序排列矩阵单元格[简单]"></a>1030. 距离顺序排列矩阵单元格[简单]</h3><p>给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;&#x3D; r &lt; R 且 0 &lt;&#x3D; c &lt; C。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）</p>
<p> </p>
<p>示例 1：</p>
<p>输入：R &#x3D; 1, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 0<br>输出：[[0,0],[0,1]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1]<br>示例 2：</p>
<p>输入：R &#x3D; 2, C &#x3D; 2, r0 &#x3D; 0, c0 &#x3D; 1<br>输出：[[0,1],[0,0],[1,1],[1,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]<br>[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。<br>示例 3：</p>
<p>输入：R &#x3D; 2, C &#x3D; 3, r0 &#x3D; 1, c0 &#x3D; 2<br>输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]<br>解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]<br>其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; R &lt;&#x3D; 100<br>1 &lt;&#x3D; C &lt;&#x3D; 100<br>0 &lt;&#x3D; r0 &lt; R<br>0 &lt;&#x3D; c0 &lt; C<br>通过次数30,037提交次数42,187</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order">https://leetcode-cn.com/problems/matrix-cells-in-distance-order</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-38"><a href="#解法-38" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allCellsDistOrder</span><span class="params">(R <span class="type">int</span>, C <span class="type">int</span>, r0 <span class="type">int</span>, c0 <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 距离计算: |r0 - Rn| + |c0 - Cn|。其中Rn(0-R), Cn(0 - C)。</span></span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    tmp := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dis := []<span class="type">int</span>&#123;&#125; <span class="comment">// 距离</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; R;i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; C;j ++&#123;</span><br><span class="line">            d := abs(i - r0) + abs(j - c0)</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, []<span class="type">int</span>&#123;i, j&#125;)</span><br><span class="line">            dis = <span class="built_in">append</span>(dis, d)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dis);i ++&#123;</span><br><span class="line">        minIndex := <span class="number">0</span></span><br><span class="line">        minDis := <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(dis); j ++&#123;</span><br><span class="line">            <span class="keyword">if</span> dis[j] &lt; minDis &#123;</span><br><span class="line">                minDis = dis[j]</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, tmp[minIndex])</span><br><span class="line">        dis[minIndex] = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-三数之和-中等"><a href="#15-三数之和-中等" class="headerlink" title="15. 三数之和[中等]"></a>15. 三数之和[中等]</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p> </p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]<br>通过次数365,190提交次数1,215,505<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum">https://leetcode-cn.com/problems/3sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-39"><a href="#解法-39" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        nMap[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; <span class="built_in">len</span>(nums); first++&#123;</span><br><span class="line">        <span class="comment">// 定位第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]&#123;</span><br><span class="line">            <span class="comment">// 去掉重复的</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>;second &lt; <span class="built_in">len</span>(nums); second ++&#123;</span><br><span class="line">            <span class="comment">// 定位第二个元素</span></span><br><span class="line">            <span class="keyword">if</span> second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            k := <span class="number">-1</span> * (nums[first] + nums[second])</span><br><span class="line">            <span class="keyword">if</span> v,ok := nMap[k];ok &amp;&amp; v &gt; second &#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;nums[first], nums[second], k&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-17-16-按摩师-简单"><a href="#面试题-17-16-按摩师-简单" class="headerlink" title="面试题 17.16. 按摩师[简单]"></a>面试题 17.16. 按摩师[简单]</h3><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<p>注意：本题相对原题稍作改动</p>
<p> </p>
<p>示例 1：</p>
<p>输入： [1,2,3,1]<br>输出： 4<br>解释： 选择 1 号预约和 3 号预约，总时长 &#x3D; 1 + 3 &#x3D; 4。<br>示例 2：</p>
<p>输入： [2,7,9,3,1]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 &#x3D; 2 + 9 + 1 &#x3D; 12。<br>示例 3：</p>
<p>输入： [2,1,4,5,3,1,1,3]<br>输出： 12<br>解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 &#x3D; 2 + 4 + 3 + 3 &#x3D; 12。<br>通过次数41,505提交次数78,530</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/the-masseuse-lcci">https://leetcode-cn.com/problems/the-masseuse-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-40"><a href="#解法-40" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">massage</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i <span class="number">-1</span>] &gt; nums[i] &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">2</span>] + nums[i] &gt; dp[i - <span class="number">1</span>]&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + nums[i]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i <span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max&#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-42-连续子数组的最大和-简单"><a href="#剑指-Offer-42-连续子数组的最大和-简单" class="headerlink" title="剑指 Offer 42. 连续子数组的最大和[简单]"></a>剑指 Offer 42. 连续子数组的最大和[简单]</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p> </p>
<p>示例1:</p>
<p>输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5<br>-100 &lt;&#x3D; arr[i] &lt;&#x3D; 100<br>注意：本题与主站 53 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p> </p>
<p>通过次数83,080提交次数139,064</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-41"><a href="#解法-41" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点,选取的最大是需要变得更大的</span></span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] + nums[i] &gt; nums[i]&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> max &lt; dp[i] &#123;</span><br><span class="line">                max = dp[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-01-三步问题-简单"><a href="#面试题-08-01-三步问题-简单" class="headerlink" title="面试题 08.01. 三步问题[简单]"></a>面试题 08.01. 三步问题[简单]</h3><p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<p>示例1:</p>
<p> 输入：n &#x3D; 3<br> 输出：4<br> 说明: 有四种走法<br>示例2:</p>
<p> 输入：n &#x3D; 5<br> 输出：13<br>提示:</p>
<p>n范围在[1, 1000000]之间<br>通过次数22,922提交次数64,829</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/three-steps-problem-lcci">https://leetcode-cn.com/problems/three-steps-problem-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-42"><a href="#解法-42" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waysToStep</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 100</span></span><br><span class="line">    <span class="comment">// 1,2,3</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] + <span class="number">1</span>) % <span class="number">100</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">3</span>]) % <span class="number">1000000007</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="392-判断子序列-简单"><a href="#392-判断子序列-简单" class="headerlink" title="392. 判断子序列[简单]"></a>392. 判断子序列[简单]</h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~&#x3D; 500,000），而 s 是个短字符串（长度 &lt;&#x3D;100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<p>示例 1:<br>s &#x3D; “abc”, t &#x3D; “ahbgdc”</p>
<p>返回 true.</p>
<p>示例 2:<br>s &#x3D; “axc”, t &#x3D; “ahbgdc”</p>
<p>返回 false.</p>
<p>后续挑战 :</p>
<p>如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;&#x3D; 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p>致谢:</p>
<p>特别感谢 @pbrother 添加此问题并且创建所有测试用例。</p>
<p>通过次数95,681提交次数189,045</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence">https://leetcode-cn.com/problems/is-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-43"><a href="#解法-43" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 一个一个比较,不用从头开始</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    equalSize := <span class="number">0</span></span><br><span class="line">    slen := <span class="built_in">len</span>(s)</span><br><span class="line">    tlen := <span class="built_in">len</span>(t)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; slen; i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := start; j &lt; tlen;j ++&#123;</span><br><span class="line">            start = j</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">                equalSize += <span class="number">1</span></span><br><span class="line">                start ++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> equalSize == slen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="746-使用最小花费爬楼梯-简单"><a href="#746-使用最小花费爬楼梯-简单" class="headerlink" title="746. 使用最小花费爬楼梯[简单]"></a>746. 使用最小花费爬楼梯[简单]</h3><p>数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="%E7%B4%A2%E5%BC%95%E4%BB%8E0%E5%BC%80%E5%A7%8B">i</a>。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p>示例 1:</p>
<p>输入: cost &#x3D; [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。<br> 示例 2:</p>
<p>输入: cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。<br>注意：</p>
<p>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。<br>通过次数49,537提交次数99,055</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs">https://leetcode-cn.com/problems/min-cost-climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-44"><a href="#解法-44" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCostClimbingStairs</span><span class="params">(cost []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(cost))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(cost);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = cost[i]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span>&#123;</span><br><span class="line">            dp[i] = cost[i]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i <span class="number">-1</span>] &lt; dp[i - <span class="number">2</span>]&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + cost[i]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">2</span>] + cost[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cost) - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; dp[<span class="built_in">len</span>(cost) - <span class="number">2</span>] &lt; dp[<span class="built_in">len</span>(cost) <span class="number">-1</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(cost) - <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(cost) <span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="303-区域和检索-数组不可变-检索"><a href="#303-区域和检索-数组不可变-检索" class="headerlink" title="303. 区域和检索 - 数组不可变[检索]"></a>303. 区域和检索 - 数组不可变[检索]</h3><p>给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。</p>
<p>实现 NumArray 类：</p>
<p>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], … , nums[j])）
 </p>
<p>示例：</p>
<p>输入：<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]<br>输出：<br>[null, 1, -1, -3]</p>
<p>解释：<br>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105<br>0 &lt;&#x3D; i &lt;&#x3D; j &lt; nums.length<br>最多调用 104 次 sumRange 方法<br>通过次数59,723提交次数93,547</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable">https://leetcode-cn.com/problems/range-sum-query-immutable</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-45"><a href="#解法-45" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    ret []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="type">int</span>)</span></span> NumArray &#123;</span><br><span class="line">    arr := NumArray&#123;&#125;</span><br><span class="line">    last := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;<span class="built_in">len</span>(nums);i ++&#123;</span><br><span class="line">        last += nums[i]</span><br><span class="line">        arr.ret = <span class="built_in">append</span>(arr.ret, last)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span></span> SumRange(i <span class="type">int</span>, j <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this.ret[j]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.ret[j] - this.ret[i] +(this.ret[i] - this.ret[i - <span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(nums);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.SumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="198-打家劫舍-简单"><a href="#198-打家劫舍-简单" class="headerlink" title="198. 打家劫舍[简单]"></a>198. 打家劫舍[简单]</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400<br>通过次数209,567提交次数445,961</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber">https://leetcode-cn.com/problems/house-robber</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-46"><a href="#解法-46" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    max := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i <span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i] = nums[i]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i <span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>] &gt; nums[i] + dp[i - <span class="number">2</span>]&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i] + dp[i - <span class="number">2</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-四数之和-简单"><a href="#18-四数之和-简单" class="headerlink" title="18. 四数之和[简单]"></a>18. 四数之和[简单]</h3><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]<br>通过次数136,237提交次数346,498</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum">https://leetcode-cn.com/problems/4sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-47"><a href="#解法-47" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> first := <span class="number">0</span>; first &lt; n; first ++&#123;</span><br><span class="line">        <span class="keyword">for</span> second := first + <span class="number">1</span>;second &lt; n;second ++&#123;</span><br><span class="line">            <span class="keyword">for</span> third := second + <span class="number">1</span>;third &lt; n; third ++&#123;</span><br><span class="line">                <span class="keyword">if</span> v, ok := nMap[target - (nums[first] + nums[second] + nums[third])];ok &amp;&amp; v &gt; third &#123;</span><br><span class="line">                    addAble := <span class="literal">true</span></span><br><span class="line">                    tmp := []<span class="type">int</span>&#123;nums[first], nums[second], nums[third], nums[v]&#125;</span><br><span class="line">                    <span class="keyword">for</span> _,v := <span class="keyword">range</span> ret &#123;</span><br><span class="line">                        <span class="keyword">if</span> v[<span class="number">0</span>] == tmp[<span class="number">0</span>] &amp;&amp; v[<span class="number">1</span>] == tmp[<span class="number">1</span>] &amp;&amp; v[<span class="number">2</span>] == tmp[<span class="number">2</span>] &amp;&amp; v[<span class="number">3</span>] == tmp[<span class="number">3</span>] &#123;</span><br><span class="line">                            addAble = <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> addAble &#123;</span><br><span class="line">                        ret = <span class="built_in">append</span>(ret, tmp)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="148-排序链表-简单"><a href="#148-排序链表-简单" class="headerlink" title="148. 排序链表[简单]"></a>148. 排序链表[简单]</h3><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p>进阶：</p>
<p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>通过次数117,556提交次数173,664</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-48"><a href="#解法-48" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cur :=head;cur != <span class="literal">nil</span>;cur = cur.Next &#123;</span><br><span class="line">        tmp = <span class="built_in">append</span>(tmp, cur.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(tmp)</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> cur := head;cur != <span class="literal">nil</span>;cur = cur.Next&#123;</span><br><span class="line">        cur.Val = tmp[index]</span><br><span class="line">        index ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-64-求1-2-…-n-中等"><a href="#剑指-Offer-64-求1-2-…-n-中等" class="headerlink" title="剑指 Offer 64. 求1+2+…+n[中等]"></a>剑指 Offer 64. 求1+2+…+n[中等]</h3><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: n &#x3D; 3<br>输出: 6<br>示例 2：</p>
<p>输入: n &#x3D; 9<br>输出: 45
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 10000<br>通过次数75,194提交次数88,313</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qiu-12n-lcof">https://leetcode-cn.com/problems/qiu-12n-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-49"><a href="#解法-49" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span><span class="type">bool</span></span><br><span class="line">    sum = <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        ret += i</span><br><span class="line">        <span class="comment">// 短路特性做分支运算</span></span><br><span class="line">        <span class="keyword">return</span> i &gt; <span class="number">0</span> &amp;&amp; sum(i - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    sum(n)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-翻转字符串里的单词-中等"><a href="#151-翻转字符串里的单词-中等" class="headerlink" title="151. 翻转字符串里的单词[中等]"></a>151. 翻转字符串里的单词[中等]</h3><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<p>说明：</p>
<p>无空格字符构成一个 单词 。<br>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 </p>
<p>示例 1：</p>
<p>输入：”the sky is blue”<br>输出：”blue is sky the”<br>示例 2：</p>
<p>输入：”  hello world!  “<br>输出：”world! hello”<br>解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<br>示例 3：</p>
<p>输入：”a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。<br>示例 4：</p>
<p>输入：s &#x3D; “  Bob    Loves  Alice   “<br>输出：”Alice Loves Bob”<br>示例 5：</p>
<p>输入：s &#x3D; “Alice does not even like bob”<br>输出：”bob like even not does Alice”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 包含英文大小写字母、数字和空格 ‘ ‘<br>s 中 至少存在一个 单词
 </p>
<p>进阶：</p>
<p>请尝试使用 O(1) 额外空间复杂度的原地解法。<br>通过次数104,729提交次数237,112</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string">https://leetcode-cn.com/problems/reverse-words-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-50"><a href="#解法-50" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    tmp := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    ret := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(tmp) - <span class="number">1</span>;i &gt;=<span class="number">0</span>;i --&#123;</span><br><span class="line">        <span class="keyword">if</span> tmp[i] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret += <span class="string">&quot; &quot;</span> + tmp[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.TrimSpace(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="452-用最少数量的箭引爆气球-简单"><a href="#452-用最少数量的箭引爆气球-简单" class="headerlink" title="452. 用最少数量的箭引爆气球[简单]"></a>452. 用最少数量的箭引爆气球[简单]</h3><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 points ，其中 points [i] &#x3D; [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p> <br>示例 1：</p>
<p>输入：points &#x3D; [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：对于该样例，x &#x3D; 6 可以射爆 [2,8],[1,6] 两个气球，以及 x &#x3D; 11 射爆另外两个气球<br>示例 2：</p>
<p>输入：points &#x3D; [[1,2],[3,4],[5,6],[7,8]]<br>输出：4<br>示例 3：</p>
<p>输入：points &#x3D; [[1,2],[2,3],[3,4],[4,5]]<br>输出：2<br>示例 4：</p>
<p>输入：points &#x3D; [[1,2]]<br>输出：1<br>示例 5：</p>
<p>输入：points &#x3D; [[2,3],[2,3]]<br>输出：1
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; points.length &lt;&#x3D; 104<br>points[i].length &#x3D;&#x3D; 2<br>-231 &lt;&#x3D; xstart &lt; xend &lt;&#x3D; 231 - 1<br>通过次数46,011提交次数90,356</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-51"><a href="#解法-51" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMinArrowShots</span><span class="params">(points [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 求数组的交集,通过交集计算之后,独立的数组每一个都需要一根箭</span></span><br><span class="line">    sort.Slice(points, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> points[i][<span class="number">1</span>] &lt; points[j][<span class="number">1</span>] &#125;)</span><br><span class="line">    <span class="comment">// pMap 存储气球的信息,k 为开始,v 为结束</span></span><br><span class="line">    pMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> points &#123;</span><br><span class="line">        addAble := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> k,v := <span class="keyword">range</span> pMap&#123;</span><br><span class="line">            <span class="keyword">if</span> p[<span class="number">0</span>] &lt; k &amp;&amp; p[<span class="number">1</span>] &gt;= k &amp;&amp; p[<span class="number">1</span>] &lt;= v &#123;</span><br><span class="line">                <span class="comment">//  [2 ,  8]</span></span><br><span class="line">                <span class="comment">//[1, 6]</span></span><br><span class="line">                <span class="comment">//[1.     8]</span></span><br><span class="line">                <span class="comment">// 新的数组为:(k, p[1)</span></span><br><span class="line">                pMap[k] = p[<span class="number">1</span>]</span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[<span class="number">0</span>] &lt;= k &amp;&amp; p[<span class="number">1</span>] &gt;= v &#123;</span><br><span class="line">                <span class="comment">//  [2,8]</span></span><br><span class="line">                <span class="comment">//[1,     9]</span></span><br><span class="line">                <span class="comment">// 交集:[2,8]</span></span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[<span class="number">0</span>] &gt;= k &amp;&amp; p[<span class="number">0</span>] &lt; v &amp;&amp; p[<span class="number">1</span>] &lt;= v &#123;</span><br><span class="line">                <span class="comment">//[2,   8]</span></span><br><span class="line">                <span class="comment">//  [3,7]</span></span><br><span class="line">                <span class="built_in">delete</span>(pMap,k)</span><br><span class="line">                pMap[p[<span class="number">0</span>]] = p[<span class="number">1</span>]</span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> p[<span class="number">0</span>] &gt; k &amp;&amp; p[<span class="number">0</span>] &lt;= v &amp;&amp; p[<span class="number">1</span>] &gt; v &#123;</span><br><span class="line">                <span class="comment">// [2, 8]</span></span><br><span class="line">                <span class="comment">//    [8, 12]</span></span><br><span class="line">                <span class="built_in">delete</span>(pMap, k)</span><br><span class="line">                pMap[p[<span class="number">0</span>]] = v</span><br><span class="line">                addAble = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> addAble &#123;</span><br><span class="line">            pMap[p[<span class="number">0</span>]] = p[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(pMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1576-替换所有的问号-简单"><a href="#1576-替换所有的问号-简单" class="headerlink" title="1576. 替换所有的问号[简单]"></a>1576. 替换所有的问号[简单]</h3><p>给你一个仅包含小写英文字母和 ‘?’ 字符的字符串 s，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。</p>
<p>注意：你 不能 修改非 ‘?’ 字符。</p>
<p>题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。</p>
<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “?zs”<br>输出：”azs”<br>解释：该示例共有 25 种解决方案，从 “azs” 到 “yzs” 都是符合题目要求的。只有 “z” 是无效的修改，因为字符串 “zzs” 中有连续重复的两个 ‘z’ 。<br>示例 2：</p>
<p>输入：s &#x3D; “ubv?w”<br>输出：”ubvaw”<br>解释：该示例共有 24 种解决方案，只有替换成 “v” 和 “w” 不符合题目要求。因为 “ubvvw” 和 “ubvww” 都包含连续重复的字符。<br>示例 3：</p>
<p>输入：s &#x3D; “j?qg??b”<br>输出：”jaqgacb”<br>示例 4：</p>
<p>输入：s &#x3D; “??yw?ipkj?”<br>输出：”acywaipkja”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100</p>
<p>s 仅包含小写英文字母和 ‘?’ 字符</p>
<p>通过次数9,573提交次数19,975</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters">https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-52"><a href="#解法-52" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sb);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> sb[i] == <span class="string">&#x27;?&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="string">&#x27;a&#x27;</span>; j &lt; <span class="string">&#x27;z&#x27;</span>;j ++&#123;</span><br><span class="line">               <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; sb[i - <span class="number">1</span>] != j &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i + <span class="number">1</span> &lt; <span class="built_in">len</span>(sb) &amp;&amp; sb[i + <span class="number">1</span>] != j) || i + <span class="number">1</span> &gt;= <span class="built_in">len</span>(sb) &#123;</span><br><span class="line">                       <span class="comment">// a?b || a?</span></span><br><span class="line">                       sb[i] = j</span><br><span class="line">                       <span class="keyword">break</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> i + <span class="number">1</span> &gt;= <span class="built_in">len</span>(sb)&#123;</span><br><span class="line">                       sb[i] = j</span><br><span class="line">                       <span class="keyword">break</span></span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">if</span> sb[i + <span class="number">1</span>] != j&#123;</span><br><span class="line">                           sb[i] = j</span><br><span class="line">                           <span class="keyword">break</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(sb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="222-完全二叉树的节点个数-中等"><a href="#222-完全二叉树的节点个数-中等" class="headerlink" title="222. 完全二叉树的节点个数[中等]"></a>222. 完全二叉树的节点个数[中等]</h3><p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<p>输入:<br>    1<br>   &#x2F; <br>  2   3<br> &#x2F; \  &#x2F;<br>4  5 6</p>
<p>输出: 6<br>通过次数61,729提交次数81,007</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes">https://leetcode-cn.com/problems/count-complete-tree-nodes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-53"><a href="#解法-53" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNodes</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.Left) + countNodes(root.Right)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。<br>示例 2：</p>
<p>输入: “cbbd”<br>输出: “bb”<br>通过次数424,490提交次数1,310,495</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="暴力解法-超时"><a href="#暴力解法-超时" class="headerlink" title="暴力解法-超时"></a>暴力解法-超时</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    start,end := <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> start &lt; end &#123;</span><br><span class="line">        <span class="keyword">if</span> s[start] != s[end] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            start ++</span><br><span class="line">            end --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    max := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> isPalindrome(s) &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(s);i &gt;= <span class="number">1</span>;i -- &#123;</span><br><span class="line">        <span class="comment">// 滑动窗口</span></span><br><span class="line">        initWindows := <span class="literal">false</span></span><br><span class="line">        windows := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := i;j &lt; <span class="built_in">len</span>(s);&#123;</span><br><span class="line">            <span class="keyword">if</span> !initWindows &#123;</span><br><span class="line">                <span class="keyword">for</span> k := <span class="number">0</span>;k &lt; i;k ++&#123;</span><br><span class="line">                    windows = <span class="built_in">append</span>(windows, s[k])</span><br><span class="line">                &#125;</span><br><span class="line">                initWindows = <span class="literal">true</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 滑动</span></span><br><span class="line">                windows = <span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, windows[<span class="number">1</span>:]...)</span><br><span class="line">                windows = <span class="built_in">append</span>(windows, s[j])</span><br><span class="line">                j++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> isPalindrome(<span class="type">string</span>(windows)) &amp;&amp; <span class="built_in">len</span>(windows) &gt; <span class="built_in">len</span>(max) &#123;</span><br><span class="line">                max = <span class="type">string</span>(windows)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    ans := <span class="string">&quot;&quot;</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; n; l++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i + l &lt; n; i++ &#123;</span><br><span class="line">            j := i + l</span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] &#123;</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; <span class="number">0</span> &amp;&amp; l + <span class="number">1</span> &gt; <span class="built_in">len</span>(ans) &#123;</span><br><span class="line">                ans = s[i:i+l+<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1370-上升下降字符串-简单"><a href="#1370-上升下降字符串-简单" class="headerlink" title="1370. 上升下降字符串[简单]"></a>1370. 上升下降字符串[简单]</h3><p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<p>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。<br>重复步骤 2 ，直到你没法从 s 中选择字符。<br>从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。<br>重复步骤 5 ，直到你没法从 s 中选择字符。<br>重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。<br>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “aaaabbbbcccc”<br>输出：”abccbaabccba”<br>解释：第一轮的步骤 1，2，3 后，结果字符串为 result &#x3D; “abc”<br>第一轮的步骤 4，5，6 后，结果字符串为 result &#x3D; “abccba”<br>第一轮结束，现在 s &#x3D; “aabbcc” ，我们再次回到步骤 1<br>第二轮的步骤 1，2，3 后，结果字符串为 result &#x3D; “abccbaabc”<br>第二轮的步骤 4，5，6 后，结果字符串为 result &#x3D; “abccbaabccba”<br>示例 2：</p>
<p>输入：s &#x3D; “rat”<br>输出：”art”<br>解释：单词 “rat” 在上述算法重排序以后变成 “art”<br>示例 3：</p>
<p>输入：s &#x3D; “leetcode”<br>输出：”cdelotee”<br>示例 4：</p>
<p>输入：s &#x3D; “ggggggg”<br>输出：”ggggggg”<br>示例 5：</p>
<p>输入：s &#x3D; “spo”<br>输出：”ops”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 500<br>s 只包含小写英文字母。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-decreasing-string">https://leetcode-cn.com/problems/increasing-decreasing-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-54"><a href="#解法-54" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    retSb := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        nums = <span class="built_in">append</span>(nums, <span class="type">int</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums); &#123;</span><br><span class="line">        <span class="comment">// 获得上升</span></span><br><span class="line">        tmp := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">        last := <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(nums);j ++&#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] != <span class="number">-1</span> &amp;&amp; nums[j] &gt; last &#123;</span><br><span class="line">                tmp = <span class="built_in">append</span>(tmp, <span class="type">rune</span>(nums[j]))</span><br><span class="line">                last = nums[j]</span><br><span class="line">                nums[j] = <span class="number">-1</span></span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        retSb = <span class="built_in">append</span>(retSb, tmp...)</span><br><span class="line">        tmp = []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">        last = <span class="number">1</span> &lt;&lt; (<span class="number">32</span> - <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 获得下降</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="built_in">len</span>(nums) - <span class="number">1</span>;j &gt; <span class="number">-1</span>;j -- &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[j] != <span class="number">-1</span> &amp;&amp; nums[j] &lt; last &#123;</span><br><span class="line">                retSb = <span class="built_in">append</span>(retSb, <span class="type">rune</span>(nums[j]))</span><br><span class="line">                last = nums[j]</span><br><span class="line">                nums[j] = <span class="number">-1</span></span><br><span class="line">                i ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        retSb = <span class="built_in">append</span>(retSb, tmp...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(retSb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="187-重复的DNA序列-中等"><a href="#187-重复的DNA序列-中等" class="headerlink" title="187. 重复的DNA序列[中等]"></a>187. 重复的DNA序列[中等]</h3><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i] 为 ‘A’、’C’、’G’ 或 ‘T’<br>通过次数25,520提交次数55,859<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-dna-sequences">https://leetcode-cn.com/problems/repeated-dna-sequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-55"><a href="#解法-55" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    ans := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line">    n := <span class="built_in">len</span>(sb)</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i + <span class="number">10</span> &lt;= n;i ++&#123;</span><br><span class="line">        ds := <span class="type">string</span>(sb[i: i + <span class="number">10</span>])</span><br><span class="line">        sMap[ds] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; <span class="number">1</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="49-字母异位词分组-中等"><a href="#49-字母异位词分组-中等" class="headerlink" title="49. 字母异位词分组[中等]"></a>49. 字母异位词分组[中等]</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。<br>通过次数121,801提交次数190,239</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams">https://leetcode-cn.com/problems/group-anagrams</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-56"><a href="#解法-56" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    ans := [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    groupMap := []<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> strs&#123;</span><br><span class="line">        diff := <span class="literal">true</span></span><br><span class="line">        sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> _,c := <span class="keyword">range</span> s &#123;</span><br><span class="line">            sMap[c] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否存在相同的Map了</span></span><br><span class="line">        <span class="keyword">for</span> i, mapItem := <span class="keyword">range</span> groupMap &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(mapItem) != <span class="built_in">len</span>(sMap)&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                same := <span class="literal">true</span></span><br><span class="line">                <span class="keyword">for</span> k,v := <span class="keyword">range</span> sMap&#123;</span><br><span class="line">                    <span class="keyword">if</span> iV,ok := mapItem[k];ok &amp;&amp; iV == v&#123;</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        same = <span class="literal">false</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> same &#123;</span><br><span class="line">                    <span class="comment">// 相同的Map</span></span><br><span class="line">                    diff = <span class="literal">false</span></span><br><span class="line">                    ans[i] = <span class="built_in">append</span>(ans[i], s)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> diff &#123;</span><br><span class="line">            groupMap = <span class="built_in">append</span>(groupMap, sMap)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans,[]<span class="type">string</span>&#123;s&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="36-有效的数独-中等"><a href="#36-有效的数独-中等" class="headerlink" title="36. 有效的数独[中等]"></a>36. 有效的数独[中等]</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p>上图是一个部分填充的有效的数独。</p>
<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>示例 1:</p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true<br>示例 2:</p>
<p>输入:<br>[<br>  [“8”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: false<br>解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。<br>     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。<br>说明:</p>
<p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。<br>通过次数106,340提交次数172,920</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku">https://leetcode-cn.com/problems/valid-sudoku</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-57"><a href="#解法-57" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidSudoku</span><span class="params">(board [][]<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 每一行都只能出现一次</span></span><br><span class="line">    <span class="comment">// 每一列只能出现一次</span></span><br><span class="line">    <span class="comment">// 3 * 3 不能出现重复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++&#123;</span><br><span class="line">        bMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> j :=<span class="number">0</span>;j &lt; <span class="number">9</span>;j ++&#123;</span><br><span class="line">            <span class="keyword">if</span> board[i][j] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> _, ok := bMap[board[i][j]];ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    bMap[board[i][j]] += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理列</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++&#123;</span><br><span class="line">        bMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="number">9</span>;j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> board[j][i] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> _, ok := bMap[board[j][i]];ok &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    bMap[board[j][i]] += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理3 * 3</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">9</span>;i += <span class="number">3</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">9</span>;j += <span class="number">3</span>&#123;</span><br><span class="line">            bMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">            <span class="keyword">for</span> k := <span class="number">0</span> + i; k &lt; <span class="number">3</span> + i;k ++&#123;</span><br><span class="line">                <span class="keyword">for</span> y := <span class="number">0</span> + j; y &lt; <span class="number">3</span> + j;y ++&#123;</span><br><span class="line">                    <span class="keyword">if</span> board[k][y] != <span class="string">&#x27;.&#x27;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> _, ok := bMap[board[k][y]];ok &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            bMap[board[k][y]] += <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30-串联所有单词的子串-困难"><a href="#30-串联所有单词的子串-困难" class="headerlink" title="30. 串联所有单词的子串[困难]"></a>30. 串联所有单词的子串[困难]</h3><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：<br>  s &#x3D; “barfoothefoobarman”,<br>  words &#x3D; [“foo”,”bar”]<br>输出：[0,9]<br>解释：<br>从索引 0 和 9 开始的子串分别是 “barfoo” 和 “foobar” 。<br>输出的顺序不重要, [9,0] 也是有效答案。<br>示例 2：</p>
<p>输入：<br>  s &#x3D; “wordgoodgoodgoodbestword”,<br>  words &#x3D; [“word”,”good”,”best”,”word”]<br>输出：[]<br>通过次数49,977提交次数152,568<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-58"><a href="#解法-58" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findSubstring</span><span class="params">(s <span class="type">string</span>, words []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    wordsLength :=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,w := <span class="keyword">range</span> words&#123;</span><br><span class="line">        wordsLength += <span class="built_in">len</span>(w)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; wordsLength &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// words中的字符串必须全部用到</span></span><br><span class="line">    wMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="comment">// 子串索引,k为下标，v为该下标对应的子串数据</span></span><br><span class="line">    indexMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line">    windowSizeMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> words &#123;</span><br><span class="line">        wMap[v] += <span class="number">1</span></span><br><span class="line">        windowSizeMap[<span class="built_in">len</span>(v)] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    indexList := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找子串索引,会超时</span></span><br><span class="line">    <span class="comment">//for i := 0;i &lt; n;i ++&#123;</span></span><br><span class="line">    <span class="comment">//    for j:=i; j &lt; n;j++&#123;</span></span><br><span class="line">    <span class="comment">//        if _,ok := wMap[string(sb[i:j + 1])];ok&#123;</span></span><br><span class="line">    <span class="comment">//            indexMap[i] = string(sb[i:j + 1])</span></span><br><span class="line">    <span class="comment">//            indexList = append(indexList, i)</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> size, _ := <span class="keyword">range</span> windowSizeMap &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i + size &lt;= n;i ++&#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := wMap[<span class="type">string</span>(sb[i: i + size])];ok &#123;</span><br><span class="line">                indexMap[i] = <span class="type">string</span>(sb[i: i + size])</span><br><span class="line">                indexList = <span class="built_in">append</span>(indexList, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(indexList)</span><br><span class="line"></span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 判断是否是串起来的条件,当前索引</span></span><br><span class="line">    tmpMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> wMap &#123;</span><br><span class="line">        tmpMap[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,i := <span class="keyword">range</span> indexList &#123;</span><br><span class="line">        <span class="keyword">if</span> v,ok := indexMap[i]; ok &#123;</span><br><span class="line">            wMap[v] -= <span class="number">1</span></span><br><span class="line">            next := i + <span class="built_in">len</span>(v)</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> v2,ok := indexMap[next];ok&#123;</span><br><span class="line">                    v3, ok3 := wMap[v2]</span><br><span class="line">                    <span class="keyword">if</span> ok3 &amp;&amp; v3 &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        wMap[v2] -= <span class="number">1</span></span><br><span class="line">                        next += <span class="built_in">len</span>(v2)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            addAble := <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> _,t := <span class="keyword">range</span> wMap &#123;</span><br><span class="line">                <span class="keyword">if</span> t &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    addAble = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> addAble &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> k,v := <span class="keyword">range</span> tmpMap &#123;</span><br><span class="line">            wMap[k] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="454-四数相加-II-中等"><a href="#454-四数相加-II-中等" class="headerlink" title="454. 四数相加 II[中等]"></a>454. 四数相加 II[中等]</h3><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] &#x3D; 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p>例如:</p>
<p>输入:<br>A &#x3D; [ 1, 2]<br>B &#x3D; [-2,-1]<br>C &#x3D; [-1, 2]<br>D &#x3D; [ 0, 2]</p>
<p>输出:<br>2</p>
<p>解释:<br>两个元组如下:</p>
<ol>
<li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] &#x3D; 1 + (-2) + (-1) + 2 &#x3D; 0</li>
<li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] &#x3D; 2 + (-1) + (-1) + 0 &#x3D; 0<br>通过次数49,692提交次数86,457</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum-ii">https://leetcode-cn.com/problems/4sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-59"><a href="#解法-59" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fourSumCount</span><span class="params">(A []<span class="type">int</span>, B []<span class="type">int</span>, C []<span class="type">int</span>, D []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    abMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> A &#123;</span><br><span class="line">        <span class="keyword">for</span> _,v2 := <span class="keyword">range</span> B &#123;</span><br><span class="line">            abMap[v + v2] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,c := <span class="keyword">range</span> C &#123;</span><br><span class="line">        <span class="keyword">for</span> _,d := <span class="keyword">range</span> D &#123;</span><br><span class="line">            <span class="keyword">if</span> v,ok := abMap[-(c + d)];ok &#123;</span><br><span class="line">                ans += v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="617-合并二叉树-简单"><a href="#617-合并二叉树-简单" class="headerlink" title="617. 合并二叉树[简单]"></a>617. 合并二叉树[简单]</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<p>输入:<br>	Tree 1                     Tree 2<br>          1                         2<br>         &#x2F; \                       &#x2F; \<br>        3   2                     1   3<br>       &#x2F;                           \   \<br>      5                             4   7<br>输出:<br>合并后的树:<br>	     3<br>	    &#x2F; <br>	   4   5<br>	  &#x2F; \   \<br>	 5   4   7<br>注意: 合并必须从两个树的根节点开始。</p>
<p>通过次数109,219提交次数139,216</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees">https://leetcode-cn.com/problems/merge-two-binary-trees</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-60"><a href="#解法-60" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTrees</span><span class="params">(t1 *TreeNode, t2 *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">    tree := &amp;TreeNode&#123;</span><br><span class="line">        Val:   <span class="number">0</span>,</span><br><span class="line">        Left:  <span class="literal">nil</span>,</span><br><span class="line">        Right: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1 == <span class="literal">nil</span> &amp;&amp; t2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tree.Val = t1.Val + t2.Val</span><br><span class="line">        tree.Left = mergeTrees(t1.Left,t2.Left)</span><br><span class="line">        tree.Right = mergeTrees(t1.Right,t2.Right)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> t1 != <span class="literal">nil</span> &amp;&amp; t2 == <span class="literal">nil</span>&#123;</span><br><span class="line">        tree.Val = t1.Val</span><br><span class="line">        tree.Left = mergeTrees(t1.Left,<span class="literal">nil</span>)</span><br><span class="line">        tree.Right = mergeTrees(t1.Right, <span class="literal">nil</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> t1 == <span class="literal">nil</span> &amp;&amp; t2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        tree.Val = t2.Val</span><br><span class="line">        tree.Left = mergeTrees(<span class="literal">nil</span>,t2.Left)</span><br><span class="line">        tree.Right = mergeTrees(<span class="literal">nil</span>, t2.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-07-重建二叉树-中等"><a href="#剑指-Offer-07-重建二叉树-中等" class="headerlink" title="剑指 Offer 07. 重建二叉树[中等]"></a>剑指 Offer 07. 重建二叉树[中等]</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<p> </p>
<p>例如，给出</p>
<p>前序遍历 preorder &#x3D; [3,9,20,15,7]<br>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>返回如下的二叉树：</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; 节点个数 &lt;&#x3D; 5000</p>
<p> </p>
<p>注意：本题与主站 105 题重复：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
<p>通过次数81,512提交次数118,783</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-61"><a href="#解法-61" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="comment">// 前序定节点,中序定左右</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    nodeVal := preorder[<span class="number">0</span>]</span><br><span class="line">    left := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    right := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 取中序左右</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(inorder);i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> inorder[i] == nodeVal &#123;</span><br><span class="line">            left = inorder[:i]</span><br><span class="line">            right = inorder[i + <span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取前序左右</span></span><br><span class="line">    tree := &amp;TreeNode&#123;</span><br><span class="line">        Val:   nodeVal,</span><br><span class="line">        Left:  buildTree(preorder[<span class="number">1</span>: <span class="built_in">len</span>(left) + <span class="number">1</span>], left),</span><br><span class="line">        Right: buildTree(preorder[<span class="number">1</span> + <span class="built_in">len</span>(left):], right),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="493-翻转对-困难"><a href="#493-翻转对-困难" class="headerlink" title="493. 翻转对[困难]"></a>493. 翻转对[困难]</h3><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p>示例 1:</p>
<p>输入: [1,3,2,3,1]<br>输出: 2<br>示例 2:</p>
<p>输入: [2,4,3,5,1]<br>输出: 3<br>注意:</p>
<p>给定数组的长度不会超过50000。<br>输入数组中的所有数字都在32位整数的表示范围内。<br>通过次数16,072提交次数51,612</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs">https://leetcode-cn.com/problems/reverse-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-62"><a href="#解法-62" class="headerlink" title="解法"></a>解法</h4><p>前言<br>本题与「327. 区间和的个数」非常相像。</p>
<p>在 327 题中，我们要对前缀和数组的每一个元素 \textit{preSum}[i]preSum[i]，找出所有位于 ii 左侧的下标 jj 的数量，要求 jj 满足 \textit{preSum}[j] \in [\textit{preSum}[i]-\textit{upper}, \textit{preSum}[i]-\textit{lower}]preSum[j]∈[preSum[i]−upper,preSum[i]−lower]。而在此题中，我们则要对数组中的每一个元素 \textit{sum}[i]sum[i]，找出位于 ii 左侧，且满足 \textit{nums}[j] &gt; 2\cdot \textit{nums}[i]nums[j]&gt;2⋅nums[i] 的下标 jj。</p>
<p>不难发现，二者都是要对数组中的每一个元素，统计「在它左侧，且取值位于某个区间」的元素数量。两个问题唯一的区别仅仅在于取值区间的不同，因此可以用相似的方法解决这两个问题。</p>
<p>在「327 题的题解：区间和的个数」中，我们介绍了归并排序、线段树、树状数组以及平衡搜索树等多种解法。对于本题，我们只给出基于归并排序与树状数组的方法，感兴趣的读者可以参照前面给出的链接，自行完成其他方法的代码。</p>
<p>方法一：归并排序<br>思路及解法</p>
<p>在归并排序的过程中，假设对于数组 \textit{nums}[l..r]nums[l..r] 而言，我们已经分别求出了子数组 \textit{nums}[l..m]nums[l..m] 与 \textit{nums}[m+1..r]nums[m+1..r] 的翻转对数目，并已将两个子数组分别排好序，则 \textit{nums}[l..r]nums[l..r] 中的翻转对数目，就等于两个子数组的翻转对数目之和，加上左右端点分别位于两个子数组的翻转对数目。</p>
<p>我们可以为两个数组分别维护指针 i,ji,j。对于任意给定的 ii 而言，我们不断地向右移动 jj，直到 \textit{nums}[i] \le 2\cdot \textit{nums}[j]nums[i]≤2⋅nums[j]。此时，意味着以 ii 为左端点的翻转对数量为 j-m-1j−m−1。随后，我们再将 ii 向右移动一个单位，并用相同的方式计算以 ii 为左端点的翻转对数量。不断重复这样的过程，就能够求出所有左右端点分别位于两个子数组的翻转对数目。</p>
<p>代码</p>
<p>C++JavaGolangCJavaScript</p>
<p>func reversePairs(nums []int) int {<br>    n :&#x3D; len(nums)<br>    if n &lt;&#x3D; 1 {<br>        return 0<br>    }</p>
<pre><code>n1 := append([]int(nil), nums[:n/2]...)
n2 := append([]int(nil), nums[n/2:]...)
cnt := reversePairs(n1) + reversePairs(n2) // 递归完毕后，n1 和 n2 均为有序

// 统计重要翻转对 (i,j) 的数量
// 由于 n1 和 n2 均为有序，可以用两个指针同时遍历
j := 0
for _, v := range n1 &#123;
    for j &lt; len(n2) &amp;&amp; v &gt; 2*n2[j] &#123;
        j++
    &#125;
    cnt += j
&#125;

// n1 和 n2 归并填入 nums
p1, p2 := 0, 0
for i := range nums &#123;
    if p1 &lt; len(n1) &amp;&amp; (p2 == len(n2) || n1[p1] &lt;= n2[p2]) &#123;
        nums[i] = n1[p1]
        p1++
    &#125; else &#123;
        nums[i] = n2[p2]
        p2++
    &#125;
&#125;
return cnt
</code></pre>
<p>}<br>复杂度分析</p>
<p>时间复杂度：O(N\log N)O(NlogN)，其中 NN 为数组的长度。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 为数组的长度。</p>
<p>方法二：树状数组<br>思路及解法</p>
<p>树状数组支持的基本查询为求出 [1, \textit{val}][1,val] 之间的整数数量。因此，对于 \textit{nums}[i]nums[i] 而言，我们首先查询 [1,2\cdot\textit{nums}[i]][1,2⋅nums[i]] 的数量，再求出 [1,\textit{maxValue}][1,maxValue] 的数量（其中 \textit{maxValue}maxValue 为数组中最大元素的二倍）。二者相减，就能够得到以 ii 为右端点的翻转对数量。</p>
<p>由于数组中整数的范围可能很大，故在使用树状数组解法之前，需要利用哈希表将所有可能出现的整数，映射到连续的整数区间内。</p>
<p>代码</p>
<p>C++JavaGolangCJavaScript</p>
<p>type fenwick struct {<br>    tree []int<br>}</p>
<p>func newFenwickTree(n int) fenwick {<br>    return fenwick{make([]int, n+1)}<br>}</p>
<p>func (f fenwick) add(i int) {<br>    for ; i &lt; len(f.tree); i +&#x3D; i &amp; -i {<br>        f.tree[i]++<br>    }<br>}</p>
<p>func (f fenwick) sum(i int) (res int) {<br>    for ; i &gt; 0; i &amp;&#x3D; i - 1 {<br>        res +&#x3D; f.tree[i]<br>    }<br>    return<br>}</p>
<p>func reversePairs(nums []int) (cnt int) {<br>    n :&#x3D; len(nums)<br>    if n &lt;&#x3D; 1 {<br>        return<br>    }</p>
<pre><code>// 离散化所有下面统计时会出现的元素
allNums := make([]int, 0, 2*n)
for _, v := range nums &#123;
    allNums = append(allNums, v, 2*v)
&#125;
sort.Ints(allNums)
k := 1
kth := map[int]int&#123;allNums[0]: k&#125;
for i := 1; i &lt; 2*n; i++ &#123;
    if allNums[i] != allNums[i-1] &#123;
        k++
        kth[allNums[i]] = k
    &#125;
&#125;

t := newFenwickTree(k)
for i, v := range nums &#123;
    // 统计之前插入了多少个比 2*v 大的数
    cnt += i - t.sum(kth[2*v])
    t.add(kth[v])
&#125;
return
</code></pre>
<p>}<br>复杂度分析</p>
<p>时间复杂度：O(N\log N)O(NlogN)，其中 NN 为数组的长度。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 为数组的长度。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs/solution/fan-zhuan-dui-by-leetcode-solution/">https://leetcode-cn.com/problems/reverse-pairs/solution/fan-zhuan-dui-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="5614-找出最具竞争力的子序列-中等"><a href="#5614-找出最具竞争力的子序列-中等" class="headerlink" title="5614. 找出最具竞争力的子序列[中等]"></a>5614. 找出最具竞争力的子序列[中等]</h3><p>给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。</p>
<p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p>
<p>在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,5,2,6], k &#x3D; 2<br>输出：[2,6]<br>解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。<br>示例 2：</p>
<p>输入：nums &#x3D; [2,4,3,3,5,4,9,6], k &#x3D; 4<br>输出：[2,3,3,4]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; k &lt;&#x3D; nums.length<br>通过次数1,122提交次数7,245</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence">https://leetcode-cn.com/problems/find-the-most-competitive-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-63"><a href="#解法-63" class="headerlink" title="解法"></a>解法</h4><ul>
<li>超时解法1</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mostCompetitive</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    tmp := nums[:]</span><br><span class="line">    gap := k</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>;j &lt; k;j ++&#123;</span><br><span class="line">        min := math.MaxInt32</span><br><span class="line">        minIndex :=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;= <span class="built_in">len</span>(tmp) - gap;i ++&#123;</span><br><span class="line">            <span class="keyword">if</span> min &gt; tmp[i] &#123;</span><br><span class="line">                min = tmp[i]</span><br><span class="line">                minIndex = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, min)</span><br><span class="line">        tmp = tmp[minIndex + <span class="number">1</span>:]</span><br><span class="line">        gap --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>超时解法2</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mostCompetitive</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 len(num) - k中选取最小</span></span><br><span class="line">    min := math.MaxInt32</span><br><span class="line">    minIndex := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 2 = 4 - 2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;= <span class="built_in">len</span>(nums) - k;i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> min &gt; nums[i] &#123;</span><br><span class="line">            min= nums[i]</span><br><span class="line">            minIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">append</span>(ans, min)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ans) == k &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">append</span>(ans, mostCompetitive(nums[minIndex+<span class="number">1</span>:], k - <span class="number">1</span>)...)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ac解法<br>使用栈存储最优</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mostCompetitive</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= k &#123;</span><br><span class="line">       <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(nums);i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> top &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt; stack[top] &amp;&amp; <span class="built_in">len</span>(nums) - i + top &gt;= k<span class="comment">/*剩余的要够K*/</span>  &#123;</span><br><span class="line">            top --</span><br><span class="line">        &#125;</span><br><span class="line">        top ++</span><br><span class="line">        stack[top] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; k;i ++&#123;</span><br><span class="line">       ans = <span class="built_in">append</span>(ans, stack[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="767-重构字符串-中等"><a href="#767-重构字符串-中等" class="headerlink" title="767. 重构字符串[中等]"></a>767. 重构字符串[中等]</h3><p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p>示例 1:</p>
<p>输入: S &#x3D; “aab”<br>输出: “aba”<br>示例 2:</p>
<p>输入: S &#x3D; “aaab”<br>输出: “”<br>注意:</p>
<p>S 只包含小写字母并且长度在[1, 500]区间内。<br>通过次数24,938提交次数53,783</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorganize-string">https://leetcode-cn.com/problems/reorganize-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-64"><a href="#解法-64" class="headerlink" title="解法"></a>解法</h4><p>首先统计每个字母的出现次数，然后根据每个字母的出现次数重构字符串。</p>
<p>当 nn 是奇数且出现最多的字母的出现次数是 (n+1)&#x2F;2(n+1)&#x2F;2 时，出现次数最多的字母必须全部放置在偶数下标，否则一定会出现相邻的字母相同的情况。其余情况下，每个字母放置在偶数下标或者奇数下标都是可行的。</p>
<p>维护偶数下标 \textit{evenIndex}evenIndex 和奇数下标 \textit{oddIndex}oddIndex，初始值分别为 00 和 11。遍历每个字母，根据每个字母的出现次数判断字母应该放置在偶数下标还是奇数下标。</p>
<p>首先考虑是否可以放置在奇数下标。根据上述分析可知，只要字母的出现次数不超过字符串的长度的一半（即出现次数小于或等于 n&#x2F;2n&#x2F;2），就可以放置在奇数下标，只有当字母的出现次数超过字符串的长度的一半时，才必须放置在偶数下标。字母的出现次数超过字符串的长度的一半只可能发生在 nn 是奇数的情况下，且最多只有一个字母的出现次数会超过字符串的长度的一半。</p>
<p>因此通过如下操作在重构的字符串中放置字母。</p>
<p>如果字母的出现次数大于 00 且小于或等于 n&#x2F;2n&#x2F;2，且 \textit{oddIndex}oddIndex 没有超出数组下标范围，则将字母放置在 \textit{oddIndex}oddIndex，然后将 \textit{oddIndex}oddIndex 的值加 22。</p>
<p>如果字母的出现次数大于 n&#x2F;2n&#x2F;2，或 \textit{oddIndex}oddIndex 超出数组下标范围，则将字母放置在 \textit{evenIndex}evenIndex，然后将 \textit{evenIndex}evenIndex 的值加 22。</p>
<p>如果一个字母出现了多次，则重复上述操作，直到该字母全部放置完毕。</p>
<p>那么上述做法是否可以确保相邻的字母都不相同？考虑以下三种情况。</p>
<p>如果 nn 是奇数且存在一个字母的出现次数为 (n+1)&#x2F;2(n+1)&#x2F;2，则该字母全部被放置在偶数下标，其余的 (n-1)&#x2F;2(n−1)&#x2F;2 个字母都被放置在奇数下标，因此相邻的字母一定不相同。</p>
<p>如果同一个字母全部被放置在奇数下标或全部被放置在偶数下标，则该字母不可能在相邻的下标出现。</p>
<p>如果同一个字母先被放置在奇数下标直到奇数下标超出数组下标范围，然后被放置在偶数下标，由于该字母的出现次数不会超过 n&#x2F;2n&#x2F;2，因此该字母的最小奇数下标与最大偶数下标之差不小于 33，不可能在相邻的下标出现。证明如下：</p>
<h1 id="当-nn-是偶数时，如果该字母的出现次数为-n-2n-2，包括-pp-个奇数下标和-qq-个偶数下标，满足-p-q-n-2p-q-n-2，最小奇数下标是-n-2p-1n−2p-1，最大偶数下标是-2-q-1-2-q−1-，最小奇数下标与最大偶数下标之差为：-begin-aligned-n-2p-1-2-q-1-n-2p-1-2q-2-n-2-p-q-3-n-2-times-frac-n-2-3-n-n-3-3-end-aligned"><a href="#当-nn-是偶数时，如果该字母的出现次数为-n-2n-2，包括-pp-个奇数下标和-qq-个偶数下标，满足-p-q-n-2p-q-n-2，最小奇数下标是-n-2p-1n−2p-1，最大偶数下标是-2-q-1-2-q−1-，最小奇数下标与最大偶数下标之差为：-begin-aligned-n-2p-1-2-q-1-n-2p-1-2q-2-n-2-p-q-3-n-2-times-frac-n-2-3-n-n-3-3-end-aligned" class="headerlink" title="当 nn 是偶数时，如果该字母的出现次数为 n&#x2F;2n&#x2F;2，包括 pp 个奇数下标和 qq 个偶数下标，满足 p+q&#x3D;n&#x2F;2p+q&#x3D;n&#x2F;2，最小奇数下标是 n-2p+1n−2p+1，最大偶数下标是 2(q-1)2(q−1)，最小奇数下标与最大偶数下标之差为：\begin{aligned} &amp; (n-2p+1)-2(q-1) \ &#x3D; &amp;\ n-2p+1-2q+2 \ &#x3D; &amp;\ n-2(p+q)+3 \ &#x3D; &amp;\ n-2 \times \frac{n}{2}+3 \ &#x3D; &amp;\ n-n+3 \ &#x3D; &amp;\ 3 \end{aligned}"></a>当 nn 是偶数时，如果该字母的出现次数为 n&#x2F;2n&#x2F;2，包括 pp 个奇数下标和 qq 个偶数下标，满足 p+q&#x3D;n&#x2F;2p+q&#x3D;n&#x2F;2，最小奇数下标是 n-2p+1n−2p+1，最大偶数下标是 2(q-1)2(q−1)，最小奇数下标与最大偶数下标之差为：<br>\begin{aligned} &amp; (n-2p+1)-2(q-1) \ &#x3D; &amp;\ n-2p+1-2q+2 \ &#x3D; &amp;\ n-2(p+q)+3 \ &#x3D; &amp;\ n-2 \times \frac{n}{2}+3 \ &#x3D; &amp;\ n-n+3 \ &#x3D; &amp;\ 3 \end{aligned}</h1><h1 id=""><a href="#" class="headerlink" title="&#x3D;"></a>&#x3D;</h1><h1 id="-1"><a href="#-1" class="headerlink" title="&#x3D;"></a>&#x3D;</h1><p>​	</p>
<p>(n−2p+1)−2(q−1)<br> n−2p+1−2q+2<br> n−2(p+q)+3<br> n−2×<br>2<br>n<br>​	<br> +3<br> n−n+3<br> 3<br>​	</p>
<h1 id="当-nn-是奇数时，如果该字母的出现次数为-n-1-2-n−1-2，包括-pp-个奇数下标和-qq-个偶数下标，满足-p-q-n-1-2p-q-n−1-2，最小奇数下标是-n-2pn−2p，最大偶数下标是-2-q-1-2-q−1-，最小奇数下标与最大偶数下标之差为：-begin-aligned-n-2p-2-q-1-n-2p-2q-2-n-2-p-q-2-n-2-times-frac-n-1-2-2-n-n-1-2-3-end-aligned"><a href="#当-nn-是奇数时，如果该字母的出现次数为-n-1-2-n−1-2，包括-pp-个奇数下标和-qq-个偶数下标，满足-p-q-n-1-2p-q-n−1-2，最小奇数下标是-n-2pn−2p，最大偶数下标是-2-q-1-2-q−1-，最小奇数下标与最大偶数下标之差为：-begin-aligned-n-2p-2-q-1-n-2p-2q-2-n-2-p-q-2-n-2-times-frac-n-1-2-2-n-n-1-2-3-end-aligned" class="headerlink" title="当 nn 是奇数时，如果该字母的出现次数为 (n-1)&#x2F;2(n−1)&#x2F;2，包括 pp 个奇数下标和 qq 个偶数下标，满足 p+q&#x3D;(n-1)&#x2F;2p+q&#x3D;(n−1)&#x2F;2，最小奇数下标是 n-2pn−2p，最大偶数下标是 2(q-1)2(q−1)，最小奇数下标与最大偶数下标之差为：\begin{aligned} &amp; (n-2p)-2(q-1) \ &#x3D; &amp;\ n-2p-2q+2 \ &#x3D; &amp;\ n-2(p+q)+2 \ &#x3D; &amp;\ n-2 \times \frac{n-1}{2}+2 \ &#x3D; &amp;\ n-(n-1)+2 \ &#x3D; &amp;\ 3 \end{aligned}"></a>当 nn 是奇数时，如果该字母的出现次数为 (n-1)&#x2F;2(n−1)&#x2F;2，包括 pp 个奇数下标和 qq 个偶数下标，满足 p+q&#x3D;(n-1)&#x2F;2p+q&#x3D;(n−1)&#x2F;2，最小奇数下标是 n-2pn−2p，最大偶数下标是 2(q-1)2(q−1)，最小奇数下标与最大偶数下标之差为：<br>\begin{aligned} &amp; (n-2p)-2(q-1) \ &#x3D; &amp;\ n-2p-2q+2 \ &#x3D; &amp;\ n-2(p+q)+2 \ &#x3D; &amp;\ n-2 \times \frac{n-1}{2}+2 \ &#x3D; &amp;\ n-(n-1)+2 \ &#x3D; &amp;\ 3 \end{aligned}</h1><h1 id="-2"><a href="#-2" class="headerlink" title="&#x3D;"></a>&#x3D;</h1><h1 id="-3"><a href="#-3" class="headerlink" title="&#x3D;"></a>&#x3D;</h1><p>​	</p>
<p>(n−2p)−2(q−1)<br> n−2p−2q+2<br> n−2(p+q)+2<br> n−2×<br>2<br>n−1<br>​	<br> +2<br> n−(n−1)+2<br> 3<br>​	</p>
<p>因此，在重构字符串可行的情况下，基于计数的贪心算法可以确保相邻的字母都不相同，得到正确答案。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorganizeString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    maxCnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ch -= <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        cnt[ch]++</span><br><span class="line">        <span class="keyword">if</span> cnt[ch] &gt; maxCnt &#123;</span><br><span class="line">            maxCnt = cnt[ch]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> maxCnt &gt; (n+<span class="number">1</span>)/<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">    evenIdx, oddIdx, halfLen := <span class="number">0</span>, <span class="number">1</span>, n/<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> cnt[:] &#123;</span><br><span class="line">        ch := <span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span> + i)</span><br><span class="line">        <span class="keyword">for</span> c &gt; <span class="number">0</span> &amp;&amp; c &lt;= halfLen &amp;&amp; oddIdx &lt; n &#123;</span><br><span class="line">            ans[oddIdx] = ch</span><br><span class="line">            c--</span><br><span class="line">            oddIdx += <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> c &gt; <span class="number">0</span> &#123;</span><br><span class="line">            ans[evenIdx] = ch</span><br><span class="line">            c--</span><br><span class="line">            evenIdx += <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ans)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n+|\Sigma|)O(n+∣Σ∣)，其中 nn 是字符串的长度，\SigmaΣ 是字符集，在本题中字符集为所有小写字母，|\Sigma|&#x3D;26∣Σ∣&#x3D;26。<br>遍历字符串并统计每个字母的出现次数，时间复杂度是 O(n)O(n)。<br>重构字符串需要进行 nn 次放置字母的操作，并遍历每个字母得到出现次数，时间复杂度是 O(n+|\Sigma|)O(n+∣Σ∣)。<br>总时间复杂度是 O(n+|\Sigma|)O(n+∣Σ∣)。</p>
<p>空间复杂度：O(|\Sigma|)O(∣Σ∣)，其中 nn 是字符串的长度，\SigmaΣ 是字符集，在本题中字符集为所有小写字母，|\Sigma|&#x3D;26∣Σ∣&#x3D;26。这里不计算存储最终答案字符串需要的空间（以及由于语言特性，在构造字符串时需要的额外缓存空间），空间复杂度主要取决于统计每个字母出现次数的数组和优先队列。空间复杂度主要取决于统计每个字母出现次数的数组。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorganize-string/solution/zhong-gou-zi-fu-chuan-by-leetcode-solution/">https://leetcode-cn.com/problems/reorganize-string/solution/zhong-gou-zi-fu-chuan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="23-合并K个升序链表-困难"><a href="#23-合并K个升序链表-困难" class="headerlink" title="23. 合并K个升序链表[困难]"></a>23. 合并K个升序链表[困难]</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br>示例 2：</p>
<p>输入：lists &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：lists &#x3D; [[]]<br>输出：[]
 </p>
<p>提示：</p>
<p>k &#x3D;&#x3D; lists.length<br>0 &lt;&#x3D; k &lt;&#x3D; 10^4<br>0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500<br>-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4<br>lists[i] 按 升序 排列<br>lists[i].length 的总和不超过 10^4<br>通过次数191,226提交次数356,108</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-65"><a href="#解法-65" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    newList := &amp;ListNode&#123;&#125;</span><br><span class="line">    cur := newList</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        min := math.MaxInt32</span><br><span class="line">        minIndex := <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i, item := <span class="keyword">range</span> lists&#123;</span><br><span class="line">            <span class="keyword">if</span> item != <span class="literal">nil</span> &amp;&amp; item.Val &lt; min &#123;</span><br><span class="line">                min = item.Val</span><br><span class="line">                minIndex = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> minIndex != <span class="number">-1</span> &amp;&amp; lists[minIndex] != <span class="literal">nil</span> &#123;</span><br><span class="line">            cur.Next = lists[minIndex]</span><br><span class="line">            lists[minIndex] = lists[minIndex].Next</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-寻找两个正序数组的中位数-困难"><a href="#4-寻找两个正序数组的中位数-困难" class="headerlink" title="4. 寻找两个正序数组的中位数[困难]"></a>4. 寻找两个正序数组的中位数[困难]</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。</p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]<br>输出：2.00000<br>解释：合并数组 &#x3D; [1,2,3] ，中位数 2<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]<br>输出：2.50000<br>解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]<br>输出：0.00000<br>示例 4：</p>
<p>输入：nums1 &#x3D; [], nums2 &#x3D; [1]<br>输出：1.00000<br>示例 5：</p>
<p>输入：nums1 &#x3D; [2], nums2 &#x3D; []<br>输出：2.00000
 </p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m &lt;&#x3D; 1000<br>0 &lt;&#x3D; n &lt;&#x3D; 1000<br>1 &lt;&#x3D; m + n &lt;&#x3D; 2000<br>-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106<br>通过次数296,624提交次数756,816</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">https://leetcode-cn.com/problems/median-of-two-sorted-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-66"><a href="#解法-66" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="comment">// 知道了长度，中位数的索引已经定位了</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums3 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    max := n / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    index1 := <span class="number">0</span></span><br><span class="line">    index2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= max;i++ &#123;</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="keyword">if</span> index1 &lt; <span class="built_in">len</span>(nums1) &amp;&amp; index2 &lt; <span class="built_in">len</span>(nums2) &amp;&amp; nums1[index1] &lt; nums2[index2]&#123;</span><br><span class="line">            nums3 = <span class="built_in">append</span>(nums3, nums1[index1])</span><br><span class="line">            index1 ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> index1 &lt; <span class="built_in">len</span>(nums1) &amp;&amp; index2 &lt; <span class="built_in">len</span>(nums2) &amp;&amp; nums1[index1] &gt;= nums2[index2] &#123;</span><br><span class="line">            nums3 = <span class="built_in">append</span>(nums3, nums2[index2])</span><br><span class="line">            index2 ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> index1 &gt;= <span class="built_in">len</span>(nums1) &amp;&amp; index2 &lt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            nums3 = <span class="built_in">append</span>(nums3, nums2[index2])</span><br><span class="line">            index2 ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> index1 &lt; <span class="built_in">len</span>(nums1) &amp;&amp; index2 &gt;= <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">            nums3 = <span class="built_in">append</span>(nums3, nums1[index1])</span><br><span class="line">            index1 ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">float64</span>(nums3[<span class="built_in">len</span>(nums3) - <span class="number">1</span>]) + <span class="type">float64</span>(nums3[<span class="built_in">len</span>(nums3) - <span class="number">2</span>]))/<span class="number">2</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">float64</span>(nums3[<span class="built_in">len</span>(nums3) - <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="34-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置[中等]"></a>34. 在排序数组中查找元素的第一个和最后一个位置[中等]</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>通过次数175,183提交次数420,917</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-67"><a href="#解法-67" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    first, last , mid := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, (<span class="number">0</span> + <span class="built_in">len</span>(nums) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 先找起点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">            mid = (first + last ) / <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">            mid = (first + last) / <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> first &gt; last &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mid定位了,向两边延伸寻找首尾</span></span><br><span class="line">    first, last = mid, mid</span><br><span class="line">    searchFont := <span class="literal">false</span></span><br><span class="line">    searchEnd := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (first &gt;= <span class="number">0</span> || last &lt;= <span class="built_in">len</span>(nums) <span class="number">-1</span>) &amp;&amp; nums[first] == target &amp;&amp; nums[last] == target &amp;&amp; (!searchEnd || !searchFont) &#123;</span><br><span class="line">        <span class="keyword">if</span> first - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[first <span class="number">-1</span>] == target &#123;</span><br><span class="line">            first = first - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            searchFont = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> last + <span class="number">1</span> &lt;= <span class="built_in">len</span>(nums) <span class="number">-1</span> &amp;&amp; nums[last + <span class="number">1</span>] == target &#123;</span><br><span class="line">            last = last + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            searchEnd = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">0</span>] = first</span><br><span class="line">    ans[<span class="number">1</span>] = last</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-05-链表求和-中等"><a href="#面试题-02-05-链表求和-中等" class="headerlink" title="面试题 02.05. 链表求和[中等]"></a>面试题 02.05. 链表求和[中等]</h3><p>给定两个用链表表示的整数，每个节点包含一个数位。</p>
<p>这些数位是反向存放的，也就是个位排在链表首部。</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<p> </p>
<p>示例：</p>
<p>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<br>输出：2 -&gt; 1 -&gt; 9，即912<br>进阶：思考一下，假设这些数位是正向存放的，又该如何解决呢?</p>
<p>示例：</p>
<p>输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295<br>输出：9 -&gt; 1 -&gt; 2，即912<br>通过次数17,839提交次数38,870</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-lists-lcci">https://leetcode-cn.com/problems/sum-lists-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-68"><a href="#解法-68" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    list := &amp;ListNode&#123;&#125;</span><br><span class="line">    cur := list</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        num := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            num += l1.Val</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            num += l2.Val</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        num += carry</span><br><span class="line">        carry = num / <span class="number">10</span></span><br><span class="line">        val := num % <span class="number">10</span></span><br><span class="line">        cur.Next = &amp;ListNode&#123;Val: val, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry != <span class="number">0</span> &#123;</span><br><span class="line">        cur.Next = &amp;ListNode&#123;Val: carry,Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-59-II-队列的最大值-中等"><a href="#剑指-Offer-59-II-队列的最大值-中等" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值[中等]"></a>剑指 Offer 59 - II. 队列的最大值[中等]</h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<p>示例 1：</p>
<p>输入:<br>[“MaxQueue”,”push_back”,”push_back”,”max_value”,”pop_front”,”max_value”]<br>[[],[1],[2],[],[],[]]<br>输出: [null,null,null,2,1,2]<br>示例 2：</p>
<p>输入:<br>[“MaxQueue”,”pop_front”,”max_value”]<br>[[],[],[]]<br>输出: [null,-1,-1]
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; push_back,pop_front,max_value的总操作数 &lt;&#x3D; 10000<br>1 &lt;&#x3D; value &lt;&#x3D; 10^5</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-69"><a href="#解法-69" class="headerlink" title="解法"></a>解法</h4><p>而外维持一个最大值的队列,这个最大值的队列对头肯定是当前最大的值。如果有新的进来，更新最大值队列。如何更新，将小于这个值得数据抛弃。里面肯定是单调递减的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="type">int</span></span><br><span class="line">    maxQueue []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MaxQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MaxQueue&#123;queue: []<span class="type">int</span>&#123;&#125;, maxQueue: []<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Max_value() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.maxQueue) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.maxQueue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Push_back(value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(this.maxQueue) &gt; <span class="number">0</span> &amp;&amp; this.maxQueue[<span class="built_in">len</span>(this.maxQueue) - <span class="number">1</span>] &lt; value &#123;</span><br><span class="line">        this.maxQueue = this.maxQueue[:<span class="built_in">len</span>(this.maxQueue) <span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    this.maxQueue = <span class="built_in">append</span>(this.maxQueue, value)</span><br><span class="line">    this.queue = <span class="built_in">append</span>(this.queue, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Pop_front() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(this.queue) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans := this.queue[<span class="number">0</span>]</span><br><span class="line">    this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> ans == this.maxQueue[<span class="number">0</span>] &#123;</span><br><span class="line">        this.maxQueue = this.maxQueue[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-K-个一组翻转链表-困难"><a href="#25-K-个一组翻转链表-困难" class="headerlink" title="25. K 个一组翻转链表[困难]"></a>25. K 个一组翻转链表[困难]</h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p> </p>
<p>示例：</p>
<p>给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p> </p>
<p>说明：</p>
<p>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>通过次数117,933提交次数185,212</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-70"><a href="#解法-70" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == head &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> ;cur != <span class="literal">nil</span>;&#123;</span><br><span class="line">        tmp := cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        tmp.Next = pre</span><br><span class="line">        pre = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    list := &amp;ListNode&#123;&#125;</span><br><span class="line">    tail := list</span><br><span class="line">    <span class="comment">// 按照k大小进行分割</span></span><br><span class="line">    tmp := head</span><br><span class="line">    <span class="keyword">for</span> tmp != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur := tmp</span><br><span class="line">        head2 := tmp</span><br><span class="line">        i := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ;cur !=<span class="literal">nil</span>;cur = cur.Next&#123;</span><br><span class="line">            i ++</span><br><span class="line">            <span class="keyword">if</span> i == k &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == k &amp;&amp; cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            tmp = cur.Next</span><br><span class="line">            cur.Next = <span class="literal">nil</span></span><br><span class="line">            tail.Next = reverse(head2)</span><br><span class="line">            <span class="keyword">for</span> ;tail.Next != <span class="literal">nil</span>;tail = tail.Next &#123;&#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.Next = head2</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1669-合并两个链表-中等"><a href="#1669-合并两个链表-中等" class="headerlink" title="1669. 合并两个链表[中等]"></a>1669. 合并两个链表[中等]</h3><p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。</p>
<p>请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。</p>
<p>下图中蓝色边和节点展示了操作后的结果：</p>
<p>请你返回结果链表的头指针。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：list1 &#x3D; [0,1,2,3,4,5], a &#x3D; 3, b &#x3D; 4, list2 &#x3D; [1000000,1000001,1000002]<br>输出：[0,1,2,1000000,1000001,1000002,5]<br>解释：我们删除 list1 中第三和第四个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。<br>示例 2：</p>
<p>输入：list1 &#x3D; [0,1,2,3,4,5,6], a &#x3D; 2, b &#x3D; 5, list2 &#x3D; [1000000,1000001,1000002,1000003,1000004]<br>输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]<br>解释：上图中蓝色的边和节点为答案链表。
 </p>
<p>提示：</p>
<p>3 &lt;&#x3D; list1.length &lt;&#x3D; 104<br>1 &lt;&#x3D; a &lt;&#x3D; b &lt; list1.length - 1<br>1 &lt;&#x3D; list2.length &lt;&#x3D; 104<br>通过次数2,046提交次数2,515</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-in-between-linked-lists">https://leetcode-cn.com/problems/merge-in-between-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-71"><a href="#解法-71" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeInBetween</span><span class="params">(list1 *ListNode, a <span class="type">int</span>, b <span class="type">int</span>, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    list := &amp;ListNode&#123;</span><br><span class="line">        Val:  <span class="number">0</span>,</span><br><span class="line">        Next: list1,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定位切割点</span></span><br><span class="line">    cutPoint := list</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; a;i ++&#123;</span><br><span class="line">        cutPoint = cutPoint.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定位切割头部</span></span><br><span class="line">    cutHead := cutPoint.Next</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; b - a + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        cutHead = cutHead.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新组装</span></span><br><span class="line">    cutPoint.Next = list2</span><br><span class="line">    cur := list2</span><br><span class="line">    <span class="keyword">for</span> ;cur.Next != <span class="literal">nil</span>;cur = cur.Next&#123;&#125;</span><br><span class="line">    cur.Next = cutHead</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-17-09-第-k-个数-中等"><a href="#面试题-17-09-第-k-个数-中等" class="headerlink" title="面试题 17.09. 第 k 个数[中等]"></a>面试题 17.09. 第 k 个数[中等]</h3><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>
<p>示例 1:</p>
<p>输入: k &#x3D; 5</p>
<p>输出: 9<br>通过次数7,350提交次数13,530</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci">https://leetcode-cn.com/problems/get-kth-magic-number-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-72"><a href="#解法-72" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y&#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthMagicNumber</span><span class="params">(k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    p3,p5,p7 := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; k;i ++ &#123;</span><br><span class="line">        min := min(dp[p3] * <span class="number">3</span>, min(dp[p5] * <span class="number">5</span>, dp[p7]* <span class="number">7</span>))</span><br><span class="line">        dp[i] = min</span><br><span class="line">        <span class="keyword">if</span> min == dp[p3] *<span class="number">3</span> &#123;</span><br><span class="line">            p3 ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> min == dp[p5] *<span class="number">5</span> &#123;</span><br><span class="line">            p5 ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> min == dp[p7] * <span class="number">7</span> &#123;</span><br><span class="line">            p7 ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[k - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="328-奇偶链表-中等"><a href="#328-奇偶链表-中等" class="headerlink" title="328. 奇偶链表[中等]"></a>328. 奇偶链表[中等]</h3><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL<br>示例 2:</p>
<p>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br>输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL<br>说明:</p>
<p>应当保持奇数节点和偶数节点的相对顺序。<br>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。<br>通过次数87,539提交次数133,658</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list">https://leetcode-cn.com/problems/odd-even-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-73"><a href="#解法-73" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oddEvenList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    tail := head</span><br><span class="line">    oddHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    oddTail := oddHead</span><br><span class="line">    <span class="keyword">for</span> ;tail.Next != <span class="literal">nil</span>;&#123;</span><br><span class="line">        oddTail.Next = tail.Next</span><br><span class="line">        tail.Next = tail.Next.Next</span><br><span class="line">        oddTail = oddTail.Next</span><br><span class="line">        oddTail.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">if</span> tail.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tail.Next = oddHead.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="659-分割数组为连续子序列-中等"><a href="#659-分割数组为连续子序列-中等" class="headerlink" title="659. 分割数组为连续子序列[中等]"></a>659. 分割数组为连续子序列[中等]</h3><p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p>
<p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5
 </p>
<p>示例 2：</p>
<p>输入: [1,2,3,3,4,4,5,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5
 </p>
<p>示例 3：</p>
<p>输入: [1,2,3,4,4,5]<br>输出: False
 </p>
<p>提示：</p>
<p>输入的数组长度范围为 [1, 10000]
 </p>
<p>通过次数17,783提交次数34,004</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences">https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-74"><a href="#解法-74" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPossible</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    left := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 每个数字的剩余个数</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        left[v]++</span><br><span class="line">    &#125;</span><br><span class="line">    endCnt := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125; <span class="comment">// 以某个数字结尾的连续子序列的个数</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> left[v] == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> endCnt[v<span class="number">-1</span>] &gt; <span class="number">0</span> &#123; <span class="comment">// 若存在以 v-1 结尾的连续子序列，则将 v 加到其末尾</span></span><br><span class="line">            left[v]--</span><br><span class="line">            endCnt[v<span class="number">-1</span>]--</span><br><span class="line">            endCnt[v]++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> left[v+<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; left[v+<span class="number">2</span>] &gt; <span class="number">0</span> &#123; <span class="comment">// 否则，生成一个长度为 3 的连续子序列</span></span><br><span class="line">            left[v]--</span><br><span class="line">            left[v+<span class="number">1</span>]--</span><br><span class="line">            left[v+<span class="number">2</span>]--</span><br><span class="line">            endCnt[v+<span class="number">2</span>]++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无法生成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LCP-06-拿硬币-简单"><a href="#LCP-06-拿硬币-简单" class="headerlink" title="LCP 06. 拿硬币[简单]"></a>LCP 06. 拿硬币[简单]</h3><p>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<p>示例 1：</p>
<p>输入：[4,2,1]</p>
<p>输出：4</p>
<p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p>
<p>示例 2：</p>
<p>输入：[2,3,10]</p>
<p>输出：8</p>
<p>限制：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 4<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 10</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/na-ying-bi">https://leetcode-cn.com/problems/na-ying-bi</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-75"><a href="#解法-75" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCount</span><span class="params">(coins []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    nMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">3</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="number">4</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="number">5</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="number">6</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="number">7</span>:<span class="number">4</span>,</span><br><span class="line">        <span class="number">8</span>:<span class="number">4</span>,</span><br><span class="line">        <span class="number">9</span>:<span class="number">5</span>,</span><br><span class="line">        <span class="number">10</span>:<span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> coins &#123;</span><br><span class="line">        ans += nMap[v]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="621-任务调度器-中等"><a href="#621-任务调度器-中等" class="headerlink" title="621. 任务调度器[中等]"></a>621. 任务调度器[中等]</h3><p>给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 最短时间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 2<br>输出：8<br>解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B<br>     在本示例中，两个相同类型任务之间必须间隔长度为 n &#x3D; 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。<br>示例 2：</p>
<p>输入：tasks &#x3D; [“A”,”A”,”A”,”B”,”B”,”B”], n &#x3D; 0<br>输出：6<br>解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n &#x3D; 0<br>[“A”,”A”,”A”,”B”,”B”,”B”]<br>[“A”,”B”,”A”,”B”,”A”,”B”]<br>[“B”,”B”,”B”,”A”,”A”,”A”]<br>…<br>诸如此类<br>示例 3：</p>
<p>输入：tasks &#x3D; [“A”,”A”,”A”,”A”,”A”,”A”,”B”,”C”,”D”,”E”,”F”,”G”], n &#x3D; 2<br>输出：16<br>解释：一种可能的解决方案是：<br>     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; task.length &lt;&#x3D; 104<br>tasks[i] 是大写英文字母<br>n 的取值范围为 [0, 100]<br>通过次数46,923提交次数86,906</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/task-scheduler">https://leetcode-cn.com/problems/task-scheduler</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-76"><a href="#解法-76" class="headerlink" title="解法"></a>解法</h4><p>方法一：模拟<br>思路与算法</p>
<p>一种容易想到的方法是，我们按照时间顺序，依次给每一个时间单位分配任务。</p>
<p>那么如果当前有多种任务不在冷却中，那么我们应该如何挑选执行的任务呢？直觉上，我们应当选择剩余执行次数最多的那个任务，将每种任务的剩余执行次数尽可能平均，使得 CPU 处于待命状态的时间尽可能少。当然这也是可以证明的，详细证明见下一个小标题。</p>
<p>因此我们可以用二元组 (\textit{nextValid}_i, \textit{rest}_i)(nextValid<br>i<br>​	<br> ,rest<br>i<br>​	<br> ) 表示第 ii 个任务，其中 \textit{nextValid}_inextValid<br>i<br>​	<br>  表示其因冷却限制，最早可以执行的时间；\textit{rest}_irest<br>i<br>​	<br>  表示其剩余执行次数。初始时，所有的 \textit{nextValid}_inextValid<br>i<br>​	<br>  均为 11，而 \textit{rest}_irest<br>i<br>​	<br>  即为任务 ii 在数组 \textit{tasks}tasks 中出现的次数。</p>
<p>我们用 \textit{time}time 记录当前的时间。根据我们的策略，我们需要选择不在冷却中并且剩余执行次数最多的那个任务，也就是说，我们需要找到满足 \textit{nextValid}_i \leq \textit{time}nextValid<br>i<br>​	<br> ≤time 的并且 \textit{rest}_irest<br>i<br>​	<br>  最大的索引 ii。因此我们只需要遍历所有的二元组，即可找到 ii。在这之后，我们将 (\textit{nextValid}_i, \textit{rest}_i)(nextValid<br>i<br>​	<br> ,rest<br>i<br>​	<br> ) 更新为 (\textit{time}+n+1, \textit{rest}_i-1)(time+n+1,rest<br>i<br>​	<br> −1)，记录任务 ii 下一次冷却结束的时间以及剩余执行次数。如果更新后的 \textit{rest}_i&#x3D;0rest<br>i<br>​	<br> &#x3D;0，那么任务 ii 全部做完，我们在遍历二元组时也就可以忽略它了。</p>
<p>而对于 \textit{time}time 的更新，我们可以选择将其不断增加 11，模拟每一个时间片。但这会导致我们在 CPU 处于待命状态时，对二元组进行不必要的遍历。为了减少时间复杂度，我们可以在每一次遍历之前，将 \textit{time}time 更新为所有 \textit{nextValid}_inextValid<br>i<br>​	<br>  中的最小值，直接「跳过」待命状态，保证每一次对二元组的遍历都是有效的。需要注意的是，只有当这个最小值大于 \textit{time}time 时，才需要这样快速更新。</p>
<p>证明</p>
<p>对于某个时间点 tt，设任务 aa 和 bb 均不在冷却中，并且它们分别剩余 pp 和 qq 次。不失一般性，假设 p&gt;qp&gt;q，那么我们应当在此时选择任务 aa，但我们选择了任务 bb。我们需要证明，存在一种交换方法，使得将此时的任务 bb「变成」任务 aa 后，总时间不会增加。</p>
<p>为了叙述方便，设 a_1, a_2, \cdots, a_pa<br>1<br>​	<br> ,a<br>2<br>​	<br> ,⋯,a<br>p<br>​	<br>  为选择任务 aa 的时间点，b_1, b_2, \cdots, b_qb<br>1<br>​	<br> ,b<br>2<br>​	<br> ,⋯,b<br>q<br>​	<br>  为选择任务 bb 的时间点，根据假设有</p>
<p>a_1 &gt; b_1 &#x3D; t<br>a<br>1<br>​	</p>
<blockquote>
<p>b<br>1<br>​	<br> &#x3D;t</p>
</blockquote>
<p>以及对于任意相邻的两项 a_i, a_{i+1}a<br>i<br>​	<br> ,a<br>i+1<br>​	<br>  或者 b_j, b_{j+1}b<br>j<br>​	<br> ,b<br>j+1<br>​	<br> ，均有</p>
<p>a_{i+1} - a_i &gt; n<br>a<br>i+1<br>​	<br> −a<br>i<br>​	</p>
<blockquote>
<p>n</p>
</blockquote>
<p>以及</p>
<p>b_{j+1} - b_j &gt; n<br>b<br>j+1<br>​	<br> −b<br>j<br>​	</p>
<blockquote>
<p>n</p>
</blockquote>
<p>接下来我们分情况讨论：</p>
<p>如果 \exists k’ \in [2, q]∃k<br>′<br> ∈[2,q] 使得 a_{k’} &lt; b_{k’}a<br>k<br>′</p>
<p>​	<br> &lt;b<br>k<br>′</p>
<p>​	<br> ，那么我们找出其中最小的那个 k’k<br>′<br>  记为 kk。此时我们有</p>
<p>\begin{cases} a_1 &gt; b_1 \ a_2 &gt; b_2 \ \cdots \ a_{k-1} &gt; b_{k-1} \ a_k &lt; b_k \end{cases}<br>⎩<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎨<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎪<br>⎧<br>​	</p>
<p>a<br>1<br>​	</p>
<blockquote>
<p>b<br>1<br>​	</p>
</blockquote>
<p>a<br>2<br>​	</p>
<blockquote>
<p>b<br>2<br>​	</p>
</blockquote>
<p>⋯<br>a<br>k−1<br>​	</p>
<blockquote>
<p>b<br>k−1<br>​	</p>
</blockquote>
<p>a<br>k<br>​	<br> &lt;b<br>k<br>​	</p>
<p>​	</p>
<p>那么我们可以构造序列：</p>
<p>b_1, b_2, \cdots, b_{k-1}, a_k, a_{k+1}, \cdots, a_pb<br>1<br>​	<br> ,b<br>2<br>​	<br> ,⋯,b<br>k−1<br>​	<br> ,a<br>k<br>​	<br> ,a<br>k+1<br>​	<br> ,⋯,a<br>p<br>​	<br>  作为交换后选择任务 aa 的时间点；<br>a_1, a_2, \cdots, a_{k-1}, b_k, b_{k+1}, \cdots, b_qa<br>1<br>​	<br> ,a<br>2<br>​	<br> ,⋯,a<br>k−1<br>​	<br> ,b<br>k<br>​	<br> ,b<br>k+1<br>​	<br> ,⋯,b<br>q<br>​	<br>  作为交换后选择任务 bb 的时间点。<br>对于交换后任务 aa 的序列，其一共有 pp 项，并且有</p>
<p>a_k - b_{k-1} &gt; a_k - a_{k-1} &gt; n<br>a<br>k<br>​	<br> −b<br>k−1<br>​	</p>
<blockquote>
<p>a<br>k<br>​	<br> −a<br>k−1<br>​	<br>n</p>
</blockquote>
<p>因此其满足任意相邻两项之差大于 nn，不会违反冷却时间的规则。</p>
<p>同理对于对于交换后任务 bb 的序列，其一共有 qq 项，并且有</p>
<p>b_k - a_{k-1} &gt; a_k - a_{k-1} &gt; n<br>b<br>k<br>​	<br> −a<br>k−1<br>​	</p>
<blockquote>
<p>a<br>k<br>​	<br> −a<br>k−1<br>​	<br>n</p>
</blockquote>
<p>同样不会违反冷却时间的规则。</p>
<p>如果 \forall k’ \in [2, q]∀k<br>′<br> ∈[2,q] 均有 a_{k’} &gt; b_{k’}a<br>k<br>′</p>
<p>​	</p>
<blockquote>
<p>b<br>k<br>′</p>
</blockquote>
<p>​	<br> ，那么我们只要构造序列：</p>
<p>b_1, b_2, \cdots, b_kb<br>1<br>​	<br> ,b<br>2<br>​	<br> ,⋯,b<br>k<br>​	<br>  作为交换后选择任务 aa 的时间点；<br>a_1, a_2, \cdots, a_k, b_{k+1}, \cdots, b_na<br>1<br>​	<br> ,a<br>2<br>​	<br> ,⋯,a<br>k<br>​	<br> ,b<br>k+1<br>​	<br> ,⋯,b<br>n<br>​	<br>  作为交换后选择任务 bb 的时间点。<br>由于 b_{k+1} - a_k &gt; b_{k+1} - b_k &gt; nb<br>k+1<br>​	<br> −a<br>k<br>​	</p>
<blockquote>
<p>b<br>k+1<br>​	<br> −b<br>k<br>​	<br>n，因此不会违反冷却时间的规则。</p>
</blockquote>
<p>无论哪一种情况，我们都将 b_1&#x3D;tb<br>1<br>​	<br> &#x3D;t 变成了选择任务 aa 的时间点，并且由于我们只在任务 aa 和 bb 的内部进行交换，因此交换后总时间一定不会增加。这样就证明了一定存在一种总时间最少的方法，是通过不断地选择不在冷却中并且剩余执行次数最多的那个任务得到的。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/">https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leastInterval</span><span class="params">(tasks []<span class="type">byte</span>, n <span class="type">int</span>)</span></span> (minTime <span class="type">int</span>) &#123;</span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        cnt[t]++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextValid := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(cnt))</span><br><span class="line">    rest := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(cnt))</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cnt &#123;</span><br><span class="line">        nextValid = <span class="built_in">append</span>(nextValid, <span class="number">1</span>)</span><br><span class="line">        rest = <span class="built_in">append</span>(rest, c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        minTime++</span><br><span class="line">        minNextValid := math.MaxInt64</span><br><span class="line">        <span class="keyword">for</span> i, r := <span class="keyword">range</span> rest &#123;</span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">0</span> &amp;&amp; nextValid[i] &lt; minNextValid &#123;</span><br><span class="line">                minNextValid = nextValid[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> minNextValid &gt; minTime &#123;</span><br><span class="line">            minTime = minNextValid</span><br><span class="line">        &#125;</span><br><span class="line">        best := <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i, r := <span class="keyword">range</span> rest &#123;</span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">0</span> &amp;&amp; nextValid[i] &lt;= minTime &amp;&amp; (best == <span class="number">-1</span> || r &gt; rest[best]) &#123;</span><br><span class="line">                best = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nextValid[best] = minTime + n + <span class="number">1</span></span><br><span class="line">        rest[best]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-I-在排序数组中查找数字-I-简单"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I-简单" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I[简单]"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I[简单]</h3><p>统计一个数字在排序数组中出现的次数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: 0
 </p>
<p>限制：</p>
<p>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 50000</p>
<p> </p>
<p>注意：本题与主站 34 题相同（仅返回值不同）：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>通过次数62,297提交次数117,791</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-77"><a href="#解法-77" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 二分查找,两端统计</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    first, last , mid := <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, (<span class="number">0</span> + <span class="built_in">len</span>(nums) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 先找起点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">            mid = (first + last ) / <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">            mid = (first + last) / <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> first &gt; last &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mid定位了,向两边延伸寻找首尾</span></span><br><span class="line">    first, last = mid, mid</span><br><span class="line">    searchFont := <span class="literal">false</span></span><br><span class="line">    searchEnd := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (first &gt;= <span class="number">0</span> || last &lt;= <span class="built_in">len</span>(nums) <span class="number">-1</span>) &amp;&amp; nums[first] == target &amp;&amp; nums[last] == target &amp;&amp; (!searchEnd || !searchFont) &#123;</span><br><span class="line">        <span class="keyword">if</span> first - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[first <span class="number">-1</span>] == target &#123;</span><br><span class="line">            first = first - <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            searchFont = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> last + <span class="number">1</span> &lt;= <span class="built_in">len</span>(nums) <span class="number">-1</span> &amp;&amp; nums[last + <span class="number">1</span>] == target &#123;</span><br><span class="line">            last = last + <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            searchEnd = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-17-打印从1到最大的n位数-简单"><a href="#剑指-Offer-17-打印从1到最大的n位数-简单" class="headerlink" title="剑指 Offer 17. 打印从1到最大的n位数[简单]"></a>剑指 Offer 17. 打印从1到最大的n位数[简单]</h3><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>示例 1:</p>
<p>输入: n &#x3D; 1<br>输出: [1,2,3,4,5,6,7,8,9]
 </p>
<p>说明：</p>
<p>用返回一个整数列表来代替打印<br>n 为正整数<br>通过次数70,318提交次数89,741</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-78"><a href="#解法-78" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    base := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        base *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; base;i ++ &#123;</span><br><span class="line">        ans = <span class="built_in">append</span>(ans, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="861-翻转矩阵后的得分-中等"><a href="#861-翻转矩阵后的得分-中等" class="headerlink" title="861. 翻转矩阵后的得分[中等]"></a>861. 翻转矩阵后的得分[中等]</h3><p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p>
<p>返回尽可能高的分数。</p>
<p> </p>
<p>示例：</p>
<p>输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>输出：39<br>解释：<br>转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]<br>0b1111 + 0b1001 + 0b1111 &#x3D; 15 + 9 + 15 &#x3D; 39
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &lt;&#x3D; 20<br>1 &lt;&#x3D; A[0].length &lt;&#x3D; 20<br>A[i][j] 是 0 或 1<br>通过次数21,908提交次数27,082</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/score-after-flipping-matrix">https://leetcode-cn.com/problems/score-after-flipping-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-79"><a href="#解法-79" class="headerlink" title="解法"></a>解法</h4><p>方法一：贪心<br>根据题意，能够知道一个重要的事实：给定一个翻转方案，则它们之间任意交换顺序后，得到的结果保持不变。因此，我们总可以先考虑所有的行翻转，再考虑所有的列翻转。</p>
<p>不难发现一点：为了得到最高的分数，矩阵的每一行的最左边的数都必须为 11。为了做到这一点，我们可以翻转那些最左边的数不为 11 的那些行，而其他的行则保持不动。</p>
<p>当将每一行的最左边的数都变为 11 之后，就只能进行列翻转了。为了使得总得分最大，我们要让每个列中 11 的数目尽可能多。因此，我们扫描除了最左边的列以外的每一列，如果该列 00 的数目多于 11 的数目，就翻转该列，其他的列则保持不变。</p>
<p>实际编写代码时，我们无需修改原矩阵，而是可以计算每一列对总分数的「贡献」，从而直接计算出最高的分数。假设矩阵共有 mm 行 nn 列，计算方法如下：</p>
<p>对于最左边的列而言，由于最优情况下，它们的取值都为 11，因此每个元素对分数的贡献都为 2^{n-1}2<br>n−1<br> ，总贡献为 m \times 2^{n-1}m×2<br>n−1<br> 。</p>
<p>对于第 jj 列（j&gt;0j&gt;0，此处规定最左边的列是第 00 列）而言，我们统计这一列 0,10,1 的数量，令其中的最大值为 kk，则 kk 是列翻转后的 11 的数量，该列的总贡献为 k \times 2^{n-j-1}k×2<br>n−j−1<br> 。需要注意的是，在统计 0,10,1 的数量的时候，要考虑最初进行的行反转。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixScore</span><span class="params">(a [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m, n := <span class="built_in">len</span>(a), <span class="built_in">len</span>(a[<span class="number">0</span>])</span><br><span class="line">    ans := <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>) * m</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">        ones := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, row := <span class="keyword">range</span> a &#123;</span><br><span class="line">            <span class="keyword">if</span> row[j] == row[<span class="number">0</span>] &#123;</span><br><span class="line">                ones++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ones &lt; m-ones &#123;</span><br><span class="line">            ones = m - ones</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span> - j) * ones</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(mn)O(mn)，其中 mm 为矩阵行数，nn 为矩阵列数。</p>
<p>空间复杂度：O(1)O(1)。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/score-after-flipping-matrix/solution/fan-zhuan-ju-zhen-hou-de-de-fen-by-leetc-cxma/">https://leetcode-cn.com/problems/score-after-flipping-matrix/solution/fan-zhuan-ju-zhen-hou-de-de-fen-by-leetc-cxma/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="1680-连接连续二进制数字-中等"><a href="#1680-连接连续二进制数字-中等" class="headerlink" title="1680. 连接连续二进制数字[中等]"></a>1680. 连接连续二进制数字[中等]</h3><p>给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 1<br>输出：1<br>解释：二进制的 “1” 对应着十进制的 1 。<br>示例 2：</p>
<p>输入：n &#x3D; 3<br>输出：27<br>解释：二进制下，1，2 和 3 分别对应 “1” ，”10” 和 “11” 。<br>将它们依次连接，我们得到 “11011” ，对应着十进制的 27 。<br>示例 3：</p>
<p>输入：n &#x3D; 12<br>输出：505379714<br>解释：连接结果为 “1101110010111011110001001101010111100” 。<br>对应的十进制数字为 118505380540 。<br>对 109 + 7 取余后，结果为 505379714 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 105</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers">https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-80"><a href="#解法-80" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatenatedBinary</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt;= n;i ++ &#123;</span><br><span class="line">        bitlen := bits.Len(<span class="type">uint</span>(i))</span><br><span class="line">        <span class="comment">// 左移空位，然后加</span></span><br><span class="line">        ans = <span class="type">int</span>((ans&lt;&lt;bitlen) + i) % (<span class="number">1e9</span>+<span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试题-17-10-主要元素-简单"><a href="#面试题-17-10-主要元素-简单" class="headerlink" title="面试题 17.10. 主要元素[简单]"></a>面试题 17.10. 主要元素[简单]</h3><p>数组中占比超过一半的元素称之为主要元素。给定一个整数数组，找到它的主要元素。若没有，返回-1。</p>
<p>示例 1：</p>
<p>输入：[1,2,5,9,5,9,5,5,5]<br>输出：5
 </p>
<p>示例 2：</p>
<p>输入：[3,2]<br>输出：-1
 </p>
<p>示例 3：</p>
<p>输入：[2,2,1,1,1,2,2]<br>输出：2
 </p>
<p>说明：<br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p>
<p>通过次数22,420提交次数38,902</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-majority-element-lcci">https://leetcode-cn.com/problems/find-majority-element-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-81"><a href="#解法-81" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 打仗，相同加一，不同减一。最后剩余的结果大于0说明存在</span></span><br><span class="line">    nMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        nMap[v] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nMap[v] &gt; n / <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="860-柠檬水找零-简单"><a href="#860-柠檬水找零-简单" class="headerlink" title="860. 柠檬水找零[简单]"></a>860. 柠檬水找零[简单]</h3><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。</p>
<p>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>示例 1：</p>
<p>输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：</p>
<p>输入：[5,5,10]<br>输出：true<br>示例 3：</p>
<p>输入：[10,10]<br>输出：false<br>示例 4：</p>
<p>输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; bills.length &lt;&#x3D; 10000<br>bills[i] 不是 5 就是 10 或是 20 <br>通过次数35,803提交次数63,683</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lemonade-change">https://leetcode-cn.com/problems/lemonade-change</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-82"><a href="#解法-82" class="headerlink" title="解法"></a>解法</h4><p>贪心，先付大的，再付小的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lemonadeChange</span><span class="params">(bills []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 5 10 20</span></span><br><span class="line">    <span class="comment">// 找零0 5 15</span></span><br><span class="line">    bMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, b := <span class="keyword">range</span> bills &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">5</span> &#123;</span><br><span class="line">            bMap[<span class="number">5</span>] += <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> b == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> bMap[<span class="number">5</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                bMap[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                bMap[<span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 20找零 10 + 5 || 5 × 3</span></span><br><span class="line">            <span class="keyword">if</span> bMap[<span class="number">10</span>] &gt; <span class="number">0</span> &amp;&amp; bMap[<span class="number">5</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                bMap[<span class="number">10</span>] -= <span class="number">1</span></span><br><span class="line">                bMap[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> bMap[<span class="number">5</span>] &gt;= <span class="number">3</span> &#123;</span><br><span class="line">                bMap[<span class="number">5</span>] -= <span class="number">3</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="455-分发饼干-简单"><a href="#455-分发饼干-简单" class="headerlink" title="455. 分发饼干[简单]"></a>455. 分发饼干[简单]</h3><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p> <br>示例 1:</p>
<p>输入: g &#x3D; [1,2,3], s &#x3D; [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br>示例 2:</p>
<p>输入: g &#x3D; [1,2], s &#x3D; [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; g.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; s.length &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; g[i], s[j] &lt;&#x3D; 231 - 1<br>通过次数65,009提交次数115,716</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies">https://leetcode-cn.com/problems/assign-cookies</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-83"><a href="#解法-83" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContentChildren</span><span class="params">(g []<span class="type">int</span>, s []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(g) &lt; <span class="number">1</span> || <span class="built_in">len</span>(s) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(g)</span><br><span class="line">    sort.Ints(s)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="built_in">len</span>(g) &amp;&amp; v &gt;= g[index]&#123;</span><br><span class="line">            index ++</span><br><span class="line">            ans ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="842-将数组拆分成斐波那契序列-中等"><a href="#842-将数组拆分成斐波那契序列-中等" class="headerlink" title="842. 将数组拆分成斐波那契序列[中等]"></a>842. 将数组拆分成斐波那契序列[中等]</h3><p>给定一个数字字符串 S，比如 S &#x3D; “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p>
<p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p>
<p>0 &lt;&#x3D; F[i] &lt;&#x3D; 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;&#x3D; 3；<br>对于所有的0 &lt;&#x3D; i &lt; F.length - 2，都有 F[i] + F[i+1] &#x3D; F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p>
<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”123456579”<br>输出：[123,456,579]<br>示例 2：</p>
<p>输入: “11235813”<br>输出: [1,1,2,3,5,8,13]<br>示例 3：</p>
<p>输入: “112358130”<br>输出: []<br>解释: 这项任务无法完成。<br>示例 4：</p>
<p>输入：”0123”<br>输出：[]<br>解释：每个块的数字不能以零开头，因此 “01”，”2”，”3” 不是有效答案。<br>示例 5：</p>
<p>输入: “1101111”<br>输出: [110, 1, 111]<br>解释: 输出 [11,0,11,11] 也同样被接受。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; S.length &lt;&#x3D; 200<br>字符串 S 中只含有数字。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-84"><a href="#解法-84" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">splitIntoFibonacci</span><span class="params">(s <span class="type">string</span>)</span></span> (F []<span class="type">int</span>) &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">var</span> backtrack <span class="function"><span class="keyword">func</span><span class="params">(index, sum, prev <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">    backtrack = <span class="function"><span class="keyword">func</span><span class="params">(index, sum, prev <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> index == n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(F) &gt;= <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := index; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="comment">// 每个块的数字一定不要以零开头，除非这个块是数字 0 本身</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; index &amp;&amp; s[index] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur = cur*<span class="number">10</span> + <span class="type">int</span>(s[i]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="comment">// 拆出的整数要符合 32 位有符号整数类型</span></span><br><span class="line">            <span class="keyword">if</span> cur &gt; math.MaxInt32 &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// F[i] + F[i+1] = F[i+2]</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(F) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> cur &lt; sum &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> cur &gt; sum &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cur 符合要求，加入序列 F</span></span><br><span class="line">            F = <span class="built_in">append</span>(F, cur)</span><br><span class="line">            <span class="keyword">if</span> backtrack(i+<span class="number">1</span>, prev+cur, cur) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            F = F[:<span class="built_in">len</span>(F)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    backtrack(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="213-打家劫舍-II-中等"><a href="#213-打家劫舍-II-中等" class="headerlink" title="213. 打家劫舍 II[中等]"></a>213. 打家劫舍 II[中等]</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 3：</p>
<p>输入：nums &#x3D; [0]<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>通过次数66,513提交次数165,803</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii">https://leetcode-cn.com/problems/house-robber-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-85"><a href="#解法-85" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">     n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    dp1 := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dp2 := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums[<span class="number">1</span>:] &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp1[i] = v</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> dp1[i - <span class="number">1</span>] &gt; v &#123;</span><br><span class="line">                dp1[i] = dp1[i <span class="number">-1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp1[i] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> dp1[i - <span class="number">2</span>] + v &gt; dp1[i - <span class="number">1</span>] &#123;</span><br><span class="line">                dp1[i] = dp1[i - <span class="number">2</span>] + v</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp1[i] = dp1[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ans &lt; dp1[i]&#123;</span><br><span class="line">            ans = dp1[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums[: n<span class="number">-1</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp2[i] = v</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> dp2[i - <span class="number">1</span>] &gt;  v&#123;</span><br><span class="line">                dp2[i] = dp2[i <span class="number">-1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp2[i] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> dp2[i - <span class="number">2</span>] + v &gt; dp2[i - <span class="number">1</span>] &#123;</span><br><span class="line">                dp2[i] = dp2[i - <span class="number">2</span>] + v</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp2[i] = dp2[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ans &lt; dp2[i] &#123;</span><br><span class="line">            ans = dp2[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划–路径问题"><a href="#动态规划–路径问题" class="headerlink" title="动态规划–路径问题"></a>动态规划–路径问题</h2><h3 id="62-不同路径-中等"><a href="#62-不同路径-中等" class="headerlink" title="62. 不同路径[中等]"></a>62. 不同路径[中等]</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> </p>
<p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下</li>
<li>向右 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向右<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109<br>通过次数187,109提交次数294,386</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths">https://leetcode-cn.com/problems/unique-paths</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>动态规划,处于i,j的节点路径个数等于(i -1,j) (i,j -1)两个点之和。当前的节点受前面数据影响，但不会反过来影响前面的节点。这既是终点又是起点。注意边缘只受左或上节点影响。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n; i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; m; j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j <span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n <span class="number">-1</span>][m <span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63-不同路径-II-中等"><a href="#63-不同路径-II-中等" class="headerlink" title="63. 不同路径 II[中等]"></a>63. 不同路径 II[中等]</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p> </p>
<p>示例 1：<br><img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg"></p>
<p>输入：obstacleGrid &#x3D; [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br>示例 2：</li>
</ol>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg"><br>输入：obstacleGrid &#x3D; [[0,1],[0,0]]<br>输出：1
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; obstacleGrid.length<br>n &#x3D;&#x3D; obstacleGrid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>obstacleGrid[i][j] 为 0 或 1<br>通过次数112,978提交次数303,865</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-86"><a href="#解法-86" class="headerlink" title="解法"></a>解法</h4><p>和上一题一样，只是判断条件变更一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(obstacleGrid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">    m := <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n;i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; m;j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">-1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> || j == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">-1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j] == <span class="number">-1</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">-1</span></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> j &gt; <span class="number">0</span> &amp;&amp; dp[i][j - <span class="number">1</span>] == <span class="number">-1</span>&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">-1</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t := <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> dp[i - <span class="number">1</span>][j] != <span class="number">-1</span> &#123;</span><br><span class="line">                    t += dp[i - <span class="number">1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> dp[i][j - <span class="number">1</span>] != <span class="number">-1</span> &#123;</span><br><span class="line">                    t += dp[i][j - <span class="number">1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">-1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = t</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> dp[n - <span class="number">1</span>][m <span class="number">-1</span>] == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n <span class="number">-1</span>][m <span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="64-最小路径和-中等"><a href="#64-最小路径和-中等" class="headerlink" title="64. 最小路径和[中等]"></a>64. 最小路径和[中等]</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100<br>通过次数164,703提交次数242,840</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum">https://leetcode-cn.com/problems/minimum-path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-87"><a href="#解法-87" class="headerlink" title="解法"></a>解法</h4><p>和前面两题一致，只不过现在存储的是最小路径了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(grid)</span><br><span class="line">    m := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, m)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; m;j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &#123;</span><br><span class="line">                dp[i][j] = grid[i][j]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>&#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i][j <span class="number">-1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + dp[i <span class="number">-1</span>][j]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + min(dp[i <span class="number">-1</span>][j], dp[i][j <span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="120-三角形最小路径和-中等"><a href="#120-三角形最小路径和-中等" class="headerlink" title="120. 三角形最小路径和[中等]"></a>120. 三角形最小路径和[中等]</h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<p> </p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</p>
<p> </p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<p>通过次数120,150提交次数179,666</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle">https://leetcode-cn.com/problems/triangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-88"><a href="#解法-88" class="headerlink" title="解法"></a>解法</h4><p>思路和上面的那一题一样，只不过需要使用O(n)的空间，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumTotal</span><span class="params">(triangle [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(triangle)</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    dp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            dp = <span class="built_in">append</span>(dp, triangle[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">            index ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 选择最小的值</span></span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(triangle[i]);j ++&#123;</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 最左边，只能选取上层的</span></span><br><span class="line">                    tmpIndex := index - i</span><br><span class="line">                    dp =<span class="built_in">append</span>(dp, dp[tmpIndex] + triangle[i][j])</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> j &gt; <span class="number">0</span> &amp;&amp; j + <span class="number">1</span> &gt; <span class="built_in">len</span>(triangle[i <span class="number">-1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 最右边</span></span><br><span class="line">                    tmpIndex := index - <span class="number">1</span> - i</span><br><span class="line">                    dp = <span class="built_in">append</span>(dp, dp[tmpIndex] + triangle[i][j])</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> j &gt; <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(triangle[i <span class="number">-1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 中间，选上层两边最小的</span></span><br><span class="line">                    tmpIndex1 := index - i</span><br><span class="line">                    tmpIndex2 := index - <span class="number">1</span> - i</span><br><span class="line">                    <span class="keyword">if</span> dp[tmpIndex1] &lt; dp[tmpIndex2] &#123;</span><br><span class="line">                        dp = <span class="built_in">append</span>(dp, dp[tmpIndex1] + triangle[i][j])</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp =<span class="built_in">append</span>(dp, dp[tmpIndex2] + triangle[i][j])</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                index ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fmt.Println(dp[len(dp) - n:])</span></span><br><span class="line">    ans := math.MaxInt32</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> dp[<span class="built_in">len</span>(dp) -n :] &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; ans &#123;</span><br><span class="line">            ans = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="91-解码方法-中等"><a href="#91-解码方法-中等" class="headerlink" title="91. 解码方法[中等]"></a>91. 解码方法[中等]</h3><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p>题目数据保证答案肯定是一个 32 位的整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p>
<p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p>
<p>输入：s &#x3D; “0”<br>输出：0<br>示例 4：</p>
<p>输入：s &#x3D; “1”<br>输出：1<br>示例 5：</p>
<p>输入：s &#x3D; “2”<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数77,303提交次数309,169</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-89"><a href="#解法-89" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 0不可以单独编码</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 状态转移 s[i] == &#x27;0&#x27; 必须和s[i -1]进行组合编码,不产生新的可能性dp[i] = dp[i -1]，</span></span><br><span class="line">    <span class="comment">// 不能组合编码说明解码失败，直接退出解码流程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; n; i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;2&#x27;</span> &#123;</span><br><span class="line">                <span class="comment">// 可以编码，和s[i-1]合并之后，唯一确定了,不产生新的方法，并且将s[i-1]合并之后，dp[i] = dp[i -2]</span></span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">2</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 0无法解码</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// s[i] != &#x27;0&#x27;</span></span><br><span class="line">            <span class="comment">// 不能超过26,不能小于10</span></span><br><span class="line">            <span class="comment">// 能够和s[i -1]合并的条件，s[i - 1] == &#x27;1&#x27; || (s[i -1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;)</span></span><br><span class="line">            <span class="keyword">if</span> s[i <span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> || (s[i <span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;6&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 可以合并，有两种可能，第一种：合并，dp[i] = dp[i-2]，不合并dp[i] = dp[i -1]</span></span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">2</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 11 26 -&gt; 1</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i <span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n <span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="649-Dota2-参议院-中等"><a href="#649-Dota2-参议院-中等" class="headerlink" title="649. Dota2 参议院[中等]"></a>649. Dota2 参议院[中等]</h3><p>Dota2 的世界里有两个阵营：Radiant(天辉)和 Dire(夜魇)</p>
<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的一项：</p>
<p>禁止一名参议员的权利：</p>
<p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失所有的权利。</p>
<p>宣布胜利：</p>
<p>          如果参议员发现有权利投票的参议员都是同一个阵营的，他可以宣布胜利并决定在游戏中的有关变化。</p>
<p> </p>
<p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p>
<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>
<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 Radiant 或 Dire。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”RD”<br>输出：”Radiant”<br>解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人<br>示例 2：</p>
<p>输入：”RDD”<br>输出：”Dire”<br>解释：<br>第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利<br>第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止<br>第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利<br>因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
 </p>
<p>提示：</p>
<p>给定字符串的长度在 [1, 10,000] 之间.
 </p>
<p>通过次数20,226提交次数43,548</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dota2-senate">https://leetcode-cn.com/problems/dota2-senate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="解法-90"><a href="#解法-90" class="headerlink" title="解法"></a>解法</h3><p>方法一：「循环」队列<br>思路与算法</p>
<p>我们以天辉方的议员为例。当一名天辉方的议员行使权利时：</p>
<p>如果目前所有的议员都为天辉方，那么该议员可以直接宣布天辉方取得胜利；</p>
<p>如果目前仍然有夜魇方的议员，那么这名天辉方的议员只能行使「禁止一名参议员的权利」这一项权利。显然，该议员不会令一名同为天辉方的议员丧失权利，所以他一定会挑选一名夜魇方的议员。那么应该挑选哪一名议员呢？容易想到的是，应该贪心地挑选按照投票顺序的下一名夜魇方的议员。这也是很容易形象化地证明的：既然只能挑选一名夜魇方的议员，那么就应该挑最早可以进行投票的那一名议员；如果挑选了其它较晚投票的议员，那么等到最早可以进行投票的那一名议员行使权利时，一名天辉方议员就会丧失权利，这样就得不偿失了。</p>
<p>由于我们总要挑选投票顺序最早的议员，因此我们可以使用两个队列 \textit{radiant}radiant 和 \textit{dire}dire 分别按照投票顺序存储天辉方和夜魇方每一名议员的投票时间。随后我们就可以开始模拟整个投票的过程：</p>
<p>如果此时 \textit{radiant}radiant 或者 \textit{dire}dire 为空，那么就可以宣布另一方获得胜利；</p>
<p>如果均不为空，那么比较这两个队列的首元素，就可以确定当前行使权利的是哪一名议员。如果 \textit{radiant}radiant 的首元素较小，那说明轮到天辉方的议员行使权利，其会挑选 \textit{dire}dire 的首元素对应的那一名议员。因此，我们会将 \textit{dire}dire 的首元素永久地弹出，并将 \textit{radiant}radiant 的首元素弹出，增加 nn 之后再重新放回队列，这里 nn 是给定的字符串 \textit{senate}senate 的长度，即表示该议员会参与下一轮的投票。</p>
<p>为什么这里是固定地增加 nn，而不是增加与当前剩余议员数量相关的一个数？读者可以思考一下这里的正确性。</p>
<p>同理，如果 \textit{dire}dire 的首元素较小，那么会永久弹出 \textit{radiant}radiant 的首元素，剩余的处理方法也是类似的。</p>
<p>这样一来，我们就模拟了整个投票的过程，也就可以得到最终的答案了。</p>
<p>代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predictPartyVictory</span><span class="params">(senate <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> radiant, dire []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> i, s := <span class="keyword">range</span> senate &#123;</span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">&#x27;R&#x27;</span> &#123;</span><br><span class="line">            radiant = <span class="built_in">append</span>(radiant, i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dire = <span class="built_in">append</span>(dire, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(radiant) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(dire) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> radiant[<span class="number">0</span>] &lt; dire[<span class="number">0</span>] &#123;</span><br><span class="line">            radiant = <span class="built_in">append</span>(radiant, radiant[<span class="number">0</span>]+<span class="built_in">len</span>(senate))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dire = <span class="built_in">append</span>(dire, dire[<span class="number">0</span>]+<span class="built_in">len</span>(senate))</span><br><span class="line">        &#125;</span><br><span class="line">        radiant = radiant[<span class="number">1</span>:]</span><br><span class="line">        dire = dire[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(radiant) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Radiant&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Dire&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是字符串 \textit{senate}senate 的长度。在模拟整个投票过程的每一步，我们进行的操作的时间复杂度均为 O(1)O(1)，并且会弹出一名天辉方或夜魇方的议员。由于议员的数量为 nn，因此模拟的步数不会超过 nn，时间复杂度即为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，即为两个队列需要使用的空间。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/dota2-senate/solution/dota2-can-yi-yuan-by-leetcode-solution-jb7l/">https://leetcode-cn.com/problems/dota2-senate/solution/dota2-can-yi-yuan-by-leetcode-solution-jb7l/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="1518-换酒问题-简单"><a href="#1518-换酒问题-简单" class="headerlink" title="1518. 换酒问题[简单]"></a>1518. 换酒问题[简单]</h3><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p>
<p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p>
<p>请你计算 最多 能喝到多少瓶酒。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：numBottles &#x3D; 9, numExchange &#x3D; 3<br>输出：13<br>解释：你可以用 3 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 9 + 3 + 1 &#x3D; 13 瓶酒。<br>示例 2：</p>
<p>输入：numBottles &#x3D; 15, numExchange &#x3D; 4<br>输出：19<br>解释：你可以用 4 个空酒瓶兑换 1 瓶酒。<br>所以最多能喝到 15 + 3 + 1 &#x3D; 19 瓶酒。<br>示例 3：</p>
<p>输入：numBottles &#x3D; 5, numExchange &#x3D; 5<br>输出：6<br>示例 4：</p>
<p>输入：numBottles &#x3D; 2, numExchange &#x3D; 3<br>输出：2
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; numBottles &lt;&#x3D; 100<br>2 &lt;&#x3D; numExchange &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/water-bottles">https://leetcode-cn.com/problems/water-bottles</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-91"><a href="#解法-91" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWaterBottles</span><span class="params">(numBottles <span class="type">int</span>, numExchange <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    empty := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> numBottles &gt; <span class="number">0</span> &#123;</span><br><span class="line">        numBottles --</span><br><span class="line">        empty ++</span><br><span class="line">        ans ++</span><br><span class="line">        <span class="comment">// 凑够空瓶就直接换</span></span><br><span class="line">        <span class="keyword">if</span> empty == numExchange &#123;</span><br><span class="line">            numBottles ++</span><br><span class="line">            empty = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="376-摆动序列-中等"><a href="#376-摆动序列-中等" class="headerlink" title="376. 摆动序列[中等]"></a>376. 摆动序列[中等]</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<p>输入: [1,7,4,9,2,5]<br>输出: 6<br>解释: 整个序列均为摆动序列。<br>示例 2:</p>
<p>输入: [1,17,5,10,13,15,10,5,16,8]<br>输出: 7<br>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。<br>示例 3:</p>
<p>输入: [1,2,3,4,5,6,7,8,9]<br>输出: 2<br>进阶:<br>你能否用 O(n) 时间复杂度完成此题</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence">https://leetcode-cn.com/problems/wiggle-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-92"><a href="#解法-92" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    up, down := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            up = max(up, down+<span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            down = max(up+<span class="number">1</span>, down)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(up, down)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1590-使数组和能被-P-整除-中等"><a href="#1590-使数组和能被-P-整除-中等" class="headerlink" title="1590. 使数组和能被 P 整除[中等]"></a>1590. 使数组和能被 P 整除[中等]</h3><p>给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。</p>
<p>请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。</p>
<p>子数组 定义为原数组中连续的一组元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,1,4,2], p &#x3D; 6<br>输出：1<br>解释：nums 中元素和为 10，不能被 p 整除。我们可以移除子数组 [4] ，剩余元素的和为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [6,3,5,2], p &#x3D; 9<br>输出：2<br>解释：我们无法移除任何一个元素使得和被 9 整除，最优方案是移除子数组 [5,2] ，剩余元素为 [6,3]，和为 9 。<br>示例 3：</p>
<p>输入：nums &#x3D; [1,2,3], p &#x3D; 3<br>输出：0<br>解释：和恰好为 6 ，已经能被 3 整除了。所以我们不需要移除任何元素。<br>示例  4：</p>
<p>输入：nums &#x3D; [1,2,3], p &#x3D; 7<br>输出：-1<br>解释：没有任何方案使得移除子数组后剩余元素的和被 7 整除。<br>示例 5：</p>
<p>输入：nums &#x3D; [1000000000,1000000000,1000000000], p &#x3D; 3<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>1 &lt;&#x3D; p &lt;&#x3D; 109<br>通过次数1,854提交次数7,780</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/make-sum-divisible-by-p">https://leetcode-cn.com/problems/make-sum-divisible-by-p</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-93"><a href="#解法-93" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSubarray</span><span class="params">(nums []<span class="type">int</span>, p <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        sum += <span class="type">int64</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">    mod := sum % <span class="type">int64</span>(p)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> == mod &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="built_in">len</span>(nums)</span><br><span class="line">    table := <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>&#123;<span class="number">0</span>: <span class="number">-1</span>&#125;</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums);i ++&#123;</span><br><span class="line">        sum += <span class="type">int64</span>(nums[i])</span><br><span class="line">        curMod := sum % <span class="type">int64</span>(p)</span><br><span class="line">        table[curMod] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> targetMod <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> curMod &gt;= mod &#123;</span><br><span class="line">            targetMod = curMod - mod</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            targetMod = curMod - mod + <span class="type">int64</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> _,ok := table[targetMod];ok &#123;</span><br><span class="line">            res = min(res, i - table[targetMod])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="287-寻找重复数-中等"><a href="#287-寻找重复数-中等" class="headerlink" title="287. 寻找重复数[中等]"></a>287. 寻找重复数[中等]</h3><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p>
<p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>
<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。<br>通过次数110,297提交次数166,875</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-94"><a href="#解法-94" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    first, last := <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">    ans := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        mid := (first + last) &gt;&gt; <span class="number">1</span></span><br><span class="line">        cnt := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt;= mid &#123;</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt &lt;= mid &#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">            ans = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="744-寻找比目标字母大的最小字母-简单"><a href="#744-寻找比目标字母大的最小字母-简单" class="headerlink" title="744. 寻找比目标字母大的最小字母[简单]"></a>744. 寻找比目标字母大的最小字母[简单]</h3><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。</p>
<p>在比较时，字母是依序循环出现的。举个例子：</p>
<p>如果目标字母 target &#x3D; ‘z’ 并且字符列表为 letters &#x3D; [‘a’, ‘b’]，则答案返回 ‘a’
 </p>
<p>示例：</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “a”<br>输出: “c”</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “c”<br>输出: “f”</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “d”<br>输出: “f”</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “g”<br>输出: “j”</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “j”<br>输出: “c”</p>
<p>输入:<br>letters &#x3D; [“c”, “f”, “j”]<br>target &#x3D; “k”<br>输出: “c”
 </p>
<p>提示：</p>
<p>letters长度范围在[2, 10000]区间内。<br>letters 仅由小写字母组成，最少包含两个不同的字母。<br>目标字母target 是一个小写字母。<br>通过次数27,173提交次数59,671</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target">https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-95"><a href="#解法-95" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreatestLetter</span><span class="params">(letters []<span class="type">byte</span>, target <span class="type">byte</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">    first, last, mid := <span class="number">0</span>, <span class="built_in">len</span>(letters) - <span class="number">1</span>, (<span class="built_in">len</span>(letters) - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        <span class="keyword">if</span> letters[mid] &gt; target &#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (first + last) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> first &gt;= <span class="built_in">len</span>(letters) &#123;</span><br><span class="line">        <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letters[first]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="278-第一个错误的版本-简单"><a href="#278-第一个错误的版本-简单" class="headerlink" title="278. 第一个错误的版本[简单]"></a>278. 第一个错误的版本[简单]</h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p>示例:</p>
<p>给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</p>
<p>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true</p>
<p>所以，4 是第一个错误的版本。 <br>通过次数73,107提交次数176,199</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version">https://leetcode-cn.com/problems/first-bad-version</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-96"><a href="#解法-96" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstBadVersion</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    first,last,mid := <span class="number">1</span>, n, (n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        <span class="keyword">if</span> isBadVersion(mid) &#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (first + last) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="738-单调递增的数字-中等"><a href="#738-单调递增的数字-中等" class="headerlink" title="738. 单调递增的数字[中等]"></a>738. 单调递增的数字[中等]</h3><p>给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是单调递增的。）</p>
<p>示例 1:</p>
<p>输入: N &#x3D; 10<br>输出: 9<br>示例 2:</p>
<p>输入: N &#x3D; 1234<br>输出: 1234<br>示例 3:</p>
<p>输入: N &#x3D; 332<br>输出: 299<br>说明: N 是在 [0, 10^9] 范围内的一个整数。</p>
<p>通过次数24,995提交次数50,506</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/monotone-increasing-digits">https://leetcode-cn.com/problems/monotone-increasing-digits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-97"><a href="#解法-97" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(N <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// x小于等于N，并且单调递增的</span></span><br><span class="line">    s := []<span class="type">byte</span>(strconv.Itoa(N))</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; s[i] &gt;= s[i - <span class="number">1</span>] &#123;</span><br><span class="line">        i ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s)&#123;</span><br><span class="line">        <span class="keyword">for</span> i &gt; <span class="number">0</span> &amp;&amp; s[i] &lt; s[i - <span class="number">1</span>] &#123;</span><br><span class="line">            s[i - <span class="number">1</span>] --</span><br><span class="line">            i --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i ++;i &lt; <span class="built_in">len</span>(s);i ++&#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans, _ := strconv.Atoi(<span class="type">string</span>(s))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="106-从中序与后序遍历序列构造二叉树-中等"><a href="#106-从中序与后序遍历序列构造二叉树-中等" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树[中等]"></a>106. 从中序与后序遍历序列构造二叉树[中等]</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>中序遍历 inorder &#x3D; [9,3,15,20,7]<br>后序遍历 postorder &#x3D; [9,15,7,20,3]<br>返回如下的二叉树：</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>通过次数80,870提交次数114,177</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-98"><a href="#解法-98" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(inorder []<span class="type">int</span>, postorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(postorder) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    tree := &amp;TreeNode&#123;&#125;</span><br><span class="line">    <span class="comment">// 后序最后节点肯定是根节点</span></span><br><span class="line">    tree.Val = postorder[<span class="built_in">len</span>(postorder) - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 切割中序</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> inorder &#123;</span><br><span class="line">        <span class="keyword">if</span> v == tree.Val &#123;</span><br><span class="line">            <span class="comment">// 寻找到切割点</span></span><br><span class="line">            tree.Left = buildTree(inorder[:i], postorder[:i])</span><br><span class="line">            tree.Right = buildTree(inorder[i + <span class="number">1</span>:], postorder[i : <span class="built_in">len</span>(postorder) - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="560-和为K的子数组-中等"><a href="#560-和为K的子数组-中等" class="headerlink" title="560. 和为K的子数组[中等]"></a>560. 和为K的子数组[中等]</h3><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<p>输入:nums &#x3D; [1,1,1], k &#x3D; 2<br>输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。<br>说明 :</p>
<p>数组的长度为 [1, 20,000]。<br>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。<br>通过次数81,696提交次数181,801</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-sum-equals-k">https://leetcode-cn.com/problems/subarray-sum-equals-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-99"><a href="#解法-99" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraySum</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    cnt,pre := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        pre += v</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[pre - k];ok &#123;</span><br><span class="line">            cnt += m[pre - k]</span><br><span class="line">        &#125;</span><br><span class="line">        m[pre] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="451-根据字符出现频率排序-中等"><a href="#451-根据字符出现频率排序-中等" class="headerlink" title="451. 根据字符出现频率排序[中等]"></a>451. 根据字符出现频率排序[中等]</h3><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例 1:</p>
<p>输入:<br>“tree”</p>
<p>输出:<br>“eert”</p>
<p>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。<br>示例 2:</p>
<p>输入:<br>“cccaaa”</p>
<p>输出:<br>“cccaaa”</p>
<p>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。<br>示例 3:</p>
<p>输入:<br>“Aabb”</p>
<p>输出:<br>“bbAa”</p>
<p>解释:<br>此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。<br>注意’A’和’a’被认为是两种不同的字符。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-characters-by-frequency">https://leetcode-cn.com/problems/sort-characters-by-frequency</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-100"><a href="#解法-100" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">frequencySort</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">        m[c] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> m&#123;</span><br><span class="line">        arr = <span class="built_in">append</span>(arr, v)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i] &gt; arr[j]</span><br><span class="line">    &#125;)</span><br><span class="line">    res := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">for</span> k,value := <span class="keyword">range</span> m &#123;</span><br><span class="line">            <span class="keyword">if</span> v == value &#123;</span><br><span class="line">                <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; v;i ++&#123;</span><br><span class="line">                    res = <span class="built_in">append</span>(res, k)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">delete</span>(m, k)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="80-删除排序数组中的重复项-II-中等"><a href="#80-删除排序数组中的重复项-II-中等" class="headerlink" title="80. 删除排序数组中的重复项 II[中等]"></a>80. 删除排序数组中的重复项 II[中等]</h3><p>给定一个增序排列数组 nums ，你需要在 原地 删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p> </p>
<p>说明：</p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下：</p>
<p>&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝<br>int len &#x3D; removeDuplicates(nums);</p>
<p>&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。<br>&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。<br>for (int i &#x3D; 0; i &lt; len; i++) {<br>    print(nums[i]);<br>}
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,1,2,2,3]<br>输出：5, nums &#x3D; [1,1,2,2,3]<br>解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]<br>输出：7, nums &#x3D; [0,0,1,1,2,3,3]<br>解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 按递增顺序排列</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-101"><a href="#解法-101" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">    &#125;</span><br><span class="line">    index := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != nums[index - <span class="number">2</span>] &#123;</span><br><span class="line">            nums[index] = nums[i]</span><br><span class="line">            index ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="102-二叉树的层序遍历-中等"><a href="#102-二叉树的层序遍历-中等" class="headerlink" title="102. 二叉树的层序遍历[中等]"></a>102. 二叉树的层序遍历[中等]</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例：<br>二叉树：[3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回其层次遍历结果：</p>
<p>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]<br>通过次数228,667提交次数358,232<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">https://leetcode-cn.com/problems/binary-tree-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-102"><a href="#解法-102" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;root.Val&#125;)</span><br><span class="line">    left := levelOrder(root.Left)</span><br><span class="line">    right := levelOrder(root.Right)</span><br><span class="line">    layout := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 层层合并</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(left)||i &lt; <span class="built_in">len</span>(right);i ++&#123;</span><br><span class="line">        tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(left) &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, left[i]...)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, right[i]...)</span><br><span class="line">        &#125;</span><br><span class="line">        layout = <span class="built_in">append</span>(layout, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, layout...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="103-二叉树的锯齿形层次遍历-中等"><a href="#103-二叉树的锯齿形层次遍历-中等" class="headerlink" title="103. 二叉树的锯齿形层次遍历[中等]"></a>103. 二叉树的锯齿形层次遍历[中等]</h3><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回锯齿形层次遍历如下：</p>
<p>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]<br>通过次数83,481提交次数151,198</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-103"><a href="#解法-103" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, []<span class="type">int</span>&#123;root.Val&#125;)</span><br><span class="line">    left := getLevelOrder(root.Left)</span><br><span class="line">    right := getLevelOrder(root.Right)</span><br><span class="line">    layout := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(left) || i &lt; <span class="built_in">len</span>(right);i ++ &#123;</span><br><span class="line">        tmp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(left) &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp, left[i]...)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,right[i]...)</span><br><span class="line">        &#125;</span><br><span class="line">        layout = <span class="built_in">append</span>(layout, tmp)</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">append</span>(res, layout...)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    tmp := getLevelOrder(root)</span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(tmp);i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp2 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j := <span class="built_in">len</span>(tmp[i]) - <span class="number">1</span>;j &gt;=<span class="number">0</span>;j -- &#123;</span><br><span class="line">                tmp2 = <span class="built_in">append</span>(tmp2, tmp[i][j])</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, tmp2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="714-买卖股票的最佳时机含手续费-简单"><a href="#714-买卖股票的最佳时机含手续费-简单" class="headerlink" title="714. 买卖股票的最佳时机含手续费[简单]"></a>714. 买卖股票的最佳时机含手续费[简单]</h3><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1:</p>
<p>输入: prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] &#x3D; 1<br>在此处卖出 prices[3] &#x3D; 8<br>在此处买入 prices[4] &#x3D; 4<br>在此处卖出 prices[5] &#x3D; 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8.<br>注意:</p>
<p>0 &lt; prices.length &lt;&#x3D; 50000.<br>0 &lt; prices[i] &lt; 50000.<br>0 &lt;&#x3D; fee &lt; 50000.<br>通过次数56,589提交次数81,204</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-104"><a href="#解法-104" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>, fee <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    sell, buy := <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        sell = max(sell, buy+prices[i]-fee)</span><br><span class="line">        buy = max(buy, sell-prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sell</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="152-乘积最大子数组-中等"><a href="#152-乘积最大子数组-中等" class="headerlink" title="152. 乘积最大子数组[中等]"></a>152. 乘积最大子数组[中等]</h3><p>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br>通过次数108,015提交次数265,260</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-105"><a href="#解法-105" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := math.MinInt32</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n; i ++&#123;</span><br><span class="line">        pre := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j := i; j &lt; n;j ++&#123;</span><br><span class="line">            pre = pre * nums[j]</span><br><span class="line">            <span class="keyword">if</span> pre &gt; max &#123;</span><br><span class="line">                max = pre</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="898-子数组按位或操作-中等"><a href="#898-子数组按位或操作-中等" class="headerlink" title="898. 子数组按位或操作[中等]"></a>898. 子数组按位或操作[中等]</h3><p>我们有一个非负整数数组 A。</p>
<p>对于每个（连续的）子数组 B &#x3D; [A[i], A[i+1], …, A[j]] （ i &lt;&#x3D; j），我们对 B 中的每个元素进行按位或操作，获得结果 A[i] | A[i+1] | … | A[j]。</p>
<p>返回可能结果的数量。 （多次出现的结果在最终答案中仅计算一次。）</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[0]<br>输出：1<br>解释：<br>只有一个可能的结果 0 。<br>示例 2：</p>
<p>输入：[1,1,2]<br>输出：3<br>解释：<br>可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。<br>产生的结果为 1，1，2，1，3，3 。<br>有三个唯一值，所以答案是 3 。<br>示例 3：</p>
<p>输入：[1,2,4]<br>输出：6<br>解释：<br>可能的结果是 1，2，3，4，6，以及 7 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bitwise-ors-of-subarrays">https://leetcode-cn.com/problems/bitwise-ors-of-subarrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-106"><a href="#解法-106" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarrayBitwiseORs</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    nMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    cur := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    cur[<span class="number">0</span>] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        nMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">for</span> k, _ := <span class="keyword">range</span> cur &#123;</span><br><span class="line">            nMap2[k | arr[i]] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nMap2[arr[i]] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        cur = nMap2</span><br><span class="line">        <span class="keyword">for</span> k,_ := <span class="keyword">range</span> cur&#123;</span><br><span class="line">            nMap[k] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="48-旋转图像-中等"><a href="#48-旋转图像-中等" class="headerlink" title="48. 旋转图像[中等]"></a>48. 旋转图像[中等]</h3><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<p>给定 matrix &#x3D;<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>示例 2:</p>
<p>给定 matrix &#x3D;<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]<br>通过次数126,258提交次数176,813<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image">https://leetcode-cn.com/problems/rotate-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-107"><a href="#解法-107" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n / <span class="number">2</span>;i ++&#123;</span><br><span class="line">        matrix[i], matrix[n - <span class="number">1</span> -i] = matrix[n - <span class="number">1</span> - i], matrix[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j :=<span class="number">0</span>;j &lt; i;j ++&#123;</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i],matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="316-去除重复字母-中等"><a href="#316-去除重复字母-中等" class="headerlink" title="316. 去除重复字母[中等]"></a>316. 去除重复字母[中等]</h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p>
<p>注意：该题与 1081 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters">https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters</a> 相同</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “bcabc”<br>输出：”abc”<br>示例 2：</p>
<p>输入：s &#x3D; “cbacdcbc”<br>输出：”acdb”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 104<br>s 由小写英文字母组成<br>通过次数36,504提交次数79,575</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-letters">https://leetcode-cn.com/problems/remove-duplicate-letters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-108"><a href="#解法-108" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateLetters</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    left := [<span class="number">26</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">        left[ch-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    inStack := [<span class="number">26</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">        ch := s[i]</span><br><span class="line">        <span class="keyword">if</span> !inStack[ch-<span class="string">&#x27;a&#x27;</span>] &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; ch &lt; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] &#123;</span><br><span class="line">                last := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> left[last] == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">                inStack[last] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, ch)</span><br><span class="line">            inStack[ch-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        left[ch-<span class="string">&#x27;a&#x27;</span>]--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-58-II-左旋转字符串-简单"><a href="#剑指-Offer-58-II-左旋转字符串-简单" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串[简单]"></a>剑指 Offer 58 - II. 左旋转字符串[简单]</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s &#x3D; “lrloseumgh”, k &#x3D; 6<br>输出: “umghlrlose”
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000<br>通过次数93,490提交次数109,533</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-109"><a href="#解法-109" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    n %= l</span><br><span class="line">    <span class="keyword">return</span> s[n:] + s[:n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="523-连续的子数组和-中等"><a href="#523-连续的子数组和-中等" class="headerlink" title="523. 连续的子数组和[中等]"></a>523. 连续的子数组和[中等]</h3><p>给定一个包含 非负数 的数组和一个目标 整数 k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[23,2,4,6,7], k &#x3D; 6<br>输出：True<br>解释：[2,4] 是一个大小为 2 的子数组，并且和为 6。<br>示例 2：</p>
<p>输入：[23,2,6,4,7], k &#x3D; 6<br>输出：True<br>解释：[23,2,6,4,7]是大小为 5 的子数组，并且和为 42。
 </p>
<p>说明：</p>
<p>数组的长度不会超过 10,000 。<br>你可以认为所有数字总和在 32 位有符号整数范围内。<br>通过次数24,562提交次数109,066<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/continuous-subarray-sum">https://leetcode-cn.com/problems/continuous-subarray-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-110"><a href="#解法-110" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkSubarraySum</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// hash表 前缀和的余数，如果当前的前缀和和之前的某一次前缀和一致。</span></span><br><span class="line">    <span class="comment">// 说明从上次前缀和到现在前缀和之间的区间和为n*k。</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       sum += v</span><br><span class="line">       <span class="keyword">if</span> k != <span class="number">0</span> &#123;</span><br><span class="line">           sum = sum % k</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> value,ok := m[sum];ok &#123;</span><br><span class="line">           <span class="keyword">if</span> i - value &gt; <span class="number">1</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           m[sum] = i</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="135-分发糖果-困难"><a href="#135-分发糖果-困难" class="headerlink" title="135. 分发糖果[困难]"></a>135. 分发糖果[困难]</h3><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p>示例 1:</p>
<p>输入: [1,0,2]<br>输出: 5<br>解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。<br>示例 2:</p>
<p>输入: [1,2,2]<br>输出: 4<br>解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。<br>通过次数52,554提交次数110,962<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy">https://leetcode-cn.com/problems/candy</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-111"><a href="#解法-111" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">candy</span><span class="params">(ratings []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    d := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; n;i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> ratings[i - <span class="number">1</span>] &gt; ratings[i] &#123;</span><br><span class="line">            d[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d[i - <span class="number">1</span>] &lt;= <span class="number">1</span> &#123;</span><br><span class="line">                d[i - <span class="number">1</span>] ++</span><br><span class="line">                <span class="keyword">for</span> j := i - <span class="number">1</span>;j - <span class="number">1</span> &gt;= <span class="number">0</span>;j -- &#123;</span><br><span class="line">                    <span class="keyword">if</span> ratings[j - <span class="number">1</span>] &gt; ratings[j] &#123;</span><br><span class="line">                        <span class="keyword">if</span> d[j - <span class="number">1</span>] &lt; d[j] + <span class="number">1</span> &#123;</span><br><span class="line">                            <span class="comment">// 回溯的时候只有小于才变更，</span></span><br><span class="line">                            d[j - <span class="number">1</span>] = d[j] + <span class="number">1</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ratings[i - <span class="number">1</span>] &lt; ratings[i]&#123;</span><br><span class="line">            d[i] = d[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            d[i] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fmt.Println(d)</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> d &#123;</span><br><span class="line">        ans += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1046-最后一块石头的重量-简单"><a href="#1046-最后一块石头的重量-简单" class="headerlink" title="1046. 最后一块石头的重量[简单]"></a>1046. 最后一块石头的重量[简单]</h3><p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>
<p>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；<br>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>
<p> </p>
<p>示例：</p>
<p>输入：[2,7,4,1,8,1]<br>输出：1<br>解释：<br>先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，<br>再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，<br>接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，<br>最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; stones.length &lt;&#x3D; 30<br>1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000<br>通过次数46,177提交次数70,535</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/last-stone-weight">https://leetcode-cn.com/problems/last-stone-weight</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-112"><a href="#解法-112" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeight</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stones) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    temp := stones</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(temp) &gt;= <span class="number">2</span> &#123;</span><br><span class="line">        sort.Slice(temp, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> temp[i] &gt;= temp[j]</span><br><span class="line">        &#125;)</span><br><span class="line">        temp = <span class="built_in">append</span>([]<span class="type">int</span>&#123;temp[<span class="number">0</span>] - temp[<span class="number">1</span>]&#125;, temp[<span class="number">2</span>:]...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="977-有序数组的平方-简单"><a href="#977-有序数组的平方-简单" class="headerlink" title="977. 有序数组的平方[简单]"></a>977. 有序数组的平方[简单]</h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]<br>示例 2：</p>
<p>输入：nums &#x3D; [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 非递减顺序 排序
 </p>
<p>进阶：</p>
<p>请你设计时间复杂度为 O(n) 的算法解决本问题<br>通过次数91,837提交次数125,028</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">https://leetcode-cn.com/problems/squares-of-a-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-113"><a href="#解法-113" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedSquares</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// O(n)算法</span></span><br><span class="line">    n1 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    n2 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">            n1 = <span class="built_in">append</span>(n1, v * v)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            n2 = <span class="built_in">append</span>(n2, v * v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    i,j := <span class="built_in">len</span>(n1) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> || j &lt;= <span class="built_in">len</span>(n2) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="built_in">len</span>(n2) <span class="number">-1</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> n1[i] &gt; n2[j] &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, n2[j])</span><br><span class="line">                j ++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, n1[i])</span><br><span class="line">                i --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="built_in">len</span>(n2) &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, n1[i])</span><br><span class="line">            i --</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i &lt; <span class="number">0</span> &amp;&amp; j &lt;= <span class="built_in">len</span>(n2) <span class="number">-1</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, n2[j])</span><br><span class="line">            j ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="830-较大分组的位置-简单"><a href="#830-较大分组的位置-简单" class="headerlink" title="830. 较大分组的位置[简单]"></a>830. 较大分组的位置[简单]</h3><p>在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。</p>
<p>例如，在字符串 s &#x3D; “abbxxxxzyy” 中，就含有 “a”, “bb”, “xxxx”, “z” 和 “yy” 这样的一些分组。</p>
<p>分组可以用区间 [start, end] 表示，其中 start 和 end 分别表示该分组的起始和终止位置的下标。上例中的 “xxxx” 分组用区间表示为 [3,6] 。</p>
<p>我们称所有包含大于或等于三个连续字符的分组为 较大分组 。</p>
<p>找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abbxxxxzzy”<br>输出：[[3,6]]<br>解释：”xxxx” 是一个起始于 3 且终止于 6 的较大分组。<br>示例 2：</p>
<p>输入：s &#x3D; “abc”<br>输出：[]<br>解释：”a”,”b” 和 “c” 均不是符合要求的较大分组。<br>示例 3：</p>
<p>输入：s &#x3D; “abcdddeeeeaabbbcd”<br>输出：[[3,5],[6,9],[12,14]]<br>解释：较大分组为 “ddd”, “eeee” 和 “bbb”<br>示例 4：</p>
<p>输入：s &#x3D; “aba”<br>输出：[]<br> <br>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅含小写英文字母</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/positions-of-large-groups">https://leetcode-cn.com/problems/positions-of-large-groups</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-114"><a href="#解法-114" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largeGroupPositions</span><span class="params">(s <span class="type">string</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 大于等于3的</span></span><br><span class="line">    ans := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    preValue := <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    preIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            preValue = v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> preValue != v &#123;</span><br><span class="line">            <span class="keyword">if</span> i - preIndex &gt;= <span class="number">3</span> &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;preIndex, i - <span class="number">1</span>&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            preValue = v</span><br><span class="line">            preIndex = i</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &gt;= <span class="built_in">len</span>(s) &amp;&amp; i - preIndex &gt;= <span class="number">2</span> &#123;</span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;preIndex, i&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1018-可被-5-整除的二进制前缀-简单"><a href="#1018-可被-5-整除的二进制前缀-简单" class="headerlink" title="1018. 可被 5 整除的二进制前缀[简单]"></a>1018. 可被 5 整除的二进制前缀[简单]</h3><p>给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p>
<p>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[0,1,1]<br>输出：[true,false,false]<br>解释：<br>输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。<br>示例 2：</p>
<p>输入：[1,1,1]<br>输出：[false,false,false]<br>示例 3：</p>
<p>输入：[0,1,1,1,1,1]<br>输出：[true,false,false,false,true,false]<br>示例 4：</p>
<p>输入：[1,1,1,0,1]<br>输出：[false,false,false,false,false]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &lt;&#x3D; 30000<br>A[i] 为 0 或 1<br>通过次数33,869提交次数65,889</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5">https://leetcode-cn.com/problems/binary-prefix-divisible-by-5</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-115"><a href="#解法-115" class="headerlink" title="解法"></a>解法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">prefixesDivBy5</span><span class="params">(A []<span class="type">int</span>)</span> []<span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 能整除5就归零</span></span><br><span class="line">    ans := make([]<span class="type">bool</span>, len(A))</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(A);i ++ &#123;</span><br><span class="line">        sum = ((sum &lt;&lt; <span class="number">1</span>) | A[i])</span><br><span class="line">        <span class="keyword">if</span> sum % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            ans[i] = <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 减小数据量</span></span><br><span class="line">            sum = sum % <span class="number">5</span></span><br><span class="line">            ans[i] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1004-最大连续1的个数-III-中等"><a href="#1004-最大连续1的个数-III-中等" class="headerlink" title="1004. 最大连续1的个数 III[中等]"></a>1004. 最大连续1的个数 III[中等]</h2><p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：A &#x3D; [1,1,1,0,0,0,1,1,1,1,0], K &#x3D; 2<br>输出：6<br>解释：<br>[1,1,1,0,0,1,1,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 6。<br>示例 2：</p>
<p>输入：A &#x3D; [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K &#x3D; 3<br>输出：10<br>解释：<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>粗体数字从 0 翻转到 1，最长的子数组长度为 10。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &lt;&#x3D; 20000<br>0 &lt;&#x3D; K &lt;&#x3D; A.length<br>A[i] 为 0 或 1 </p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii">https://leetcode-cn.com/problems/max-consecutive-ones-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="解法-116"><a href="#解法-116" class="headerlink" title="解法"></a>解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(A []<span class="type">int</span>, K <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 翻转k个字符,算出最长的数据,</span></span><br><span class="line">    <span class="comment">// 从左到右数数,碰见0用1填,填够了就退出</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    remain := K</span><br><span class="line">    start,end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(A); i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] == <span class="number">1</span> &#123;</span><br><span class="line">            end ++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> remain &gt; <span class="number">0</span> &#123;</span><br><span class="line">                remain --</span><br><span class="line">                end ++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 没有能填充的了,就只能把前面的不断收缩,碰见0就归还</span></span><br><span class="line">                <span class="keyword">if</span> A[start] == <span class="number">0</span> &#123;</span><br><span class="line">                    remain ++</span><br><span class="line">                &#125;</span><br><span class="line">                start ++</span><br><span class="line">                i --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> end - start &gt; ans &#123;</span><br><span class="line">            ans = end - start</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="766-托普利茨矩阵-简单"><a href="#766-托普利茨矩阵-简单" class="headerlink" title="766. 托普利茨矩阵[简单]"></a>766. 托普利茨矩阵[简单]</h2><p>给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。</p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 托普利茨矩阵 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br>输出：true<br>解释：<br>在上述矩阵中, 其对角线为:<br>“[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”。<br>各条对角线上的所有元素均相同, 因此答案是 True 。<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2],[2,2]]<br>输出：false<br>解释：<br>对角线 “[1, 2]” 上的元素不同。
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 20<br>0 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 99
 </p>
<p>进阶：</p>
<p>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？<br>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？<br>通过次数43,372提交次数61,387</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/toeplitz-matrix">https://leetcode-cn.com/problems/toeplitz-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isToeplitzMatrix</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一列，第一行</span></span><br><span class="line">    row := <span class="built_in">len</span>(matrix)</span><br><span class="line">    </span><br><span class="line">    column := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.先算第一列,第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; row;j ++ &#123;</span><br><span class="line">        stand := matrix[j][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>;j + i &lt; row &amp;&amp; i &lt; column;i ++&#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[j + i][i] != stand &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.再算第一行</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; column;i ++ &#123;</span><br><span class="line">        stand := matrix[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; row &amp;&amp; i + j &lt; column;j ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> matrix[j][i + j] != stand &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1052-爱生气的书店老板-中等"><a href="#1052-爱生气的书店老板-中等" class="headerlink" title="1052. 爱生气的书店老板[中等]"></a>1052. 爱生气的书店老板[中等]</h2><p>今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] &#x3D; 1，否则 grumpy[i] &#x3D; 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。
 </p>
<p>示例：</p>
<p>输入：customers &#x3D; [1,0,1,2,1,1,7,5], grumpy &#x3D; [0,1,0,1,0,1,0,1], X &#x3D; 3<br>输出：16<br>解释：<br>书店老板在最后 3 分钟保持冷静。<br>感到满意的最大客户数量 &#x3D; 1 + 1 + 1 + 1 + 7 + 5 &#x3D; 16.
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; X &lt;&#x3D; customers.length &#x3D;&#x3D; grumpy.length &lt;&#x3D; 20000<br>0 &lt;&#x3D; customers[i] &lt;&#x3D; 1000<br>0 &lt;&#x3D; grumpy[i] &lt;&#x3D; 1<br>通过次数32,682提交次数56,341</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/grumpy-bookstore-owner">https://leetcode-cn.com/problems/grumpy-bookstore-owner</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-1"><a href="#solution-1" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSatisfied</span><span class="params">(customers []<span class="type">int</span>, grumpy []<span class="type">int</span>, X <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 生气为1,不生气为0</span></span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 先算不生气时满意的</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="built_in">len</span>(grumpy);i ++ &#123;</span><br><span class="line">        ans += customers[i] *(<span class="number">1</span> - grumpy[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 滑动窗口算生气消除的</span></span><br><span class="line">    wnd := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; X;i ++ &#123;</span><br><span class="line">        wnd += grumpy[i] * customers[i]</span><br><span class="line">    &#125;</span><br><span class="line">    maxwnd := wnd</span><br><span class="line">    <span class="comment">// 开始向后滑动算最大值</span></span><br><span class="line">    <span class="keyword">for</span> i := X;i &lt; <span class="built_in">len</span>(grumpy);i ++ &#123;</span><br><span class="line">        <span class="comment">// 进来的是生气的 + customers[i]</span></span><br><span class="line">        <span class="comment">// 出去的是生气的 - customers[i - X]</span></span><br><span class="line">        wnd += customers[i] * grumpy[i]</span><br><span class="line">        wnd -= customers[i - X] * grumpy[i - X]</span><br><span class="line">        <span class="keyword">if</span> wnd &gt; maxwnd &#123;</span><br><span class="line">            maxwnd = wnd</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + maxwnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="395-至少有K个重复字符的最长子串-中等"><a href="#395-至少有K个重复字符的最长子串-中等" class="headerlink" title="395. 至少有K个重复字符的最长子串[中等]"></a>395. 至少有K个重复字符的最长子串[中等]</h2><p>找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。</p>
<p>示例 1:</p>
<p>输入:<br>s &#x3D; “aaabb”, k &#x3D; 3</p>
<p>输出:<br>3</p>
<p>最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。<br>示例 2:</p>
<p>输入:<br>s &#x3D; “ababbc”, k &#x3D; 2</p>
<p>输出:<br>5</p>
<p>最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。<br>通过次数18,939提交次数41,163</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-2"><a href="#solution-2" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestSubstring</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 相同字母的 数量 &gt;= k,返回最长子串</span></span><br><span class="line">    letterNumber := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line">    lenght := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; lenght;i ++ &#123;</span><br><span class="line">        letterNumber[s[i] - <span class="string">&#x27;a&#x27;</span>] ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查当前字符串是否满足条件</span></span><br><span class="line">    status := <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; lenght;i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> letterNumber[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k &#123;</span><br><span class="line">            status = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 满足条件就退出</span></span><br><span class="line">    <span class="keyword">if</span> status &#123;</span><br><span class="line">        <span class="keyword">return</span> lenght</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不满足条件需要，分割字符串，按不满足的条件的字母做分割点</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    tmp := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; lenght;i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> letterNumber[s[i] - <span class="string">&#x27;a&#x27;</span>] &lt; k &#123;</span><br><span class="line">            tmp = longestSubstring(s[start : i], k)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; ans &#123;</span><br><span class="line">                ans = tmp</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 切割指针偏移</span></span><br><span class="line">            start = i + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切割完成,如果还有剩下的也去判断</span></span><br><span class="line">    tmp = longestSubstring(s[start:], k)</span><br><span class="line">    <span class="keyword">if</span> tmp &gt; ans &#123;</span><br><span class="line">        ans = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="翻转图像"><a href="#翻转图像" class="headerlink" title="翻转图像"></a>翻转图像</h2><p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p>
<p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[[1,1,0],[1,0,1],[0,0,0]]<br>输出：[[1,0,0],[0,1,0],[1,1,1]]<br>解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]<br>示例 2：</p>
<p>输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &#x3D; A[0].length &lt;&#x3D; 20<br>0 &lt;&#x3D; A[i][j] &lt;&#x3D; 1<br>通过次数71,692提交次数90,217</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flipping-an-image">https://leetcode-cn.com/problems/flipping-an-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="翻转图像-1"><a href="#翻转图像-1" class="headerlink" title="翻转图像"></a>翻转图像</h2><p>给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。</p>
<p>反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[[1,1,0],[1,0,1],[0,0,0]]<br>输出：[[1,0,0],[0,1,0],[1,1,1]]<br>解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；<br>     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]<br>示例 2：</p>
<p>输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]<br>输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]<br>解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；<br>     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &#x3D; A[0].length &lt;&#x3D; 20<br>0 &lt;&#x3D; A[i][j] &lt;&#x3D; 1<br>通过次数71,692提交次数90,217</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flipping-an-image">https://leetcode-cn.com/problems/flipping-an-image</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-3"><a href="#solution-3" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flipAndInvertImage</span><span class="params">(A [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 翻转并反转</span></span><br><span class="line">    row := <span class="built_in">len</span>(A)</span><br><span class="line">    column := <span class="built_in">len</span>(A[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; row;i ++ &#123;</span><br><span class="line">        start, end := <span class="number">0</span>, column - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> start &lt;= end &#123;</span><br><span class="line">            tmp := A[i][start]</span><br><span class="line">            A[i][start] = <span class="number">1</span> - A[i][end]</span><br><span class="line">            A[i][end] = <span class="number">1</span> - tmp</span><br><span class="line">            start ++</span><br><span class="line">            end --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1178-猜字谜"><a href="#1178-猜字谜" class="headerlink" title="1178. 猜字谜"></a>1178. 猜字谜</h2><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p>
<p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p>
<p>单词 word 中包含谜面 puzzle 的第一个字母。<br>单词 word 中的每一个字母都可以在谜面 puzzle 中找到。<br>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p>
<p> </p>
<p>示例：</p>
<p>输入：<br>words &#x3D; [“aaaa”,”asas”,”able”,”ability”,”actt”,”actor”,”access”],<br>puzzles &#x3D; [“aboveyz”,”abrodyz”,”abslute”,”absoryz”,”actresz”,”gaswxyz”]<br>输出：[1,1,3,2,4,0]<br>解释：<br>1 个单词可以作为 “aboveyz” 的谜底 : “aaaa”<br>1 个单词可以作为 “abrodyz” 的谜底 : “aaaa”<br>3 个单词可以作为 “abslute” 的谜底 : “aaaa”, “asas”, “able”<br>2 个单词可以作为 “absoryz” 的谜底 : “aaaa”, “asas”<br>4 个单词可以作为 “actresz” 的谜底 : “aaaa”, “asas”, “actt”, “access”<br>没有单词可以作为 “gaswxyz” 的谜底，因为列表中的单词都不含字母 ‘g’。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; words.length &lt;&#x3D; 10^5<br>4 &lt;&#x3D; words[i].length &lt;&#x3D; 50<br>1 &lt;&#x3D; puzzles.length &lt;&#x3D; 10^4<br>puzzles[i].length &#x3D;&#x3D; 7<br>words[i][j], puzzles[i][j] 都是小写英文字母。<br>每个 puzzles[i] 所包含的字符都不重复。<br>通过次数11,961提交次数28,439</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle">https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-4"><a href="#solution-4" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumOfValidWords</span><span class="params">(words []<span class="type">string</span>, puzzles []<span class="type">string</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 单词 word 中包含谜面 puzzle 的第一个字母。</span></span><br><span class="line">    <span class="comment">// 即 puzzle 第一个字母可以在word中找到 word[i] | 1 &lt;&lt; puzzle[i][0] = word[i]</span></span><br><span class="line">    <span class="comment">// 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。</span></span><br><span class="line">    <span class="comment">// =&gt; word[i] | puzzle[i] = puzzle[i]</span></span><br><span class="line">    <span class="comment">// =&gt; words[i] | puzzles[i] = puzzles[i]</span></span><br><span class="line">    <span class="comment">// 26bit-&gt;有为1,没有为0</span></span><br><span class="line">    <span class="comment">// 32位整数可以存储下编码</span></span><br><span class="line">    wLen := <span class="built_in">len</span>(words)</span><br><span class="line">    <span class="comment">// 算编码,建立hash表</span></span><br><span class="line">    <span class="comment">// &#x27;a&#x27;--&gt;list[,,,,,]</span></span><br><span class="line">    wMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>][]<span class="type">int32</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; wLen; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> wCodec <span class="type">int32</span></span><br><span class="line">        keys := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">26</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(words[i]);j ++ &#123;</span><br><span class="line">            wCodec |= (<span class="number">1</span> &lt;&lt; (words[i][j] - <span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">            keys[words[i][j] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给这个Codec绑定Hash</span></span><br><span class="line">        <span class="keyword">for</span> k := <span class="number">0</span>;k &lt; <span class="number">26</span>;k ++ &#123;</span><br><span class="line">            <span class="keyword">if</span> keys[k] == <span class="number">1</span> &#123;</span><br><span class="line">                wMap[<span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span> + k)] = <span class="built_in">append</span>(wMap[<span class="type">byte</span>(<span class="string">&#x27;a&#x27;</span> + k)], wCodec)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pLen := <span class="built_in">len</span>(puzzles)</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, pLen)</span><br><span class="line">    <span class="comment">// 为每个puzzle寻找word数量</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; pLen;i ++ &#123;</span><br><span class="line">        <span class="keyword">var</span> pCode <span class="type">int32</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(puzzles[i]);j ++ &#123;</span><br><span class="line">            pCode |= (<span class="number">1</span> &lt;&lt; (puzzles[i][j] -<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        list,ok := wMap[puzzles[i][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            ans[i] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            listSize := <span class="built_in">len</span>(list)</span><br><span class="line">            <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; listSize;j ++ &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[j] | pCode) == pCode &#123;</span><br><span class="line">                    ans[i] ++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="896-单调数列-easy"><a href="#896-单调数列-easy" class="headerlink" title="896. 单调数列[easy]"></a>896. 单调数列[easy]</h2><p>如果数组是单调递增或单调递减的，那么它是单调的。</p>
<p>如果对于所有 i &lt;&#x3D; j，A[i] &lt;&#x3D; A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;&#x3D; j，A[i]&gt; &#x3D; A[j]，那么数组 A 是单调递减的。</p>
<p>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[1,2,2,3]<br>输出：true<br>示例 2：</p>
<p>输入：[6,5,4,4]<br>输出：true<br>示例 3：</p>
<p>输入：[1,3,2]<br>输出：false<br>示例 4：</p>
<p>输入：[1,2,4,5]<br>输出：true<br>示例 5：</p>
<p>输入：[1,1,1]<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; A.length &lt;&#x3D; 50000<br>-100000 &lt;&#x3D; A[i] &lt;&#x3D; 100000</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/monotonic-array">https://leetcode-cn.com/problems/monotonic-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-5"><a href="#solution-5" class="headerlink" title="solution"></a>solution</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMonotonic</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 单增或单减,让后面的减前面的，全部小于等于0，单减。全部大于等于0，单增</span></span><br><span class="line">    nType := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="built_in">len</span>(A) <span class="number">-1</span> ;i &gt; <span class="number">0</span>;i -- &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] - A[i - <span class="number">1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nType == <span class="number">0</span> &#123;</span><br><span class="line">                nType = <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> nType == <span class="number">-1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> A[i] - A[i - <span class="number">1</span>] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nType == <span class="number">0</span> &#123;</span><br><span class="line">                nType = <span class="number">-1</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> nType == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="面试题-17-18-最短超串-中等"><a href="#面试题-17-18-最短超串-中等" class="headerlink" title="面试题 17.18. 最短超串[中等]"></a>面试题 17.18. 最短超串[中等]</h2><p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<p>示例 1:</p>
<p>输入:<br>big &#x3D; [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]<br>small &#x3D; [1,5,9]<br>输出: [7,10]<br>示例 2:</p>
<p>输入:<br>big &#x3D; [1,2,3]<br>small &#x3D; [4]<br>输出: []<br>提示：</p>
<p>big.length &lt;&#x3D; 100000<br>1 &lt;&#x3D; small.length &lt;&#x3D; 100000<br>通过次数4,545提交次数10,344</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-supersequence-lcci">https://leetcode-cn.com/problems/shortest-supersequence-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="solution-6"><a href="#solution-6" class="headerlink" title="solution"></a>solution</h3><p>滑动窗口只要想清楚怎么进,怎么出就行了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checksub</span><span class="params">(bMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, sMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> sMap &#123;</span><br><span class="line">        <span class="keyword">if</span> bv,ok := bMap[k];!ok || bv &lt; v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shortestSeq</span><span class="params">(big []<span class="type">int</span>, small []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(big) &lt; <span class="built_in">len</span>(small) &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> small&#123;</span><br><span class="line">        sMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    windowMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    sLen := <span class="built_in">len</span>(small)</span><br><span class="line">    bLen := <span class="built_in">len</span>(big)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; sLen;i ++ &#123;</span><br><span class="line">        windowMap[big[i]] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行处理</span></span><br><span class="line">    <span class="comment">// results := make(map[int]int)</span></span><br><span class="line">    start := <span class="number">0</span></span><br><span class="line">    finded := <span class="literal">false</span></span><br><span class="line">    shortestFirstIndex,shortestLastIndex := <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> checksub(windowMap, sMap) &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">0</span>, sLen - <span class="number">1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := sLen;i &lt;= bLen;i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> checksub(windowMap, sMap) &#123;</span><br><span class="line">            <span class="keyword">for</span> k := start;k &lt; start + sLen;k ++&#123;</span><br><span class="line">                <span class="keyword">if</span> !checksub(windowMap, sMap) &#123;</span><br><span class="line">                    <span class="comment">// tmp := start - 1</span></span><br><span class="line">                    <span class="comment">// results[tmp] = i - 1</span></span><br><span class="line">                    <span class="keyword">if</span> shortestFirstIndex == <span class="number">-1</span> &#123;</span><br><span class="line">                        finded = <span class="literal">true</span></span><br><span class="line">                        shortestFirstIndex = start - <span class="number">1</span></span><br><span class="line">                        shortestLastIndex = i - <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span>) - (start - <span class="number">1</span>) &lt; shortestLastIndex - shortestFirstIndex &#123;</span><br><span class="line">                        shortestFirstIndex = start - <span class="number">1</span></span><br><span class="line">                        shortestLastIndex = i - <span class="number">1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                v, _ := windowMap[big[start]]</span><br><span class="line">                <span class="keyword">if</span> v &gt; <span class="number">1</span> &#123;</span><br><span class="line">                    windowMap[big[start]] -= <span class="number">1</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">delete</span>(windowMap, big[start])</span><br><span class="line">                &#125;</span><br><span class="line">                start ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; bLen&#123;</span><br><span class="line">            windowMap[big[i]] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !finded &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 选最短的</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;shortestFirstIndex, shortestLastIndex&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="338-比特位计数-m"><a href="#338-比特位计数-m" class="headerlink" title="338. 比特位计数[m]"></a>338. 比特位计数[m]</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p>示例 1:</p>
<p>输入: 2<br>输出: [0,1,1]<br>示例 2:</p>
<p>输入: 5<br>输出: [0,1,1,2,1,2]<br>进阶:</p>
<p>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。<br>通过次数107,862提交次数136,687</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits">https://leetcode-cn.com/problems/counting-bits</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="solution-7"><a href="#solution-7" class="headerlink" title="solution"></a>solution</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBits</span><span class="params">(num <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>, num + <span class="number">1</span>)</span><br><span class="line">    ans[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt;= num;i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            ans[i] = ans[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i] = ans[i / <span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1006-笨阶乘-m"><a href="#1006-笨阶乘-m" class="headerlink" title="1006. 笨阶乘[m]"></a>1006. 笨阶乘[m]</h4><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) &#x3D; 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</p>
<p>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(&#x2F;)，加法(+)和减法(-)。</p>
<p>例如，clumsy(10) &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>
<p>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 &#x2F; 8 等于 11。这保证结果是一个整数。</p>
<p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：4<br>输出：7<br>解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1<br>示例 2：</p>
<p>输入：10<br>输出：12<br>解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clumsy-factorial">https://leetcode-cn.com/problems/clumsy-factorial</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="solution-8"><a href="#solution-8" class="headerlink" title="solution"></a>solution</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clumsy</span><span class="params">(N <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 先算乘除,后算加减</span></span><br><span class="line">    <span class="comment">// 0, 1, 2, 3</span></span><br><span class="line">    op := <span class="built_in">make</span>([]<span class="type">int</span>, N / <span class="number">2</span>)</span><br><span class="line">    op_top := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    current_op := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    num := <span class="built_in">make</span>([]<span class="type">int</span>, N)</span><br><span class="line">    num_top := <span class="number">0</span></span><br><span class="line">    num[num_top] = N</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := N - <span class="number">1</span>; i &gt;= <span class="number">1</span> ; i -- &#123;</span><br><span class="line">        num_top ++</span><br><span class="line">        num[num_top] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current_op == <span class="number">2</span> || current_op == <span class="number">3</span> &#123;</span><br><span class="line">            op_top ++</span><br><span class="line">            op[op_top] = current_op</span><br><span class="line">            current_op = (current_op + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> current_op == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 乘法</span></span><br><span class="line">            tmp := num[num_top] * num[num_top - <span class="number">1</span>]</span><br><span class="line">            num_top --</span><br><span class="line">            num[num_top] = tmp</span><br><span class="line">            current_op = (current_op + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> current_op == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// 除法</span></span><br><span class="line">            tmp := num[num_top - <span class="number">1</span>] / num[num_top]</span><br><span class="line">            num_top --</span><br><span class="line">            num[num_top] = tmp</span><br><span class="line">            current_op = (current_op + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理加减</span></span><br><span class="line">    last := <span class="number">1</span></span><br><span class="line">    result := num[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;= op_top;i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> op[i] == <span class="number">2</span> &#123;</span><br><span class="line">            result += num[last]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> op[i] == <span class="number">3</span> &#123;</span><br><span class="line">            result -= num[last]</span><br><span class="line">        &#125;</span><br><span class="line">        last ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-17-21-直方图的水量-h"><a href="#面试题-17-21-直方图的水量-h" class="headerlink" title="面试题 17.21. 直方图的水量[h]"></a>面试题 17.21. 直方图的水量[h]</h3><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p>
<p>示例:</p>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6<br>通过次数29,968提交次数47,826</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/volume-of-histogram-lcci">https://leetcode-cn.com/problems/volume-of-histogram-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="solution-9"><a href="#solution-9" class="headerlink" title="solution"></a>solution</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    size := <span class="built_in">len</span>(height)</span><br><span class="line">    leftMax := <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line">    rightMax := <span class="built_in">make</span>([]<span class="type">int</span>, size)</span><br><span class="line">    <span class="comment">// 左端最大值阶梯</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            leftMax[i] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            leftMax[i] = height[i - <span class="number">1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> height[i - <span class="number">1</span>] &gt; leftMax[i - <span class="number">1</span>] &#123;</span><br><span class="line">                leftMax[i] = height[i - <span class="number">1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                leftMax[i] = leftMax[i - <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右端最大值阶梯</span></span><br><span class="line">    <span class="keyword">for</span> i := size - <span class="number">1</span>; i &gt;= <span class="number">0</span>;i -- &#123;</span><br><span class="line">        <span class="keyword">if</span> i == size - <span class="number">1</span> &#123;</span><br><span class="line">            rightMax[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i == size - <span class="number">2</span>&#123;</span><br><span class="line">            rightMax[i] = height[i + <span class="number">1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> height[i + <span class="number">1</span>] &gt; rightMax[i + <span class="number">1</span>] &#123;</span><br><span class="line">                rightMax[i] = height[i + <span class="number">1</span>]</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                rightMax[i] = rightMax[i + <span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算头顶的水,左右大过自己,从大的选小的减去自己</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt; size - <span class="number">1</span>;i ++ &#123;</span><br><span class="line">        minTop := min(leftMax[i], rightMax[i])</span><br><span class="line">        <span class="keyword">if</span> minTop &gt; height[i] &#123;</span><br><span class="line">            result += (minTop - height[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="丑数-e"><a href="#丑数-e" class="headerlink" title="丑数[e]"></a>丑数[e]</h3><p>给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。</p>
<p>丑数 就是只包含质因数 2、3 和&#x2F;或 5 的正整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 6<br>输出：true<br>解释：6 &#x3D; 2 × 3<br>示例 2：</p>
<p>输入：n &#x3D; 8<br>输出：true<br>解释：8 &#x3D; 2 × 2 × 2<br>示例 3：</p>
<p>输入：n &#x3D; 14<br>输出：false<br>解释：14 不是丑数，因为它包含了另外一个质因数 7 。<br>示例 4：</p>
<p>输入：n &#x3D; 1<br>输出：true<br>解释：1 通常被视为丑数。
 </p>
<p>提示：</p>
<p>-231 &lt;&#x3D; n &lt;&#x3D; 231 - 1<br>通过次数81,651提交次数159,582</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ugly-number">https://leetcode-cn.com/problems/ugly-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="solution-10"><a href="#solution-10" class="headerlink" title="solution"></a>solution</h4><p>只能2&#x2F;3&#x2F;5去除尽,理论上n &#x3D; 2^i + 3^j + 5^k。除尽之后只剩下1,剩下别的数说明是假的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factors = []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isUgly</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> factors &#123;</span><br><span class="line">        <span class="keyword">for</span> n%f == <span class="number">0</span> &#123;</span><br><span class="line">            n /= f</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://long95288.github.io/2019/08/11/基础算法2/%20风兮木落%20基础算法2"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/08/14/UML%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99/" title="UML文档编写"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: UML文档编写</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/08/11/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="基础算法">Next post: 基础算法&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>