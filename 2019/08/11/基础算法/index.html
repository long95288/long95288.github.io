<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>基础算法 · 风兮木落</title><meta name="description" content="递归实现累加和累乘1、实现n+(n-1)+(n-2)+..3+2+1最佳办法是使用等差求和公式:n(n+1)&amp;#x2F;2
12345678910111213141516/*** 递归实现累加*/public static int accumulate(int n)&amp;#123;    if(n &amp;l"><meta name="og:description" content="递归实现累加和累乘1、实现n+(n-1)+(n-2)+..3+2+1最佳办法是使用等差求和公式:n(n+1)&amp;#x2F;2
12345678910111213141516/*** 递归实现累加*/public static int accumulate(int n)&amp;#123;    if(n &amp;l"><meta name="twitter:site" content="风兮木落"><meta name="twitter:title" content="基础算法"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">long blogs</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">进一步有进一步惊喜</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://long95288.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>基础算法</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-08-11</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/算法/" title="算法">算法</a><span>&nbsp;</span></span></p><p class="post-abstract"><h4 id="递归实现累加和累乘"><a href="#递归实现累加和累乘" class="headerlink" title="递归实现累加和累乘"></a>递归实现累加和累乘</h4><p>1、实现n+(n-1)+(n-2)+..3+2+1<br>最佳办法是使用等差求和公式:n(n+1)&#x2F;2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 递归实现累加</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">accumulate</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 递归异常</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 递归出口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归的函数体</span></span><br><span class="line">        <span class="keyword">return</span> n + Solution.accumulate(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、实现n!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 递归实现阶乘</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * Solution.factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><h4 id="关键路径算法"><a href="#关键路径算法" class="headerlink" title="关键路径算法"></a>关键路径算法</h4><h5 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h5><ul>
<li>节点最早开始时间,做这项最早开工干活。可以开工干活的前提是该工序之前的全部节点(工序)已经全部完成，如果是汇聚节点。需要选择消耗时间最大的那个。因为花费时间最多的工序完成了，则花费时间少的就很不用管了(并行)。<br>使用<code>Tes(i)</code>标记为该节点i的最早开始时间。计算公式为<br><code>Tes(i)=max&#123;Tes(i) + T(i,j)&#125;,i=1,2,3...k</code></li>
<li>节点的最迟结束时间。<br>最迟结束时间是为了保证该节点后面的工作能够按时完成，这个工序晚点的话依赖这个工序的可能会晚点。<br>使用<code>Tlf(j)</code>标记该节点的最迟结束时间。公式为<br><code>Tlf(i) = min&#123;Tlf(j) - T(i,j)&#125;,j=1,2,3....n</code><br>计算的时候从后面逆序计算。因为结束时间已经知道了。<ul>
<li>节点时差 <code>S(i) = Tlf(i) - Tes(i)</code></li>
<li>关键路径。节点时差为0的节点联结起来算为关键路径。因为这个节点不能最早开始时间和最迟结束时间是没有时间差的。关键路径上的工序为关键工序，关键工序作业时间之和就是工程的完工总工期。</li>
</ul>
</li>
</ul>
<h4 id="辗转相除法求最大公因子"><a href="#辗转相除法求最大公因子" class="headerlink" title="辗转相除法求最大公因子"></a>辗转相除法求最大公因子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   int hfc(int m,int n)</span><br><span class="line">&#123;</span><br><span class="line">	int r=1;</span><br><span class="line">	r = m % n;</span><br><span class="line">	while(r!=0)&#123;</span><br><span class="line">		if(r==1)&#123;</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		m=n;</span><br><span class="line">		n=r;</span><br><span class="line">		r=m % n;</span><br><span class="line">	&#125;</span><br><span class="line">	return n;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h5 id="优化版的辗转相除法"><a href="#优化版的辗转相除法" class="headerlink" title="优化版的辗转相除法"></a>优化版的辗转相除法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int hfc(int m,int n)</span><br><span class="line">   &#123;</span><br><span class="line">       int r =1;</span><br><span class="line">       r = m % n;</span><br><span class="line">       while ( r != 0)</span><br><span class="line">       &#123;</span><br><span class="line">           m = n;</span><br><span class="line">           n = r;</span><br><span class="line">           r = m % n;</span><br><span class="line">       &#125;</span><br><span class="line">       return n;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h4><p>题目描述:<br>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。<br>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a></p>
<h5 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h5><p>由于两个数组都是有序的,则可以使用类似于归并排序的思想。从后往前合并数组，每次选择从两个数组中选取其中最大的合并到nums1的尾部。<br>边界处理:<br>1、nums1值为空,将nums2复制到nums1中。<br>2、nums2为空,不做任何处理</p>
<h5 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> m + n -<span class="number">1</span>;</span><br><span class="line">        -- m;</span><br><span class="line">        -- n;</span><br><span class="line">        <span class="comment">// 归并排序的思想</span></span><br><span class="line">        <span class="keyword">while</span>(m &gt;=<span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[m] &gt; nums2[n])&#123;</span><br><span class="line">                nums1[point] = nums1[m];</span><br><span class="line">                -- point;</span><br><span class="line">                -- m;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[point] = nums2[n];</span><br><span class="line">                -- point;</span><br><span class="line">                -- n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( n &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">            nums1[point] = nums2[n];</span><br><span class="line">            -- point;</span><br><span class="line">            -- n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="大神的题解"><a href="#大神的题解" class="headerlink" title="大神的题解"></a>大神的题解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[p--] = nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="两数之和-中等"><a href="#两数之和-中等" class="headerlink" title="两数之和[中等]"></a>两数之和[中等]</h4><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 &#x3D; 807</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a></p>
<h5 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    p,q,flag := l1,l2,&amp;ListNode&#123;Val: <span class="number">0</span>&#125;</span><br><span class="line">    current := flag</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> || q != <span class="literal">nil</span> &#123;</span><br><span class="line">        x := <span class="number">0</span></span><br><span class="line">        y := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            x = p.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">            y = q.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相加,上一步的进位也要加上</span></span><br><span class="line">        sum := carry + x + y</span><br><span class="line">        <span class="comment">// 重新计算进位</span></span><br><span class="line">        carry = sum/<span class="number">10</span></span><br><span class="line">        <span class="comment">// 创建新的节点,节点里面放的是相加之后的个位数</span></span><br><span class="line">        <span class="comment">// current.Next里面可能已经有值了，但是不管.直接覆盖</span></span><br><span class="line">        current.Next = &amp;ListNode&#123;Val: sum%<span class="number">10</span>&#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span>&#123;</span><br><span class="line">            p = p.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">            q = q.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有进位的话会往前创建一个node,如果后面还有数据的话这个节点会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> carry &gt;<span class="number">0</span>  &#123;</span><br><span class="line">            current.Next = &amp;ListNode&#123;Val: carry&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>使用一个值为0的node来作为输出的头部节点头(哑节点)。<br>将两个输入的链表虚拟为相同的长度，如果有一条链表已经到达末尾了,该链表的下一个值用0替代。对应节点相加,创建一个新的节点放置相加后数据的个位数。如果有进位，添加新的节点来放置进位数据。放置进位的数据节点会被后面相加的数据的个位数替换。其实是丢掉进位节点，将链表的Next指针指向新生成的节点。使用current指针用于连接新的生成的数据。使用哑节点来放置链表的头部。这样返回的时候，只需要返回哑节点的Next指针便是相加后的数据。其中比较难理解的是current这个变量。<br>current只是放置Node指针的，最开始的时候current指向的哑节点。<br><code>current.Next = &amp;ListNode&#123;&#125;</code>真正连接的是哑节点的Next。<br><code>current= current.Next</code>current指针现在指向的是新生成的数据。current本身不具备真正的node。都是其它的Node通过current来代理操作的。<br>进位处理:</p>
<ul>
<li>进位创建新的Node.<br>当前还不知道后面是否还有数据，先创个Node节点放置数据。如果后面没有数据了,返回便可。如果后面还有数据,该节点被丢弃了。</li>
<li>生成的数据<br><code>[0(flag)]-&gt;[7]-&gt;[0]-&gt;[8]</code></li>
</ul>
<h4 id="83-删除排序链表中的重复元素-简单题"><a href="#83-删除排序链表中的重复元素-简单题" class="headerlink" title="83. 删除排序链表中的重复元素[简单题]"></a>83. 删除排序链表中的重复元素[简单题]</h4><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>删除链表中的节点,当两个节点一致时，删除后面的节点。只要知道对链表的节点进行删除便可以做出来
</code></pre>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &amp;&amp; cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Val == cur.Next.Val &#123;</span><br><span class="line">            <span class="comment">// 删除重复节点</span></span><br><span class="line">            <span class="comment">// 跳过下一个节点</span></span><br><span class="line">            cur.Next = cur.Next.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不相同到下一个</span></span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二、递归"><a href="#方法二、递归" class="headerlink" title="方法二、递归"></a>方法二、递归</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates2</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归条件</span></span><br><span class="line">    head.Next = deleteDuplicates2(head.Next)</span><br><span class="line">    <span class="keyword">if</span> head.Val == head.Next.Val &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="203-移除链表元素-简单"><a href="#203-移除链表元素-简单" class="headerlink" title="203. 移除链表元素[简单]"></a>203. 移除链表元素[简单]</h4><p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements">https://leetcode-cn.com/problems/remove-linked-list-elements</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="官方解法-1"><a href="#官方解法-1" class="headerlink" title="官方解法"></a>官方解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElements</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">   flag := &amp;ListNode&#123;Val:<span class="number">0</span>&#125;</span><br><span class="line">   flag.Next = head</span><br><span class="line">   <span class="comment">// 前置</span></span><br><span class="line">   prev,cur := flag,head</span><br><span class="line">   <span class="keyword">for</span> cur != <span class="literal">nil</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> cur.Val == val &#123;</span><br><span class="line">           <span class="comment">// 删除节点</span></span><br><span class="line">           prev.Next = cur.Next</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// 不相等,往前进发</span></span><br><span class="line">           prev = cur</span><br><span class="line">       &#125;</span><br><span class="line">       cur = cur.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> flag.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析"></a>解法分析</h5><p>思路:相同就删除链表中的节点，不相同就跳到下一个,但是如果头节点相同的话如何返回链表？<br>官方使用的方法是使用哨兵节点，列表作为哨兵节点的next值。通过使用哨兵节点就可以解决链表无头问题。</p>
<h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h4><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png"><br>示例 1：<br>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png"><br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png"></p>
<h5 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h5><p>使用map存储节点地址，如果后续的节点地址已经存在map中，说明已经回来了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    cur := head</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">interface</span>&#123;&#125;,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[cur];ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[cur] = <span class="literal">nil</span></span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快慢指针解法"><a href="#快慢指针解法" class="headerlink" title="快慢指针解法"></a>快慢指针解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow,fast := head,head.Next</span><br><span class="line">    <span class="keyword">for</span> slow != fast &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种快慢跑,fast节点比slow节点跑得快，如果有环的话后面会和跑得慢的相撞。1000m赛跑，跑得快的会再一圈之后相遇。</p>
<h5 id="奇葩解法"><a href="#奇葩解法" class="headerlink" title="奇葩解法"></a>奇葩解法</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type head: ListNode</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.val == <span class="string">&#x27;bjfuvth&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head.val = <span class="string">&#x27;bjfuvth&#x27;</span></span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h5 id="进阶，如果需要返回相交节点"><a href="#进阶，如果需要返回相交节点" class="headerlink" title="进阶，如果需要返回相交节点"></a>进阶，如果需要返回相交节点</h5><ul>
<li>使用map需要返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    cur := head</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">interface</span>&#123;&#125;,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[cur];ok &#123;</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        &#125;</span><br><span class="line">        m[cur] = <span class="literal">nil</span></span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用快慢指针<br>需要计算出相遇的时候里相交点的距离,相遇点离相交点的距离&#x3D;原点离相交点的距离。<br>假设O点为起始点,P点为环状相交点,Q点为快慢指针相遇的地方<br>OP &#x3D; x<br>PQ &#x3D; Y<br>QP &#x3D; Z<br>慢指针前进的距离:OP + PQ &#x3D; X + Y<br>快指针前进的距离:OP + PQ + QP + PQ &#x3D; X + 2Y + Z<br>由于快指针前进的距离是慢指针的两倍,所以<br>2(X + Y) &#x3D; X + 2Y + Z<br>整理得:X &#x3D; Z<br>说明OP &#x3D; QP<br>这时候从O点再次出发,步长和慢指针一致,他们便是在P点相遇。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            -&gt;----[Y]--&gt; </span><br><span class="line">           |            |</span><br><span class="line">O.---[x]---P            |</span><br><span class="line">           |            |</span><br><span class="line">            &lt;----[Z]-Q--</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow,fast := head,head</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> fast == <span class="literal">nil</span> || fast.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相遇了,一个C从开始点出发,再相遇的点是相交点</span></span><br><span class="line">    <span class="keyword">for</span> cur := head; cur!=<span class="literal">nil</span>;&#123;</span><br><span class="line">        <span class="keyword">if</span> slow == cur &#123;</span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="160-相交链表-简单"><a href="#160-相交链表-简单" class="headerlink" title="160. 相交链表[简单]"></a>160. 相交链表[简单]</h4><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><br>在节点 c1 开始相交。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png"></p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Reference of the node with value &#x3D; 8<br>输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p>
<p>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png"></p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Reference of the node with value &#x3D; 2<br>输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p>
<p>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png"></p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>解释：这两个链表不相交，因此返回 null。</p>
<p>注意：</p>
<p>如果两个链表没有交点，返回 null.<br>在返回结果后，两个链表仍须保持原有的结构。<br>可假定整个链表结构中没有循环。<br>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。<br>通过次数135,078提交次数241,320</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">https://leetcode-cn.com/problems/intersection-of-two-linked-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法1-map"><a href="#解法1-map" class="headerlink" title="解法1 map"></a>解法1 map</h5><p>使用map存储节点，第一遍先遍历A,将数据写入map中。然后遍历B,如果B的某个节点在map中,返回这个节点值。如果到尾巴了都没有，说明不相交。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[*ListNode]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> headA == <span class="literal">nil</span> || headB == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur := headA</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        m[cur] = <span class="literal">true</span></span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历B的时候,判断</span></span><br><span class="line">    cur = headB</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := m[cur];ok&#123;</span><br><span class="line">            <span class="keyword">return</span> cur</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法2-暴力法"><a href="#解法2-暴力法" class="headerlink" title="解法2 暴力法"></a>解法2 暴力法</h5><p>两个for循环判断</p>
<h5 id="解法3-双指针法"><a href="#解法3-双指针法" class="headerlink" title="解法3 双指针法"></a>解法3 双指针法</h5><p>相交:<br>len(A+B) &#x3D;&#x3D; len(B+A)<br>两个指针会在相遇的地方碰面</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> headA == <span class="literal">nil</span> || headB == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    pA,pB := headA,headB</span><br><span class="line">    <span class="comment">//如果两个链表相交: A+B = B+A,两个指针走的路程都是一样的,会在汇合处相遇</span></span><br><span class="line">    <span class="comment">//不相交：最后都会变成nil,退出</span></span><br><span class="line">    <span class="comment">// 退出的条件为相等,要么找到相同节点,要么都为nil</span></span><br><span class="line">    <span class="keyword">for</span> pA != pB &#123;</span><br><span class="line">        <span class="keyword">if</span> pA == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 到达尾巴了,从B链表开始</span></span><br><span class="line">            pA = headB</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">            pA = pA.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同理</span></span><br><span class="line">        <span class="keyword">if</span> pB == <span class="literal">nil</span> &#123;</span><br><span class="line">            pB = headA</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pB = pB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果p</span></span><br><span class="line">    <span class="keyword">return</span> pA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h4><p>给定一个带有头结点 head 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.<br>示例 2：</p>
<p>输入：[1,2,3,4,5,6]<br>输出：此列表中的结点 4 (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</p>
<p>提示：</p>
<p>给定链表的结点数介于 1 和 100 之间。<br>通过次数69,843提交次数100,768</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list">https://leetcode-cn.com/problems/middle-of-the-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="方法一-数组"><a href="#方法一-数组" class="headerlink" title="方法一 数组"></a>方法一 数组</h5><p>数组,遍历链表,将数据放入数组中。结束后取出下表为n&#x2F;2的节点。</p>
<h5 id="方法二-单指针法"><a href="#方法二-单指针法" class="headerlink" title="方法二 单指针法"></a>方法二 单指针法</h5><ul>
<li>第一遍跑,记下长度。</li>
<li>第二遍跑一半，返回节点。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        length ++</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">if</span> length % <span class="number">2</span> == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="comment">// 偶数 = (length+2)/2</span></span><br><span class="line">        length = (length + <span class="number">2</span>)/<span class="number">2</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 奇数 = (length+1)/2</span></span><br><span class="line">        length = (length + <span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ;length&gt;<span class="number">1</span>;length-- &#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        length ++</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> length = length/<span class="number">2</span> + <span class="number">1</span>;length&gt;<span class="number">1</span>;length-- &#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法三-快慢指针"><a href="#解法三-快慢指针" class="headerlink" title="解法三 快慢指针"></a>解法三 快慢指针</h5><p>每次快指针比慢指针多走一步，当快指针到终点之后。慢指针走到中间位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    slow,fast := head,head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="754-到达终点数字"><a href="#754-到达终点数字" class="headerlink" title="754. 到达终点数字"></a>754. 到达终点数字</h4><p>在一根无限长的数轴上，你站在0的位置。终点在target的位置。</p>
<p>每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。</p>
<p>返回到达终点需要的最小移动次数。</p>
<p>示例 1:</p>
<p>输入: target &#x3D; 3<br>输出: 2<br>解释:<br>第一次移动，从 0 到 1 。<br>第二次移动，从 1 到 3 。<br>示例 2:</p>
<p>输入: target &#x3D; 2<br>输出: 3<br>解释:<br>第一次移动，从 0 到 1 。<br>第二次移动，从 1 到 -1 。<br>第三次移动，从 -1 到 2 。<br>注意:</p>
<p>target是在[-10^9, 10^9]范围中的非零整数。<br>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reach-a-number">https://leetcode-cn.com/problems/reach-a-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>规律<br>1 &#x3D; 1<br>2 &#x3D; 1 - 2 + 3 (1+2+3)&#x3D;6 6-2&#x3D;4 4&#x2F;2 &#x3D; 2<br>3 &#x3D; 1 + 2<br>4 &#x3D; -1 + 2 + 3 (1+2+3)&#x3D;6 6-4&#x3D;2 2&#x2F;2 &#x3D; 1<br>5 &#x3D; 1 + 2 + 3 + 4 - 5 sum&#x3D;15 15-5&#x3D;10 10&#x2F;2&#x3D; 5</p>
<p>对于target来所,正负不会影响走的步数。所以只考虑正数的便可。<br>对于累加和来说,其中第n为数转为-n。相应的数值变为 sum - 2n。<br>为什么是2n,如果不加第n位时,sum -n 。第n位变为负数时又-n。所以，第n位数变为负数时，累加和为全是正数的累加和-2n。即第一次满足条件: target &#x3D; sum -2n即为走的步数。整理得<br>满足:<code>sum - target = 2n</code>时,找到步数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reachNumber</span><span class="params">(target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> target &lt; <span class="number">0</span> &#123;</span><br><span class="line">        target = -target</span><br><span class="line">    &#125; </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sum = sum + i</span><br><span class="line">        <span class="keyword">if</span> sum == target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - target) %<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a>1144. 递减元素使数组呈锯齿状</h4><p>给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。</p>
<p>如果符合下列情况之一，则数组 A 就是 锯齿数组：</p>
<p>每个偶数索引对应的元素都大于相邻的元素，即 A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; …<br>或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …<br>返回将数组 nums 转换为锯齿数组所需的最小操作次数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：2<br>解释：我们可以把 2 递减到 0，或把 3 递减到 1。<br>示例 2：</p>
<p>输入：nums &#x3D; [9,6,1,6,2]<br>输出：4</p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 1000<br>通过次数6,990提交次数16,349</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decrease-elements-to-make-array-zigzag">https://leetcode-cn.com/problems/decrease-elements-to-make-array-zigzag</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>要么1,3,5,7….奇数位为高峰。要么2,4,6,8,….偶数位为高峰。只要分别计算出步数,返回步数小的情况就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MovesToMakeZigzag</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    锯齿状数据,只能递减,每次减1。步数最少。</span></span><br><span class="line"><span class="comment">    奇数位先减,操作的步数。</span></span><br><span class="line"><span class="comment">    偶数位再减,操作的步数。</span></span><br><span class="line"><span class="comment">    比较那个走得少。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oddStep := <span class="number">0</span></span><br><span class="line">    eventStep := <span class="number">0</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment">// 奇位数先减 1,3,5,7</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt; length; i = i +<span class="number">2</span>&#123;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        <span class="comment">// 处在头部,只比较右边的数据</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i + <span class="number">1</span>] &gt; tmp &#123;</span><br><span class="line">                <span class="comment">// A &lt; B 高过，不用管</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// A &gt;= B,下拉</span></span><br><span class="line">                oddStep = oddStep + (tmp - nums[i+<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处在尾部</span></span><br><span class="line">        <span class="keyword">if</span> i == length <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// B &gt; C</span></span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; tmp &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// B &lt; C</span></span><br><span class="line">                oddStep = oddStep + (tmp - nums[i<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处在中间,比两边。低过最低的便可</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; i &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// 比较两边,</span></span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; tmp &amp;&amp; tmp &lt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// A &gt; C 低过右边便可</span></span><br><span class="line">                <span class="keyword">if</span> nums[i + <span class="number">1</span>] &gt; tmp &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    oddStep = oddStep + (tmp - nums[i+<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// A &lt; C 低过左边便可</span></span><br><span class="line">                <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; tmp &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    oddStep = oddStep + (tmp - nums[i<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 偶数位先减 2,4,6,8</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i &lt; length;i= i + <span class="number">2</span>&#123;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        <span class="comment">// 尾部</span></span><br><span class="line">        <span class="keyword">if</span> i == length <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// B &gt; C</span></span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; tmp &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// B &lt; C</span></span><br><span class="line">                eventStep = eventStep + (tmp - nums[i<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中间</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; i &lt; length<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// 比较两边,</span></span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; tmp &amp;&amp; tmp &lt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nums[i<span class="number">-1</span>] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">                <span class="comment">// A &gt; C 低过右边便可</span></span><br><span class="line">                <span class="keyword">if</span> nums[i + <span class="number">1</span>] &gt; tmp &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    eventStep = eventStep + (tmp - nums[i+<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// A &lt; C 低过左边便可</span></span><br><span class="line">                <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; tmp &#123;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    eventStep = eventStep + (tmp - nums[i<span class="number">-1</span>] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> oddStep &gt; eventStep &#123;</span><br><span class="line">        <span class="keyword">return</span> eventStep</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oddStep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表-简单"><a href="#206-反转链表-简单" class="headerlink" title="206. 反转链表[简单]"></a>206. 反转链表[简单]</h4><p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<h5 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">   <span class="keyword">var</span> tmp *ListNode = <span class="literal">nil</span></span><br><span class="line">   cur := head</span><br><span class="line">   <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">       tmpNode := &amp;ListNode&#123;</span><br><span class="line">           Val: cur.Val,</span><br><span class="line">       &#125;</span><br><span class="line">       tmpNode.Next = tmp</span><br><span class="line">       tmp = tmpNode</span><br><span class="line">       cur = cur.Next</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseList2</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp *ListNode = <span class="literal">nil</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmpNode := cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        <span class="comment">// 断开链表</span></span><br><span class="line">        tmpNode.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 重新连接</span></span><br><span class="line">        tmpNode.Next = tmp</span><br><span class="line">        tmp = tmpNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="234-回文链表-简单"><a href="#234-回文链表-简单" class="headerlink" title="234. 回文链表[简单]"></a>234. 回文链表[简单]</h4><p>请判断一个链表是否为回文链表。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2<br>输出: false<br>示例 2:</p>
<p>输入: 1-&gt;2-&gt;2-&gt;1<br>输出: true<br>进阶：<br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p>通过次数113,285提交次数264,021</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list">https://leetcode-cn.com/problems/palindrome-linked-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法一-复制链表，逆序比较"><a href="#解法一-复制链表，逆序比较" class="headerlink" title="解法一 复制链表，逆序比较"></a>解法一 复制链表，逆序比较</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 复制链表</span></span><br><span class="line">    cp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp = <span class="built_in">append</span>(cp,cur.Val)</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序比较</span></span><br><span class="line">    cur = head</span><br><span class="line">    index := <span class="built_in">len</span>(cp) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Val != cp[index] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        index --</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断链表是否是回文数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(head *ListNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 复制链表</span></span><br><span class="line">    cp := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        cp = <span class="built_in">append</span>(cp,cur.Val)</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序比较</span></span><br><span class="line">    cur = head</span><br><span class="line">    index := <span class="built_in">len</span>(cp) - <span class="number">1</span></span><br><span class="line">    index2 := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index != index2 &amp;&amp; index2 &lt; index &#123;</span><br><span class="line">        <span class="keyword">if</span> cp[index] != cp[index2] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        index --</span><br><span class="line">        index2 ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for cur != nil&#123;</span></span><br><span class="line">    <span class="comment">//    if cur.Val != cp[index] &#123;</span></span><br><span class="line">    <span class="comment">//        return false</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//    index --</span></span><br><span class="line">    <span class="comment">//    cur = cur.Next</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-快慢指针-翻转链表"><a href="#方法二-快慢指针-翻转链表" class="headerlink" title="方法二 快慢指针+翻转链表"></a>方法二 快慢指针+翻转链表</h5><p>待研究</p>
<h4 id="1290-二进制链表转整数-简单"><a href="#1290-二进制链表转整数-简单" class="headerlink" title="1290. 二进制链表转整数[简单]"></a>1290. 二进制链表转整数[简单]</h4><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<p> </p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png"><br>输入：head &#x3D; [1,0,1]<br>输出：5<br>解释：二进制数 (101) 转化为十进制数 (5)<br>示例 2：</p>
<p>输入：head &#x3D; [0]<br>输出：0<br>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：1<br>示例 4：</p>
<p>输入：head &#x3D; [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]<br>输出：18880<br>示例 5：</p>
<p>输入：head &#x3D; [0,0]<br>输出：0</p>
<p>提示：</p>
<p>链表不为空。<br>链表的结点总数不超过 30。<br>每个结点的值不是 0 就是 1。<br>通过次数25,976提交次数32,106</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer">https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>先将数据读取出来,获得长度。然后根据长度决定每个二进制位的base</p>
<h5 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h5><p>使用额外切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDecimalValue</span><span class="params">(head *ListNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 读出来再进制运算</span></span><br><span class="line">    arr := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        arr = <span class="built_in">append</span>(arr,cur.Val)</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进制运算</span></span><br><span class="line">    base := <span class="number">1</span> &lt;&lt; (<span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        result = result + v * base</span><br><span class="line">        base /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="版本二-不使用切片"><a href="#版本二-不使用切片" class="headerlink" title="版本二 不使用切片"></a>版本二 不使用切片</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDecimalValue</span><span class="params">(head *ListNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 读出来</span></span><br><span class="line">    cur := head</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        length ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按权重进行相加</span></span><br><span class="line">    length --</span><br><span class="line">    base := <span class="number">1</span> &lt;&lt; length</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> cur = head;cur!=<span class="literal">nil</span>;cur=cur.Next &#123;</span><br><span class="line">        result = result + cur.Val * base</span><br><span class="line">        base /= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-22-链表中倒数第k个节点-简单"><a href="#剑指-Offer-22-链表中倒数第k个节点-简单" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点[简单]"></a>剑指 Offer 22. 链表中倒数第k个节点[简单]</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.<br>返回链表 4-&gt;5.<br>通过次数56,304提交次数71,296</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h5><p>第一遍循环,寻找链表长度。得到截取的部分,再循环读取到对应的位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 第一遍算长度</span></span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> ;cur != <span class="literal">nil</span>;cur= cur.Next &#123;</span><br><span class="line">        length ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算前进步数</span></span><br><span class="line">    length = length - k</span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i &lt;=length; i++&#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二-双指针"><a href="#解法二-双指针" class="headerlink" title="解法二 双指针"></a>解法二 双指针</h5><p>快和慢指针。快指针先走k步,然后快慢指针一起走,快指针到末尾的时候,慢指针就是倒数第k个节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    fast,slow := head,head</span><br><span class="line">    <span class="keyword">for</span> i:=k;i&gt;<span class="number">0</span>;i--&#123;</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="面试题-02-01-移除重复节点-简单"><a href="#面试题-02-01-移除重复节点-简单" class="headerlink" title="面试题 02.01. 移除重复节点[简单]"></a>面试题 02.01. 移除重复节点[简单]</h4><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<p>示例1:</p>
<p> 输入：[1, 2, 3, 3, 2, 1]<br> 输出：[1, 2, 3]<br>示例2:</p>
<p> 输入：[1, 1, 1, 1, 2]<br> 输出：[1, 2]<br>提示：</p>
<p>链表长度在[0, 20000]范围内。<br>链表元素在[0, 20000]范围内。<br>进阶：</p>
<p>如果不得使用临时缓冲区，该怎么解决？</p>
<p>通过次数31,595提交次数44,947</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci">https://leetcode-cn.com/problems/remove-duplicate-node-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法一-2"><a href="#解法一-2" class="headerlink" title="解法一"></a>解法一</h5><p>建立一个set,如果后面的数据已经存在,则删除该节点。不存在加入set中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateNodes</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 向后读取,如果后面的数据和现在的一样,删除节点。不一样,指针前移</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    pre,cur := head,head.Next</span><br><span class="line">    <span class="comment">// 临时缓冲区</span></span><br><span class="line">    buf := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    buf[pre.Val] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := buf[cur.Val];ok &#123;</span><br><span class="line">            <span class="comment">// 相同,删除节点</span></span><br><span class="line">            cur = cur.Next</span><br><span class="line">            pre.Next = cur</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 不相同,继续</span></span><br><span class="line">            buf[cur.Val] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            pre = pre.Next</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-两重循环"><a href="#方法二-两重循环" class="headerlink" title="方法二 两重循环"></a>方法二 两重循环</h5><p>检查从当前节点开始，后面是否有重复的。如果有重复的,删除重复节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateNodes</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">   <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    pre,cur := head,head.Next</span><br><span class="line">    <span class="keyword">for</span> pre != <span class="literal">nil</span> &#123;</span><br><span class="line">        preTmp := pre</span><br><span class="line">        <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Val == pre.Val &#123;</span><br><span class="line">                cur = cur.Next</span><br><span class="line">                preTmp.Next = cur</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preTmp = preTmp.Next</span><br><span class="line">                cur = cur.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.Next</span><br><span class="line">        <span class="keyword">if</span> pre == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = pre.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化后</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicateNodes</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">   <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    index := head</span><br><span class="line">    <span class="keyword">for</span> index != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur := index</span><br><span class="line">        <span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cur.Next.Val == index.Val &#123;</span><br><span class="line">                <span class="comment">// 删除节点</span></span><br><span class="line">                cur.Next = cur.Next.Next</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index = index.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-06-从尾到头打印链表-简单"><a href="#剑指-Offer-06-从尾到头打印链表-简单" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表[简单]"></a>剑指 Offer 06. 从尾到头打印链表[简单]</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,3,2]<br>输出：[2,3,1]</p>
<p>限制：</p>
<p>0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</p>
<p>通过次数71,441提交次数93,952</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法一-3"><a href="#解法一-3" class="headerlink" title="解法一"></a>解法一</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cur := head;cur != <span class="literal">nil</span>;cur = cur.Next&#123;</span><br><span class="line">        arr = <span class="built_in">append</span>([]<span class="type">int</span>&#123;cur.Val&#125;,arr...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h5><p>减少append操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur != <span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        length ++</span><br><span class="line">    &#125;</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="type">int</span>,length)</span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        arr[length<span class="number">-1</span>] = cur.Val</span><br><span class="line">        length --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-18-删除链表的节点-简单"><a href="#剑指-Offer-18-删除链表的节点-简单" class="headerlink" title="剑指 Offer 18. 删除链表的节点[简单]"></a>剑指 Offer 18. 删除链表的节点[简单]</h4><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>注意：此题对比原题有改动</p>
<p>示例 1:</p>
<p>输入: head &#x3D; [4,5,1,9], val &#x3D; 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<br>示例 2:</p>
<p>输入: head &#x3D; [4,5,1,9], val &#x3D; 1<br>输出: [4,5,9]<br>解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</p>
<p>说明：</p>
<p>题目保证链表中节点的值互不相同<br>若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点<br>通过次数46,045提交次数78,179</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>判断下个节点是否和目标一致，如果一致，删除节点。如果第一个节点为待删除节点，需要提前解决。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理第一个节点为待删除节点</span></span><br><span class="line">     cur:=head</span><br><span class="line">    <span class="keyword">for</span>;cur !=<span class="literal">nil</span> &amp;&amp; cur.Val == val;&#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    head = cur</span><br><span class="line">    <span class="keyword">for</span> index:=head;index!=<span class="literal">nil</span> &amp;&amp; index.Next !=<span class="literal">nil</span> ;&#123;</span><br><span class="line">        <span class="keyword">if</span> index.Next.Val == val &#123;</span><br><span class="line">            index.Next = index.Next.Next</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index = index.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以解决重复数字删除</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[5,5,4,5,5,1,9]</span><br><span class="line">5</span><br><span class="line">输出</span><br><span class="line">[4,1,9]</span><br></pre></td></tr></table></figure>
<h4 id="面试题-02-03-删除中间节点-简单题"><a href="#面试题-02-03-删除中间节点-简单题" class="headerlink" title="面试题 02.03. 删除中间节点[简单题]"></a>面试题 02.03. 删除中间节点[简单题]</h4><p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<p>示例：</p>
<p>输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c<br>结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f<br>通过次数23,101提交次数27,295</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-middle-node-lcci">https://leetcode-cn.com/problems/delete-middle-node-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>入参为待删除的节点，这个问题是如何根据当前节点删除当前节点。<br>只要将后面的节点数据往前移一格，然后删除最后一个节点便可。</p>
<h5 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(node *ListNode)</span></span> &#123;</span><br><span class="line">    cur := node</span><br><span class="line">    <span class="keyword">for</span> cur.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Next.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 删除最后节点</span></span><br><span class="line">            cur.Val = cur.Next.Val</span><br><span class="line">            cur.Next = <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            cur.Val = cur.Next.Val</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-删除链表的倒数第N个节点-中等"><a href="#19-删除链表的倒数第N个节点-中等" class="headerlink" title="19. 删除链表的倒数第N个节点[中等]"></a>19. 删除链表的倒数第N个节点[中等]</h4><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：</p>
<p>给定的 n 保证是有效的。</p>
<p>进阶：</p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>通过次数210,641提交次数537,922</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="方法一-记录法"><a href="#方法一-记录法" class="headerlink" title="方法一 记录法"></a>方法一 记录法</h4><p>先跑一遍得出链表长度,根据倒数数得出顺数删除节点。删除便可.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur != <span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        length ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得出待删除节点所处的位置</span></span><br><span class="line">    length = length - n</span><br><span class="line">    <span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定位节点并删除</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> ;length &gt; <span class="number">1</span>;length--&#123;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    cur.Next = cur.Next.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法二-快慢指针"><a href="#方法二-快慢指针" class="headerlink" title="方法二 快慢指针"></a>方法二 快慢指针</h4><p>快慢指针,快指针比慢指针先走n+1。当快指针走完之后,如果慢指针还没走，说明删除第一个节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 快慢指针,快指针比慢指针先走n+1步.快指针到终点了慢指针就再到数第n为的前面,然后删除便可</span></span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow,fast := head,head</span><br><span class="line">    step := n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ;fast != <span class="literal">nil</span>;fast=fast.Next &#123;</span><br><span class="line">        <span class="keyword">if</span> step &gt; <span class="number">0</span> &#123;</span><br><span class="line">            step --  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            slow = slow.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快指针已经结束,但是还有剩余步数,说明删除的是第一个节点</span></span><br><span class="line">    <span class="keyword">if</span> step &gt; <span class="number">0</span> &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除前面的节点</span></span><br><span class="line">    slow.Next = slow.Next.Next</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="24-两两交换链表中的节点-中等"><a href="#24-两两交换链表中的节点-中等" class="headerlink" title="24. 两两交换链表中的节点[中等]"></a>24. 两两交换链表中的节点[中等]</h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p> </p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br>通过次数134,389提交次数202,662</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">https://leetcode-cn.com/problems/swap-nodes-in-pairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>使用哑节点构建新的链表头,新链表有个尾巴引用,用来连接新的节点,每次截取旧链表的相邻两位。注意节点需要完全断开。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 使用临时节点存放旧链表,节点短链重连</span></span><br><span class="line">    oldHead := head</span><br><span class="line">    newHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    newLinkCur := newHead</span><br><span class="line">    <span class="keyword">var</span> n1,n2 *ListNode = <span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> oldHead != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> oldHead.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 最后一个节点了,将这个节点加入新链表尾巴</span></span><br><span class="line">            newLinkCur.Next = oldHead</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理节点</span></span><br><span class="line">        n1,n2 = oldHead,oldHead.Next</span><br><span class="line">        <span class="comment">//newHead -&gt; n2-&gt; n1-&gt;</span></span><br><span class="line">        oldHead = oldHead.Next.Next</span><br><span class="line">        n1.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// n2 -&gt; n1</span></span><br><span class="line">        n2.Next = n1</span><br><span class="line">        <span class="comment">// tail-&gt; n2</span></span><br><span class="line">        newLinkCur.Next = n2</span><br><span class="line">        <span class="comment">// tail = n1</span></span><br><span class="line">        <span class="comment">// tail -&gt; n2-&gt;n1 -&gt;tail</span></span><br><span class="line">        newLinkCur = n1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapPairs</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 递归第一个出口</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    firstNode,secondNode := head,head.Next</span><br><span class="line">    firstNode.Next = swapPairs(secondNode.Next)</span><br><span class="line">    secondNode.Next = firstNode</span><br><span class="line">    <span class="keyword">return</span> secondNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="61-旋转链表-中等"><a href="#61-旋转链表-中等" class="headerlink" title="61. 旋转链表[中等]"></a>61. 旋转链表[中等]</h4><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>示例 2:</p>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL<br>通过次数76,849提交次数189,706</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list">https://leetcode-cn.com/problems/rotate-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-结环-切割"><a href="#思路-结环-切割" class="headerlink" title="思路 结环-切割"></a>思路 结环-切割</h5><p>链表结成一个环之后,向右旋转k,等价于head要后退k步。但是head只能往前,所以<br>对于环形链表来说,退k步&#x3D;进(length - k)步。<br>当k大于length时,说明循环一圈了,这一圈可以去掉。所以需要往前走(length - k%lenght)步即到切割点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotateRight</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 结环 -&gt; 割环</span></span><br><span class="line">    <span class="comment">// step = length - k%length</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    length := <span class="number">0</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 结环,获得长度</span></span><br><span class="line">            cur.Next = head</span><br><span class="line">            length ++</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur= cur.Next</span><br><span class="line">        length ++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算切割点</span></span><br><span class="line">    <span class="comment">// [1,2,3] 20000000 需要进行mod运算</span></span><br><span class="line">    step := length - k%length</span><br><span class="line">    <span class="comment">// 定位切割点</span></span><br><span class="line">    <span class="keyword">for</span> ;step &gt; <span class="number">1</span>;step-- &#123;</span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切割</span></span><br><span class="line">    tmp := head</span><br><span class="line">    head = head.Next</span><br><span class="line">    tmp.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="82-删除排序链表中的重复元素-II-中等"><a href="#82-删除排序链表中的重复元素-II-中等" class="headerlink" title="82. 删除排序链表中的重复元素 II[中等]"></a>82. 删除排序链表中的重复元素 II[中等]</h4><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3<br>通过次数59,058提交次数121,182</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法一-4"><a href="#解法一-4" class="headerlink" title="解法一"></a>解法一</h5><p>使用map存储每个节点值的个数。然后前探节点,如果该节点是重复节点,删除n次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">   <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> head</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// map</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> cur:=head;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        mp[cur.Val] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dump := &amp;ListNode&#123;&#125;</span><br><span class="line">    dump.Next = head</span><br><span class="line">    dup := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> cur := dump;cur!= <span class="literal">nil</span>&amp;&amp;cur.Next != <span class="literal">nil</span>;&#123;</span><br><span class="line">        <span class="comment">// 判断重复 值大于2</span></span><br><span class="line">        <span class="keyword">if</span> v,_ := mp[cur.Next.Val]; !dup &amp;&amp; v &gt; <span class="number">1</span> &#123;</span><br><span class="line">            dup = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除重复的节点</span></span><br><span class="line">        <span class="keyword">if</span> dup &#123;</span><br><span class="line">            <span class="keyword">if</span> v,_ := mp[cur.Next.Val];v &gt; <span class="number">0</span>&#123;</span><br><span class="line">                mp[cur.Next.Val] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> v,_ := mp[cur.Next.Val];v == <span class="number">0</span> &#123;</span><br><span class="line">                    dup = <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">                cur.Next = cur.Next.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dump.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="92-反转链表-II-中等"><a href="#92-反转链表-II-中等" class="headerlink" title="92. 反转链表 II[中等]"></a>92. 反转链表 II[中等]</h4><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL<br>通过次数66,376提交次数130,134</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>  先将待翻转的节点存到数组中,然后再根据下标反转将节点重新连接到链表中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m <span class="type">int</span>, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 先将待翻转的数据存下来,存完之后就翻转</span></span><br><span class="line">    <span class="comment">// 使用array存储</span></span><br><span class="line">    <span class="comment">// 哑节点</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    dummy.Next = head</span><br><span class="line">    pre,cur := dummy,head</span><br><span class="line">    arr := []*ListNode&#123;&#125;</span><br><span class="line">    sub := n - m</span><br><span class="line">    step := <span class="number">2</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> step == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="comment">// 分析阶段</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; m <span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">// 定位</span></span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.Next</span><br><span class="line">                i ++</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> i &gt;= m <span class="number">-1</span> &amp;&amp; i &lt;= n <span class="number">-1</span>&#123;</span><br><span class="line">                <span class="comment">// 赋值</span></span><br><span class="line">                arr = <span class="built_in">append</span>(arr,cur)</span><br><span class="line">                cur = cur.Next</span><br><span class="line">                i ++</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                step --</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> step == <span class="number">1</span>&#123;</span><br><span class="line">            <span class="comment">// 反转阶段</span></span><br><span class="line">            <span class="keyword">if</span> sub &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                tmp := arr[sub]</span><br><span class="line">                tmp.Next = <span class="literal">nil</span></span><br><span class="line">                pre.Next = tmp</span><br><span class="line">                pre = tmp</span><br><span class="line">                sub --</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 翻转完成,链表连接</span></span><br><span class="line">                pre.Next = cur</span><br><span class="line">                step --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="解法二-1"><a href="#解法二-1" class="headerlink" title="解法二"></a>解法二</h5><p>使用多指针,待翻转的部分建立成新的链表,新链表有自己的头节点和尾节点。当翻转完成之后再和哑节点形成的链表连接起来。</p>
<img src="/2019/08/11/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A82.png" class="">
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> head</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 使用多指针，边走边翻转</span></span><br><span class="line">   dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">   dummy.Next = head</span><br><span class="line">   <span class="comment">// 新生成链表的尾巴</span></span><br><span class="line">   dTail := dummy</span><br><span class="line">   <span class="comment">// 旧的数据</span></span><br><span class="line">   <span class="keyword">var</span> sHead *ListNode = <span class="literal">nil</span></span><br><span class="line">   <span class="keyword">var</span> sTail *ListNode = <span class="literal">nil</span></span><br><span class="line">   i := <span class="number">0</span></span><br><span class="line">   cur := head</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> i &lt; m <span class="number">-1</span> &#123;</span><br><span class="line">           dTail = cur</span><br><span class="line">           cur = cur.Next</span><br><span class="line">           i ++</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == m<span class="number">-1</span>&#123;</span><br><span class="line">           <span class="comment">// 切割点</span></span><br><span class="line">           sTail = cur</span><br><span class="line">           sHead = cur</span><br><span class="line">           cur = cur.Next</span><br><span class="line">           i ++</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> i &gt; m <span class="number">-1</span> &amp;&amp; i &lt;= n <span class="number">-1</span> &#123;</span><br><span class="line">           <span class="comment">// 翻转点</span></span><br><span class="line">           tmp := cur</span><br><span class="line">           cur = cur.Next</span><br><span class="line">           tmp.Next = sHead</span><br><span class="line">           sHead = tmp</span><br><span class="line">           i ++</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == n &#123;</span><br><span class="line">           <span class="comment">// 重新连接点</span></span><br><span class="line">           dTail.Next = sHead</span><br><span class="line">           sTail.Next = cur</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> dummy.Next</span><br></pre></td></tr></table></figure>
<h4 id="445-两数相加-II-中等"><a href="#445-两数相加-II-中等" class="headerlink" title="445. 两数相加 II[中等]"></a>445. 两数相加 II[中等]</h4><p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p> </p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p> </p>
<p>示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7<br>通过次数46,824提交次数80,888</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii">https://leetcode-cn.com/problems/add-two-numbers-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><p>翻转两个链表,使用两数相加的代码。然后再翻转回来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    <span class="keyword">var</span> nHead *ListNode = <span class="literal">nil</span></span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        tmpNode := cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        <span class="comment">// 断开链表</span></span><br><span class="line">        tmpNode.Next = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 重新连接</span></span><br><span class="line">        tmpNode.Next = nHead</span><br><span class="line">        nHead = tmpNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nHead</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 翻转链表,然后按照简单的方法做</span></span><br><span class="line">    l1 = reverseList(l1)</span><br><span class="line">    l2 = reverseList(l2)</span><br><span class="line">    p,q,flag := l1,l2,&amp;ListNode&#123;Val: <span class="number">0</span>&#125;</span><br><span class="line">    current := flag</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p != <span class="literal">nil</span> || q != <span class="literal">nil</span> &#123;</span><br><span class="line">        x := <span class="number">0</span></span><br><span class="line">        y := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">            x = p.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">            y = q.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 相加,上一步的进位也要加上</span></span><br><span class="line">        sum := carry + x + y</span><br><span class="line">        <span class="comment">// 重新计算进位</span></span><br><span class="line">        carry = sum/<span class="number">10</span></span><br><span class="line">        <span class="comment">// 创建新的节点,节点里面放的是相加之后的个位数</span></span><br><span class="line">        <span class="comment">// current.Next里面可能已经有值了，但是不管.直接覆盖</span></span><br><span class="line">        current.Next = &amp;ListNode&#123;Val: sum%<span class="number">10</span>&#125;</span><br><span class="line">        current = current.Next</span><br><span class="line">        <span class="keyword">if</span> p != <span class="literal">nil</span>&#123;</span><br><span class="line">            p = p.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">            q = q.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有进位的话会往前创建一个node,如果后面还有数据的话这个节点会被丢弃</span></span><br><span class="line">        <span class="keyword">if</span> carry &gt;<span class="number">0</span>  &#123;</span><br><span class="line">            current.Next = &amp;ListNode&#123;Val: carry&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reverseList(flag.Next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法二-入栈，出栈相加"><a href="#方法二-入栈，出栈相加" class="headerlink" title="方法二 入栈，出栈相加"></a>方法二 入栈，出栈相加</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    stack1 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    stack2 := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 数据入栈</span></span><br><span class="line">    <span class="keyword">for</span> cur:=l1;cur!= <span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        stack1 = <span class="built_in">append</span>(stack1,cur.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> cur:=l2;cur!=<span class="literal">nil</span>;cur=cur.Next&#123;</span><br><span class="line">        stack2 = <span class="built_in">append</span>(stack2,cur.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈相加</span></span><br><span class="line">    dummy := &amp;ListNode&#123;&#125;</span><br><span class="line">    top1,top2 := <span class="built_in">len</span>(stack1),<span class="built_in">len</span>(stack2)</span><br><span class="line">    carray := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> top1 &gt; <span class="number">0</span> || top2 &gt; <span class="number">0</span>&#123;</span><br><span class="line">        a,b := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> top1 == <span class="number">0</span> &#123;</span><br><span class="line">            a = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a = stack1[top1 - <span class="number">1</span>]</span><br><span class="line">            top1 --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> top2 == <span class="number">0</span> &#123;</span><br><span class="line">            b = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b = stack2[top2 <span class="number">-1</span>]</span><br><span class="line">            top2 --</span><br><span class="line">        &#125;</span><br><span class="line">        sum := a + b + carray</span><br><span class="line">        carray = sum / <span class="number">10</span></span><br><span class="line">        val := sum % <span class="number">10</span></span><br><span class="line">        node := &amp;ListNode&#123;</span><br><span class="line">            Val:val,</span><br><span class="line">            Next:<span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        node.Next = dummy.Next</span><br><span class="line">        dummy.Next = node</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carray &gt; <span class="number">0</span> &#123;</span><br><span class="line">        cNode := &amp;ListNode&#123;</span><br><span class="line">            Val:<span class="number">1</span>,</span><br><span class="line">            Next:<span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        cNode.Next = dummy.Next</span><br><span class="line">        dummy.Next = cNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="35-搜索插入位置-简单"><a href="#35-搜索插入位置-简单" class="headerlink" title="35. 搜索插入位置[简单]"></a>35. 搜索插入位置[简单]</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p>示例 1:</p>
<p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p>
<p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p>
<p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p>
<p>输入: [1,3,5,6], 0<br>输出: 0<br>通过次数225,858提交次数484,313</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; nums[<span class="number">0</span>]&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ;i &lt; <span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(nums)  &#123;</span><br><span class="line">            <span class="keyword">if</span> target &gt; nums[i] &amp;&amp; target &lt; nums[i + <span class="number">1</span>]&#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="面试题-10-01-合并排序的数组-简单"><a href="#面试题-10-01-合并排序的数组-简单" class="headerlink" title="面试题 10.01. 合并排序的数组[简单]"></a>面试题 10.01. 合并排序的数组[简单]</h4><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 m 和 n。</p>
<p>示例:</p>
<p>输入:<br>A &#x3D; [1,2,3,0,0,0], m &#x3D; 3<br>B &#x3D; [2,5,6],       n &#x3D; 3</p>
<p>输出: [1,2,2,3,5,6]<br>说明:</p>
<p>A.length &#x3D;&#x3D; n + m<br>通过次数30,098提交次数55,588</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sorted-merge-lcci">https://leetcode-cn.com/problems/sorted-merge-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>由于A数组能够放置B数组,也就是说A数组前面的数据不会被动到也可以放入。这样,将A前面的数据看作一个数组,和B数组做归并排序。每次从A和B中选择大的值放入A的末尾中,由于A,B有数据部分都是排序好的。所以，只要比较两个数组最后一位的大小便可。如果B中的值比A的都大,A数组也可以放得下。如果A的数据都比B大,A的数据都往后挪了m位,B数据覆盖A数组前段数据也无所谓。因为A有效数据已经全部挪完了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(A []<span class="type">int</span>, m <span class="type">int</span>, B []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 从后向前移动,每次寻找最大值填入A</span></span><br><span class="line">    index := m + n <span class="number">-1</span></span><br><span class="line">    m,n = m<span class="number">-1</span>,n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> m &gt;=<span class="number">0</span> || n &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> m &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// A已经选取结束了,把B放入便可</span></span><br><span class="line">            A[index] = B[n]</span><br><span class="line">            index --</span><br><span class="line">            n --</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">            A[index] = A[m]</span><br><span class="line">            index --</span><br><span class="line">            m --</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> A[m] &gt;= B[n] &#123;</span><br><span class="line">            A[index] = A[m]</span><br><span class="line">            m --</span><br><span class="line">            index --</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            A[index] = B[n]</span><br><span class="line">            n--</span><br><span class="line">            index --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="121-买卖股票的最佳时机-简单"><a href="#121-买卖股票的最佳时机-简单" class="headerlink" title="121. 买卖股票的最佳时机[简单]"></a>121. 买卖股票的最佳时机[简单]</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br>通过次数260,657提交次数476,342</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>由于只能进行一次买卖，并且只需要计算最大利润便可。使用一个变量存价格最低,使用一个变量存储价格最高。每天算一遍利润，反正前几天最低的数据我记得，今天的利润&#x3D;今天的价格-买入的最低价。如果可以多次买入卖出，需要动态规划的思想。但是只是一次买卖,走一遍，计算最高利润便可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 最低点买入,最高点卖出,由于只能进行一次买入和卖出,就计算看看,每天的情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span> || <span class="built_in">len</span>(prices) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    minPrice := prices[<span class="number">0</span>]</span><br><span class="line">    maxProfit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; minPrice &#123;</span><br><span class="line">            <span class="comment">// 今天的价格最低,今天买入吧</span></span><br><span class="line">            minPrice = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> prices[i] - minPrice &gt; maxProfit &#123;</span><br><span class="line">            <span class="comment">// 今天卖出比前一天好</span></span><br><span class="line">            maxProfit = prices[i] - minPrice</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="66-加一-简单"><a href="#66-加一-简单" class="headerlink" title="66. 加一[简单]"></a>66. 加一[简单]</h4><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。<br>示例 2:</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。<br>通过次数186,723提交次数414,952</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>加一,等价于之前的操作产生个进位1。将这个进位加到总数中,如果后面再有进位，开辟新的空间来存储进位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    carray := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(digits)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        sum := digits[i] + carray</span><br><span class="line">        carray = sum/<span class="number">10</span></span><br><span class="line">        digits[i] = sum % <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carray &gt; <span class="number">0</span> &#123;</span><br><span class="line">        digits = <span class="built_in">append</span>([]<span class="type">int</span>&#123;carray&#125;,digits...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="169-多数元素-简单"><a href="#169-多数元素-简单" class="headerlink" title="169. 多数元素[简单]"></a>169. 多数元素[简单]</h4><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [3,2,3]<br>输出: 3<br>示例 2:</p>
<p>输入: [2,2,1,1,1,2,2]<br>输出: 2<br>通过次数198,349提交次数308,875</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element">https://leetcode-cn.com/problems/majority-element</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路1-map"><a href="#思路1-map" class="headerlink" title="思路1 map"></a>思路1 map</h5><p>遍历一遍数组,将数据出现的次数写入map中。然后遍历map，找到大于一半的便可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    half := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        mp[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> mp &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; half &#123;</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="投票算法"><a href="#投票算法" class="headerlink" title="投票算法"></a>投票算法</h5><p>思路</p>
<p>如果我们把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。</p>
<p>算法</p>
<p>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p>
<p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>
<p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>
<p>如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>
<p>如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>
<p>在遍历完成后，candidate 即为整个数组的众数。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/">https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    candidate := <span class="number">0</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,k := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            candidate = k</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> k == candidate &#123;</span><br><span class="line">            count ++ </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对拼的思想,只要我占到一半以上,不管和谁对拼。场中最后剩下的一定是我的人。</p>
<h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h4><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<p>输入: 5<br>输出:<br>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]<br>通过次数97,040提交次数144,702</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle">https://leetcode-cn.com/problems/pascals-triangle</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>当前节点的值&#x3D; 上一组下标小于当前下标的值 + 上一组下标等于当前下标的值。<br>如果上一组的前一个节点下标小于0,则可以用0替代。上一组当前下标的数据已经越界，用零替代。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">   reNums := <span class="built_in">make</span>([][]<span class="type">int</span>,numRows)</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;numRows;i++&#123;</span><br><span class="line">       <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">           reNums[i] = []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           subNum := <span class="built_in">make</span>([]<span class="type">int</span>,i+<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">for</span> j:=<span class="number">0</span>;j &lt; i + <span class="number">1</span>;j++ &#123;</span><br><span class="line">                pre1,pre2 := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span> &lt;<span class="number">0</span> &#123;</span><br><span class="line">                    pre1 = <span class="number">0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre1 = reNums[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j &gt;= i &#123;</span><br><span class="line">                    pre2 = <span class="number">0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre2 = reNums[i<span class="number">-1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">                subNum[j] = pre1 + pre2</span><br><span class="line">           &#125;</span><br><span class="line">           reNums[i] = subNum</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reNums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h4><p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<p>输入: 3<br>输出: [1,3,3,1]<br>进阶：</p>
<p>你可以优化你的算法到 O(k) 空间复杂度吗？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle-ii">https://leetcode-cn.com/problems/pascals-triangle-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h5><p>使用上一种方式，返回第k-1行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">   numRows := rowIndex+<span class="number">1</span></span><br><span class="line">   reNums := <span class="built_in">make</span>([][]<span class="type">int</span>,numRows)</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;numRows;i++&#123;</span><br><span class="line">       <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">           reNums[i] = []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           subNum := <span class="built_in">make</span>([]<span class="type">int</span>,i+<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">for</span> j:=<span class="number">0</span>;j &lt; i + <span class="number">1</span>;j++ &#123;</span><br><span class="line">                pre1,pre2 := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> j<span class="number">-1</span> &lt;<span class="number">0</span> &#123;</span><br><span class="line">                    pre1 = <span class="number">0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre1 = reNums[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> j &gt;= i &#123;</span><br><span class="line">                    pre2 = <span class="number">0</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre2 = reNums[i<span class="number">-1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">                subNum[j] = pre1 + pre2</span><br><span class="line">           &#125;</span><br><span class="line">           reNums[i] = subNum</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> reNums[rowIndex]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>组合数学处理，</p>
<p><img src="https://pic.leetcode-cn.com/195de01eae91e09de14dd13daafbef986c42345f2bdef405153a1742175079f4.jpg" alt="img"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="type">int64</span>)</span></span> <span class="type">int64</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factorial(n<span class="number">-1</span>)*n</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combination</span><span class="params">(n1, m1 <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    n := <span class="type">int64</span>(n1)</span><br><span class="line">    m := <span class="type">int64</span>(m1)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> factorial(n)/(factorial(m)*factorial(n-m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 只要计算一半便可</span></span><br><span class="line">    half := rowIndex/<span class="number">2</span></span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>,rowIndex + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;=half;i++&#123;</span><br><span class="line">        nums[i] = <span class="type">int</span>(combination(rowIndex,i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:= half+<span class="number">1</span>;i &lt; rowIndex + <span class="number">1</span>;i++&#123;</span><br><span class="line">        nums[i] = nums[rowIndex - i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p>思路：只利用一个[]int，行数下移即在尾部添加元素1，然后倒序计算当前行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 第0行</span></span><br><span class="line">	nums := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= rowIndex; i++ &#123;</span><br><span class="line">		<span class="comment">// 尾部追加1</span></span><br><span class="line">		nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 倒序计算杨辉三角当前行</span></span><br><span class="line">		<span class="keyword">for</span> j:=i<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--&#123;</span><br><span class="line">			nums[j]+=nums[j<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line">作者：revelationofturing</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/pascals-triangle-ii/solution/zhi-xing-yong-shi-0-ms-zai-suo-you-golang-ti-jia-8/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>



<h4 id="283-移动零-简单"><a href="#283-移动零-简单" class="headerlink" title="283. 移动零[简单]"></a>283. 移动零[简单]</h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。<br>通过次数189,245提交次数305,606</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes">https://leetcode-cn.com/problems/move-zeroes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>双指针一起走,当碰到零的时候,一个指针继续往前走,另一个指针等待当前0值被覆盖。拿后面的值来填充前面的零值,被拿走的数据要归零。等价于替换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    cur,length := <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;length;i++&#123;</span><br><span class="line">       <span class="keyword">if</span> nums[i] != <span class="number">0</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> cur != i &#123;</span><br><span class="line">                nums[cur] = nums[i]</span><br><span class="line">                nums[i] = <span class="number">0</span></span><br><span class="line">                cur ++</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur ++</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="剑指-Offer-03-数组中重复的数字-简单"><a href="#剑指-Offer-03-数组中重复的数字-简单" class="headerlink" title="剑指 Offer 03. 数组中重复的数字[简单]"></a>剑指 Offer 03. 数组中重复的数字[简单]</h4><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p>
<p>限制：</p>
<p>2 &lt;&#x3D; n &lt;&#x3D; 100000</p>
<p>通过次数104,581提交次数154,607</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>使用一个set来存储出现的数字，如果当前的值在set中,说明重复了，返回当前��值。如果不存在，设置值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 使用map存储数据</span></span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := mp[v];ok&#123;</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="122-买卖股票的最佳时机-II-简单"><a href="#122-买卖股票的最佳时机-II-简单" class="headerlink" title="122. 买卖股票的最佳时机 II[简单]"></a>122. 买卖股票的最佳时机 II[简单]</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。<br>示例 2:</p>
<p>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。<br>     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br>示例 3:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 10 ^ 4<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 10 ^ 4</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>只要今天比昨天高,今天卖出可以获得利润。反正今天卖出之后,还可以再购买。每一个上升的区间进行交易我肯定是赚了。<br><img src="https://pic.leetcode-cn.com/6eaf01901108809ca5dfeaef75c9417d6b287c841065525083d1e2aac0ea1de4-file_1555699697692"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(prices);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i<span class="number">-1</span>] &lt; prices[i] &#123;</span><br><span class="line">            <span class="comment">// 今天相比昨天高了,卖出。</span></span><br><span class="line">            maxProfit = maxProfit + prices[i] -prices[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="167-两数之和-II-输入有序数组-简单"><a href="#167-两数之和-II-输入有序数组-简单" class="headerlink" title="167. 两数之和 II - 输入有序数组[简单]"></a>167. 两数之和 II - 输入有序数组[简单]</h4><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p>
<p>输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<br>通过次数145,662提交次数257,898</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>夹逼法,由于已经排序好了。元素越往后面越大,越往前面越小。所以使用两个index1,index2。分别从最小，最大。往中间夹逼。大了,右边的指针往左移一步就变小了。小了,左边的指针往右移变大。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(numbers []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 一个从头开始，一个从末尾开始。如果和大于target,末尾指针左移，减小和。如果和小于target,头指针往前，增大sum.</span></span><br><span class="line">    index1,index2 := <span class="number">0</span>,<span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> numbers[index1] + numbers[index2] != target &#123;</span><br><span class="line">        <span class="keyword">if</span> numbers[index1] + numbers[index2] == target &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> numbers[index1] + numbers[index2] &gt; target &#123;</span><br><span class="line">            index2 --</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index1 ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;index1+<span class="number">1</span>,index2+<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1013-将数组分成和相等的三个部分-简单"><a href="#1013-将数组分成和相等的三个部分-简单" class="headerlink" title="1013. 将数组分成和相等的三个部分[简单]"></a>1013. 将数组分成和相等的三个部分[简单]</h4><p>给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</p>
<p>形式上，如果可以找出索引 i+1 &lt; j 且满足 A[0] + A[1] + … + A[i] &#x3D;&#x3D; A[i+1] + A[i+2] + … + A[j-1] &#x3D;&#x3D; A[j] + A[j-1] + … + A[A.length - 1] 就可以将数组三等分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 &#x3D; -6 + 6 - 7 + 9 + 1 &#x3D; 2 + 0 + 1<br>示例 2：</p>
<p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：</p>
<p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 &#x3D; 6 &#x3D; 5 - 2 + 2 + 5 + 1 - 9 + 4</p>
<p>提示：</p>
<p>3 &lt;&#x3D; A.length &lt;&#x3D; 50000<br>-10^4 &lt;&#x3D; A[i] &lt;&#x3D; 10^4<br>通过次数36,611提交次数90,704</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>求和，然后计算1&#x2F;3的值。提供一个flag记录已经求和的次数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThreePartsEqualSum</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 先算出累加和的值,得到每个部分的值,然后再遍历一次数据进行分割</span></span><br><span class="line">    flag := <span class="number">3</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,a := <span class="keyword">range</span> A&#123;</span><br><span class="line">        sum += a</span><br><span class="line">    &#125;</span><br><span class="line">    threePart := sum / <span class="number">3</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,a := <span class="keyword">range</span> A&#123;</span><br><span class="line">        sum += a </span><br><span class="line">        <span class="keyword">if</span> sum == threePart &#123;</span><br><span class="line">            flag --</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="189-旋转数组-简单"><a href="#189-旋转数组-简单" class="headerlink" title="189. 旋转数组[简单]"></a>189. 旋转数组[简单]</h4><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,4,5,6,7] 和 k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右旋转 1 步: [7,1,2,3,4,5,6]<br>向右旋转 2 步: [6,7,1,2,3,4,5]<br>向右旋转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入: [-1,-100,3,99] 和 k &#x3D; 2<br>输出: [3,99,-1,-100]<br>解释:<br>向右旋转 1 步: [99,-1,-100,3]<br>向右旋转 2 步: [3,99,-1,-100]<br>说明:</p>
<p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。<br>要求使用空间复杂度为 O(1) 的 原地 算法。<br>通过次数151,757提交次数356,331</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array">https://leetcode-cn.com/problems/rotate-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h5><p>和旋转链表一样,将数组看成一个环状的。然后确定分割点<code>step := length - k%length</code></p>
<ul>
<li>未优化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 将数组想象成一个环，向右移动k步,等价于向后面移动length - k%length 步.这样可以确定分割点</span></span><br><span class="line">    step := <span class="built_in">len</span>(nums) - k%<span class="built_in">len</span>(nums)</span><br><span class="line">    nums1 := <span class="built_in">append</span>(nums[step:],nums[:step]...)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        nums[i] = nums1[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="官方解法-2"><a href="#官方解法-2" class="headerlink" title="官方解法"></a>官方解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(nums []<span class="type">int</span>, start <span class="type">int</span>, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> start &lt; end&#123;</span><br><span class="line">        tmp := nums[start]</span><br><span class="line">        nums[start] = nums[end]</span><br><span class="line">        nums[end] = tmp</span><br><span class="line">        start ++</span><br><span class="line">        end --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 先整体翻转,然后前k个数据翻转，然后再length - K个数据翻转</span></span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    k = k%length</span><br><span class="line">    <span class="comment">// 1.全部翻转</span></span><br><span class="line">    reverse(nums,<span class="number">0</span>,length<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 2.翻转前k个</span></span><br><span class="line">    reverse(nums,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">    <span class="comment">// 3.翻转后n-k个</span></span><br><span class="line">    reverse(nums,k,length<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="485-最大连续1的个数-简单"><a href="#485-最大连续1的个数-简单" class="headerlink" title="485. 最大连续1的个数[简单]"></a>485. 最大连续1的个数[简单]</h4><p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p>示例 1:</p>
<p>输入: [1,1,0,1,1,1]<br>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.<br>注意：</p>
<p>输入的数组只包含 0 和1。<br>输入数组的长度是正整数，且不超过 10,000。<br>通过次数47,908提交次数84,570</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones">https://leetcode-cn.com/problems/max-consecutive-ones</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h5><p>遍历一遍,如果当前是一，添加进临时变量中。判断临时变量是否大于最大的连续数,大于就赋值。如果当前值是0,临时变量变成零，从头开始数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    MaxCount := <span class="number">0</span></span><br><span class="line">    tmpCount := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">       <span class="keyword">if</span> num == <span class="number">1</span> &#123;</span><br><span class="line">           tmpCount ++</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> tmpCount &gt; MaxCount&#123;</span><br><span class="line">           MaxCount = tmpCount</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> num == <span class="number">0</span> &#123;</span><br><span class="line">           tmpCount = <span class="number">0</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxCount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="217-存在重复元素-简单"><a href="#217-存在重复元素-简单" class="headerlink" title="217. 存在重复元素[简单]"></a>217. 存在重复元素[简单]</h4><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: true<br>示例 2:</p>
<p>输入: [1,2,3,4]<br>输出: false<br>示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]<br>输出: true<br>通过次数158,982提交次数300,723</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate">https://leetcode-cn.com/problems/contains-duplicate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h5><p>构建set,如果当前数据在set中,说明第二次出现，说明重复了。不存在，添加进去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := mp[num];ok&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[num] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="219-存在重复元素-II-简单"><a href="#219-存在重复元素-II-简单" class="headerlink" title="219. 存在重复元素 II[简单]"></a>219. 存在重复元素 II[简单]</h4><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] &#x3D; nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。<br>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,1], k &#x3D; 3<br>输出: true<br>示例 2:</p>
<p>输入: nums &#x3D; [1,0,1,1], k &#x3D; 1<br>输出: true<br>示例 3:</p>
<p>输入: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2<br>输出: false</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate-ii">https://leetcode-cn.com/problems/contains-duplicate-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h5><p>使用map之前的结果，key为值,Value为数组下标。遍历数组,如果当前值重复，判断两个index之间的差值是否小于k。如果大于k,则更新该值的index为最新的index。因为后面有重复的话肯定离这个值最近。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsNearbyDuplicate</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> index,ok := mp[v]; ok&#123;</span><br><span class="line">            <span class="comment">// 存在,比较两个的差值</span></span><br><span class="line">            <span class="keyword">if</span> i - index &lt;= k &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 更新index</span></span><br><span class="line">                mp[v] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mp[v] = i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="414-第三大的数-简单"><a href="#414-第三大的数-简单" class="headerlink" title="414. 第三大的数[简单]"></a>414. 第三大的数[简单]</h4><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<p>示例 1:</p>
<p>输入: [3, 2, 1]</p>
<p>输出: 1</p>
<p>解释: 第三大的数是 1.<br>示例 2:</p>
<p>输入: [1, 2]</p>
<p>输出: 2</p>
<p>解释: 第三大的数不存在, 所以返回最大的数 2 .<br>示例 3:</p>
<p>输入: [2, 2, 3, 1]</p>
<p>输出: 1</p>
<p>解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。<br>存在两个值为2的数，它们都排第二。<br>通过次数31,553提交次数89,485</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/third-maximum-number">https://leetcode-cn.com/problems/third-maximum-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h5><p>遍历三次，每一次找一个最大的。最后比较第二大和第三大，相等返回第一大，不相等返回第三大。<br>flag的引入,为了陷入初始值特殊化的陷阱，保证都会考虑到。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">thirdMax</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    flag := <span class="number">0</span> <span class="comment">// 记录当前的阶段</span></span><br><span class="line">    one,two,three := nums[<span class="number">0</span>],nums[<span class="number">0</span>],nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; one &#123;</span><br><span class="line">                one = num</span><br><span class="line">                flag ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; one &#123;</span><br><span class="line">                one = num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后面的数据</span></span><br><span class="line">    flag ++ <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &lt; one &#123;</span><br><span class="line">                two = num</span><br><span class="line">                flag ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> flag == <span class="number">2</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; two &amp;&amp; num &lt; one &#123;</span><br><span class="line">                two = num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> num &lt; two &#123;</span><br><span class="line">                three = num</span><br><span class="line">                flag ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> flag == <span class="number">3</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; three &amp;&amp; num &lt; two &#123;</span><br><span class="line">                three = num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> three == two &#123;</span><br><span class="line">        <span class="keyword">return</span> one</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> three</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="448-找到所有数组中消失的数字-简单"><a href="#448-找到所有数组中消失的数字-简单" class="headerlink" title="448. 找到所有数组中消失的数字[简单]"></a>448. 找到所有数组中消失的数字[简单]</h4><p>给定一个范围在  1 ≤ a[i] ≤ n ( n &#x3D; 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<p>输入:<br>[4,3,2,7,8,2,3,1]</p>
<p>输出:<br>[5,6]<br>通过次数48,919提交次数82,136</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array">https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h5><ul>
<li>传统方法:hashMap</li>
<li>进阶<br>将访问到的值,作为下标去将该下标的值换成负数。换完之后,再遍历一遍，如果值为正的，说明该值对应的下标不存在数组中。如果存在就会被换成负数的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 置位下标</span></span><br><span class="line">    <span class="comment">// 将访问过的值对应的下标置为负数,</span></span><br><span class="line">    <span class="comment">// 如果没有出现某个值,这个值的下标对应的数是正数</span></span><br><span class="line">    re := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[-nums[i]<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">              nums[-nums[i]<span class="number">-1</span>] = -nums[-nums[i]<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span> nums[nums[i]<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                nums[nums[i]<span class="number">-1</span>] = -nums[nums[i]<span class="number">-1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,i+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="86-分隔链表-简单"><a href="#86-分隔链表-简单" class="headerlink" title="86. 分隔链表[简单]"></a>86. 分隔链表[简单]</h4><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<p>输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5<br>通过次数48,112提交次数81,182</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-list">https://leetcode-cn.com/problems/partition-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h5><p>新建两条链表,小于x的放在第一条链表中，大于等于x的放在第二条链表中。最后将两条链表连接起来。<br>由于新的链表元素相对顺序不变，维护一个尾巴,来了就连接进去就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(head *ListNode, x <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    first,second := &amp;ListNode&#123;&#125;,&amp;ListNode&#123;&#125;</span><br><span class="line">    firstTail,secondTail := first,second</span><br><span class="line">    split := x</span><br><span class="line">    <span class="comment">// 进行分割</span></span><br><span class="line">    <span class="keyword">for</span> cur := head;cur!= <span class="literal">nil</span>;&#123;</span><br><span class="line">        <span class="keyword">if</span> cur.Val &lt; split &#123;</span><br><span class="line">            <span class="comment">// 添加到first链表</span></span><br><span class="line">            tmp := cur</span><br><span class="line">            cur = cur.Next</span><br><span class="line">            tmp.Next = <span class="literal">nil</span></span><br><span class="line">            firstTail.Next = tmp</span><br><span class="line">            firstTail = tmp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 添加到second链表</span></span><br><span class="line">            tmp := cur</span><br><span class="line">            cur = cur.Next</span><br><span class="line">            tmp.Next = <span class="literal">nil</span></span><br><span class="line">            secondTail.Next = tmp</span><br><span class="line">            secondTail = tmp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 两个链表拼接</span></span><br><span class="line">    firstTail.Next = second.Next</span><br><span class="line">    <span class="keyword">return</span> first.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="561-数组拆分-I-简单"><a href="#561-数组拆分-I-简单" class="headerlink" title="561. 数组拆分 I[简单]"></a>561. 数组拆分 I[简单]</h4><p>给定长度为 2n 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<p>示例 1:</p>
<p>输入: [1,4,3,2]</p>
<p>输出: 4<br>解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).<br>提示:</p>
<p>n 是正整数,范围在 [1, 10000].<br>数组中的元素范围在 [-10000, 10000].<br>通过次数44,248提交次数61,688</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i">https://leetcode-cn.com/problems/array-partition-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h5><p>排序，奇数位肯定是最小的。并且排序之后，两个数之间的损失是最小的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arrayPairSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="comment">// 奇数位相加</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            sum += nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="532-数组中的K-diff数对-简单"><a href="#532-数组中的K-diff数对-简单" class="headerlink" title="532. 数组中的K-diff数对[简单]"></a>532. 数组中的K-diff数对[简单]</h4><p>给定一个整数数组和一个整数 k, 你需要在数组里找到不同的 k-diff 数对。这里将 k-diff 数对定义为一个整数对 (i, j), 其中 i 和 j 都是数组中的数字，且两数之差的绝对值是 k.</p>
<p>示例 1:</p>
<p>输入: [3, 1, 4, 1, 5], k &#x3D; 2<br>输出: 2<br>解释: 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。<br>尽管数组中有两个1，但我们只应返回不同的数对的数量。<br>示例 2:</p>
<p>输入:[1, 2, 3, 4, 5], k &#x3D; 1<br>输出: 4<br>解释: 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。<br>示例 3:</p>
<p>输入: [1, 3, 1, 5, 4], k &#x3D; 0<br>输出: 1<br>解释: 数组中只有一个 0-diff 数对，(1, 1)。<br>注意:</p>
<p>数对 (i, j) 和数对 (j, i) 被算作同一数对。<br>数组的长度不超过10,000。<br>所有输入的整数的范围在 [-1e7, 1e7]。<br>通过次数18,122提交次数52,306</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/k-diff-pairs-in-an-array">https://leetcode-cn.com/problems/k-diff-pairs-in-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findPairs</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> k &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	numsHas := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">	diffHas := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> numsHas[num - k] &#123;</span><br><span class="line">			diffHas[num - k] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> numsHas[num + k] &#123;</span><br><span class="line">			diffHas[num] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		numsHas[num] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(diffHas)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：xiaoma_nmg</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/k-diff-pairs-in-an-array/solution/onjie-fa-by-xiaoma_nmg/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="566-重塑矩阵-简单"><a href="#566-重塑矩阵-简单" class="headerlink" title="566. 重塑矩阵[简单]"></a>566. 重塑矩阵[简单]</h4><p>在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p>
<p>给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。</p>
<p>如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p>示例 1:</p>
<p>输入:<br>nums &#x3D;<br>[[1,2],<br> [3,4]]<br>r &#x3D; 1, c &#x3D; 4<br>输出:<br>[[1,2,3,4]]<br>解释:<br>行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。<br>示例 2:</p>
<p>输入:<br>nums &#x3D;<br>[[1,2],<br> [3,4]]<br>r &#x3D; 2, c &#x3D; 4<br>输出:<br>[[1,2],<br> [3,4]]<br>解释:<br>没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。<br>注意：</p>
<p>给定矩阵的宽和高范围在 [1, 100]。<br>给定的 r 和 c 都是正数。<br>通过次数20,627提交次数31,767</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reshape-the-matrix">https://leetcode-cn.com/problems/reshape-the-matrix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h5><p>如果重塑之后的r*c的值不等于原有数组的值。那么,那么返回原来的数组。接下来,将原数组的数据给解开,放入队列中。再一个一个的填充进新的数组中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">matrixReshape</span><span class="params">(nums [][]<span class="type">int</span>, r <span class="type">int</span>, c <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(nums)</span><br><span class="line">    column := <span class="built_in">len</span>(nums[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> r * c != row * column &#123;</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    &#125;</span><br><span class="line">    list := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,rowItem := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">for</span> _,columnItem := <span class="keyword">range</span> rowItem &#123;</span><br><span class="line">            list = <span class="built_in">append</span>(list,columnItem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    reNums := <span class="built_in">make</span>([][]<span class="type">int</span>,r)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;r;i++ &#123;</span><br><span class="line">        colNum := <span class="built_in">make</span>([]<span class="type">int</span>,c)</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;c;j++&#123;</span><br><span class="line">            colNum[j] = list[count]</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">        reNums[i] = colNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reNums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="581-最短无序连续子数组-简单"><a href="#581-最短无序连续子数组-简单" class="headerlink" title="581. 最短无序连续子数组[简单]"></a>581. 最短无序连续子数组[简单]</h4><p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是最短的，请输出它的长度。</p>
<p>示例 1:</p>
<p>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。<br>说明 :</p>
<p>输入的数组长度范围在 [1, 10,000]。<br>输入的数组可能包含重复元素 ，所以升序的意思是&lt;&#x3D;。<br>通过次数35,471提交次数101,719</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h5><p>克隆原来的数组，然后将新的数组排序。然后从前往后找不一致的子数组。如果没有找到，说明原本的数组已经是递增了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUnsortedSubarray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    newNum := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        newNum[i] = num</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(newNum)</span><br><span class="line">    <span class="comment">// fmt.Println(nums)</span></span><br><span class="line">    <span class="comment">// fmt.Println(newNum)</span></span><br><span class="line">    head := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num != newNum[i] &#123;</span><br><span class="line">            head = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到数据差异的</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> == <span class="built_in">len</span>(newNum)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tail := <span class="built_in">len</span>(nums) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:=tail;i&gt;=<span class="number">0</span>;i--&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] != newNum[i] &#123;</span><br><span class="line">            tail = i</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail - head + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="605-种花问题-简单"><a href="#605-种花问题-简单" class="headerlink" title="605. 种花问题[简单]"></a>605. 种花问题[简单]</h4><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:</p>
<p>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1<br>输出: True<br>示例 2:</p>
<p>输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2<br>输出: False<br>注意:</p>
<p>数组内已种好的花不会违反种植规则。<br>输入的数组长度范围为 [1, 20000]。<br>n 是非负整数，且不会超过输入数组的大小。<br>通过次数31,893提交次数99,263</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers">https://leetcode-cn.com/problems/can-place-flowers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h5><p>在原数组的基础上前后加0,连续出现3个0便在中间种花，前后加0之后可以少考虑边界问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPlaceFlowers</span><span class="params">(flowerbed []<span class="type">int</span>, n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    f := <span class="built_in">append</span>([]<span class="type">int</span>&#123;<span class="number">0</span>&#125;,<span class="built_in">append</span>(flowerbed,<span class="number">0</span>)...)</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>;i &lt;<span class="built_in">len</span>(f)<span class="number">-1</span>;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> count == n &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f[i<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; f[i] == <span class="number">0</span> &amp;&amp; f[i+<span class="number">1</span>] == <span class="number">0</span> &#123;</span><br><span class="line">            count ++</span><br><span class="line">            f[i] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="628-三个数的最大乘积-简单"><a href="#628-三个数的最大乘积-简单" class="headerlink" title="628. 三个数的最大乘积[简单]"></a>628. 三个数的最大乘积[简单]</h4><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p>示例 1:</p>
<p>输入: [1,2,3]<br>输出: 6<br>示例 2:</p>
<p>输入: [1,2,3,4]<br>输出: 24<br>注意:</p>
<p>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。<br>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。<br>通过次数24,532提交次数48,652</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers">https://leetcode-cn.com/problems/maximum-product-of-three-numbers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximumProduct</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result := nums[length<span class="number">-1</span>] * nums[length <span class="number">-2</span>] * nums[length<span class="number">-3</span>]</span><br><span class="line">    <span class="keyword">if</span> result &lt; nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[length <span class="number">-1</span>] &#123;</span><br><span class="line">        <span class="comment">// 考虑负数的情况,最小的两个负数和最大的正数积</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[length <span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="143-重排链表-中等"><a href="#143-重排链表-中等" class="headerlink" title="143. 重排链表[中等]"></a>143. 重排链表[中等]</h4><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.<br>通过次数35,105提交次数62,182</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list">https://leetcode-cn.com/problems/reorder-list</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h5><p>将链表从中间分割成两个，后面的链表指针倒置。<br>然后前后两个链表重新连接。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reorderList</span><span class="params">(head *ListNode)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分割 倒序 重连</span></span><br><span class="line">    <span class="comment">// 寻找中间节点</span></span><br><span class="line">    slow,fast := head,head</span><br><span class="line">    <span class="keyword">for</span> ;fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>;&#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow =slow.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从中间分割</span></span><br><span class="line">    cur := slow.Next</span><br><span class="line">    slow.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 后面的链表倒置</span></span><br><span class="line">    <span class="keyword">var</span> newListHead *ListNode = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">for</span> ; cur != <span class="literal">nil</span>;&#123;</span><br><span class="line">        tmp := cur</span><br><span class="line">        cur = cur.Next</span><br><span class="line">        tmp.Next = <span class="literal">nil</span></span><br><span class="line">        tmp.Next = newListHead</span><br><span class="line">        newListHead = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 连接</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">for</span> cur2 := newListHead;cur2 != <span class="literal">nil</span>;&#123;</span><br><span class="line">        temp := cur2</span><br><span class="line">        cur2 = cur2.Next</span><br><span class="line">        temp.Next = cur.Next</span><br><span class="line">        cur.Next = temp</span><br><span class="line">        cur = cur.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h5><p>将链表数据取出放置切片中。然后再分别取出对应的值进行重连。相较于方法一，使用额外的空间o(n)。</p>
<h4 id="643-子数组最大平均数-I-简单"><a href="#643-子数组最大平均数-I-简单" class="headerlink" title="643. 子数组最大平均数 I[简单]"></a>643. 子数组最大平均数 I[简单]</h4><p>给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</p>
<p>示例 1:</p>
<p>输入: [1,12,-5,-6,50,3], k &#x3D; 4<br>输出: 12.75<br>解释: 最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75
 </p>
<p>注意:</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; n &lt;&#x3D; 30,000。<br>所给数据范围 [-10,000，10,000]。<br>通过次数18,433提交次数47,162</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-average-subarray-i">https://leetcode-cn.com/problems/maximum-average-subarray-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h5><p>加上前面就减去后面，往后滑动，取最大值。最后除k.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxAverage</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    max := math.MinInt64</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++&#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> sum &gt; max&#123;</span><br><span class="line">        max = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := k;i &lt; <span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        sum += nums[i]</span><br><span class="line">        sum = sum - nums[i-k]</span><br><span class="line">        <span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">            max = sum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">float64</span>(max) / <span class="type">float64</span>(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="20-有效的括号-简单"><a href="#20-有效的括号-简单" class="headerlink" title="20. 有效的括号[简单]"></a>20. 有效的括号[简单]</h5><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true<br>示例 2:</p>
<p>输入: “()[]{}”<br>输出: true<br>示例 3:</p>
<p>输入: “(]”<br>输出: false<br>示例 4:</p>
<p>输入: “([)]”<br>输出: false<br>示例 5:</p>
<p>输入: “{[]}”<br>输出: true<br>通过次数389,566提交次数908,398</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h5><p>括号入栈,匹配出栈。最后栈为空说明匹配完成。否则不能匹配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   stack := <span class="built_in">make</span>([]<span class="type">int32</span>,<span class="built_in">len</span>(s))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,c := <span class="keyword">range</span> s &#123;</span><br><span class="line">       <span class="keyword">if</span> top == <span class="number">-1</span> &#123;</span><br><span class="line">           top ++</span><br><span class="line">           stack[top] = c</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// &#x27;(&#x27; &#x27;)&#x27; &#x27;&#123;&#x27; &#x27;&#125;&#x27; &#x27;[&#x27; &#x27;]&#x27; </span></span><br><span class="line">           <span class="keyword">if</span> (stack[top] == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;)&#x27;</span>) || (stack[top] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="string">&#x27;&#125;&#x27;</span>) || (stack[top] == <span class="string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">               top --</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               top ++</span><br><span class="line">               stack[top] = c</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="155-最小栈-简单"><a href="#155-最小栈-简单" class="headerlink" title="155. 最小栈[简单]"></a>155. 最小栈[简单]</h4><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。
 </p>
<p>示例:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.
 </p>
<p>提示：</p>
<p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack">https://leetcode-cn.com/problems/min-stack</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h5><p>双栈,其中一个只放最小的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val []<span class="type">int</span></span><br><span class="line">    Min []<span class="type">int</span></span><br><span class="line">    TopVal <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">    stack := MinStack&#123;</span><br><span class="line">        Val : []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">        Min : []<span class="type">int</span>&#123;&#125;,</span><br><span class="line">        TopVal : <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stack.Val = <span class="built_in">append</span>(stack.Val,<span class="number">-1</span>)</span><br><span class="line">    stack.Min = <span class="built_in">append</span>(stack.Min,math.MinInt32)</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> this.TopVal == <span class="number">0</span>&#123;</span><br><span class="line">        this.Min = <span class="built_in">append</span>(this.Min,x)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> x &lt; this.Min[this.TopVal] &#123;</span><br><span class="line">        this.Min = <span class="built_in">append</span>(this.Min,x)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        this.Min = <span class="built_in">append</span>(this.Min,math.MinInt32)</span><br><span class="line">        this.Min[this.TopVal + <span class="number">1</span>] = this.Min[this.TopVal]</span><br><span class="line">    &#125;</span><br><span class="line">    this.TopVal += <span class="number">1</span></span><br><span class="line">    this.Val = <span class="built_in">append</span>(this.Val,x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop()  &#123;</span><br><span class="line">    this.TopVal -= <span class="number">1</span></span><br><span class="line">    this.Val = this.Val[:this.TopVal + <span class="number">1</span>]</span><br><span class="line">    this.Min = this.Min[:this.TopVal + <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.Val[this.TopVal]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.Min[this.TopVal]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="13-罗马数字转整数-简单"><a href="#13-罗马数字转整数-简单" class="headerlink" title="13. 罗马数字转整数[简单]"></a>13. 罗马数字转整数[简单]</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: “III”<br>输出: 3<br>示例 2:</p>
<p>输入: “IV”<br>输出: 4<br>示例 3:</p>
<p>输入: “IX”<br>输出: 9<br>示例 4:</p>
<p>输入: “LVIII”<br>输出: 58<br>解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.<br>示例 5:</p>
<p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.<br>通过次数245,410提交次数395,474</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    pre := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>&#123;</span><br><span class="line">            pre = getNum(v)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            num := getNum(v)</span><br><span class="line">            <span class="keyword">if</span> pre &lt; num &#123;</span><br><span class="line">                sum -= pre</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum += pre</span><br><span class="line">            &#125;</span><br><span class="line">            pre = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += pre</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNum</span><span class="params">(c <span class="type">int32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> c &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="661-图片平滑器-简单"><a href="#661-图片平滑器-简单" class="headerlink" title="661. 图片平滑器[简单]"></a>661. 图片平滑器[简单]</h4><p>包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。</p>
<p>示例 1:</p>
<p>输入:<br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br>输出:<br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br>解释:<br>对于点 (0,0), (0,2), (2,0), (2,2): 平均(3&#x2F;4) &#x3D; 平均(0.75) &#x3D; 0<br>对于点 (0,1), (1,0), (1,2), (2,1): 平均(5&#x2F;6) &#x3D; 平均(0.83333333) &#x3D; 0<br>对于点 (1,1): 平均(8&#x2F;9) &#x3D; 平均(0.88888889) &#x3D; 0<br>注意:</p>
<p>给定矩阵中的整数范围为 [0, 255]。<br>矩阵的长和宽的范围均为 [1, 150]。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/image-smoother">https://leetcode-cn.com/problems/image-smoother</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h5><p>遍历，计算上下左右取平均值。需要赋给新的数组，不能在原有的数组中进行更改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">imageSmoother</span><span class="params">(M [][]<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(M)</span><br><span class="line">    column := <span class="built_in">len</span>(M[<span class="number">0</span>])</span><br><span class="line">    re := <span class="built_in">make</span>([][]<span class="type">int</span>,row)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;row;i++&#123;</span><br><span class="line">        re[i] = <span class="built_in">make</span>([]<span class="type">int</span>,column)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; column; j++ &#123;</span><br><span class="line">            count := <span class="number">0</span></span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            <span class="comment">// 获得周围8格的数据</span></span><br><span class="line">            <span class="keyword">for</span> i1:=<span class="number">-1</span>; i1 &lt; <span class="number">2</span>; i1 ++&#123;</span><br><span class="line">                <span class="keyword">for</span> j1:=<span class="number">-1</span>;j1 &lt; <span class="number">2</span>;j1++&#123;</span><br><span class="line">                    <span class="keyword">if</span> i1 + i &gt;= <span class="number">0</span> &amp;&amp; i1 + i &lt; row  &amp;&amp; j1 + j &gt;= <span class="number">0</span> &amp;&amp; j1+ j &lt; column&#123;</span><br><span class="line">                        sum += M[i1+i][j1+j]</span><br><span class="line">                        count ++</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 除以平均数</span></span><br><span class="line">             re[i][j] = <span class="type">int</span>(math.Floor(<span class="type">float64</span>(sum) / <span class="type">float64</span>(count)))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="665-非递减数列-简单"><a href="#665-非递减数列-简单" class="headerlink" title="665. 非递减数列[简单]"></a>665. 非递减数列[简单]</h4><p>给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (0 &lt;&#x3D; i &lt;&#x3D; n-2)，总满足 nums[i] &lt;&#x3D; nums[i + 1]。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [4,2,3]<br>输出: true<br>解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。<br>示例 2:</p>
<p>输入: nums &#x3D; [4,2,1]<br>输出: false<br>解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
 </p>
<p>说明：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 10 ^ 4</p>
<ul>
<li>10 ^ 5 &lt;&#x3D; nums[i] &lt;&#x3D; 10 ^ 5<br>通过次数25,155提交次数111,287</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array">https://leetcode-cn.com/problems/non-decreasing-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h5><p>设一个变量count用于计数，统计需要修改的元素的个数<br>设curIndex为下标，找到nums[curIndex] &gt; nums[curIndex+1]的元素位置，其可以继续向前遍历case有以下几种：</p>
<p>[4,2,3]，curIndex的左边没有元素了<br>[2,4,2,3]，curIndex左边有元素，并且满足nums[curIndex - 1] &lt;&#x3D; nums[curIndex + 1]<br>[2,3,4,2]，curIndex右边的元素是最后一个<br>[2,3,4,3,4]，curIndex右边的元素不是最后一个，但是满足nums[curIndex] &lt;&#x3D; nums[curIndex + 2]<br>满足以上条件，则可以进行count统计，否则直接返回false，自增count后也要检查count &gt; 1的情况<br>curIndex的上界为len(nums) - 1</p>
<p>代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPossibility</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i + <span class="number">1</span>] &#123;</span><br><span class="line">            <span class="keyword">if</span> i - <span class="number">1</span> &lt; <span class="number">0</span> || (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] &lt;= nums[i + <span class="number">1</span>]) || </span><br><span class="line">            (i + <span class="number">2</span> &gt;= <span class="built_in">len</span>(nums) || (i + <span class="number">2</span> &lt; <span class="built_in">len</span>(nums) &amp;&amp; nums[i] &lt;= nums[i + <span class="number">2</span>])) &#123;</span><br><span class="line">                count++</span><br><span class="line">                <span class="keyword">if</span> count &gt; <span class="number">1</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者：jihonghe<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/solution/jian-ji-ming-liao-yi-kan-jiu-dong-guan-jian-jiu-sh/">https://leetcode-cn.com/problems/non-decreasing-array/solution/jian-ji-ming-liao-yi-kan-jiu-dong-guan-jian-jiu-sh/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><p>@码不停题<br>&#x2F;*思路： 看了很多解析，没有讲的很明白的，自己整理了下思路，并配上例子，希望能够讲明白些。 提交结果运行时间超过了100%的人。</p>
<p>  这道题给了我们一个数组，说我们最多有1次修改某个数字的机会，<br>  问能不能将数组变为非递减数组。题目中给的例子太少，不能覆盖所有情况，我们再来看下面三个例子：<br>	4，2，3<br>	-1，4，2，3<br>	2，3，3，2，4<br>我们通过分析上面三个例子可以发现，当我们发现后面的数字小于前面的数字产生冲突后，<br>[1]有时候需要修改前面较大的数字(比如前两个例子需要修改4)，<br>[2]有时候却要修改后面较小的那个数字(比如前第三个例子需要修改2)，<br>那么有什么内在规律吗？是有的，判断修改那个数字其实跟再前面一个数的大小有关系，<br>首先如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字为当前的数字2即可。<br>而当再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2；<br>如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPossibility</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="built_in">len</span>(nums) &amp;&amp; count &lt; <span class="number">2</span>;i ++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i<span class="number">-1</span>] &lt;= nums[i]&#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        count ++</span><br><span class="line">        <span class="keyword">if</span> i<span class="number">-2</span> &gt;=<span class="number">0</span> &amp;&amp;nums[i<span class="number">-2</span>] &gt; nums[i] &#123;</span><br><span class="line">            nums[i] = nums[i<span class="number">-1</span>]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i <span class="number">-1</span>] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &lt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="496-下一个更大元素-I-简单"><a href="#496-下一个更大元素-I-简单" class="headerlink" title="496. 下一个更大元素 I[简单]"></a>496. 下一个更大元素 I[简单]</h4><p>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。<br>    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。<br>    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。<br>示例 2:</p>
<p>输入: nums1 &#x3D; [2,4], nums2 &#x3D; [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。<br>    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
 </p>
<p>提示：</p>
<p>nums1和nums2中所有元素是唯一的。<br>nums1和nums2 的数组大小都不超过1000。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-i">https://leetcode-cn.com/problems/next-greater-element-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h5><p>先在num2中计算每个值得下一个大于它得数，然后将对应得映射结果放置于map中。然后遍历num1,从map中取得对应的值生成结果返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextGreaterElement</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先计算num2每个元素更大的</span></span><br><span class="line">    indexMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums2);i++&#123;</span><br><span class="line">        search := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums2);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> nums2[j] &gt; nums2[i] &#123;</span><br><span class="line">                indexMap[nums2[i]] = nums2[j]</span><br><span class="line">                search = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !search&#123;</span><br><span class="line">            indexMap[nums2[i]] = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums1&#123;</span><br><span class="line">       mv,_ := indexMap[v]</span><br><span class="line">       ret = <span class="built_in">append</span>(ret,mv)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="682-棒球比赛-简单"><a href="#682-棒球比赛-简单" class="headerlink" title="682. 棒球比赛[简单]"></a>682. 棒球比赛[简单]</h4><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：<br>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。<br>2. “+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。<br>3. “D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。<br>4. “C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</p>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p>
<p>示例 1:</p>
<p>输入: [“5”,”2”,”C”,”D”,”+”]<br>输出: 30<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到2分。总和是：7。<br>操作1：第2轮的数据无效。总和是：5。<br>第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。<br>第4轮：你可以得到5 + 10 &#x3D; 15分。总数是：30。<br>示例 2:</p>
<p>输入: [“5”,”-2”,”4”,”C”,”D”,”9”,”+”,”+”]<br>输出: 27<br>解释:<br>第1轮：你可以得到5分。总和是：5。<br>第2轮：你可以得到-2分。总数是：3。<br>第3轮：你可以得到4分。总和是：7。<br>操作1：第3轮的数据无效。总数是：3。<br>第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。<br>第5轮：你可以得到9分。总数是：8。<br>第6轮：你可以得到-4 + 9 &#x3D; 5分。总数是13。<br>第7轮：你可以得到9 + 5 &#x3D; 14分。总数是27。<br>注意：</p>
<p>输入列表的大小将介于1和1000之间。<br>列表中的每个整数都将介于-30000和30000之间。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/baseball-game">https://leetcode-cn.com/problems/baseball-game</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h5><p>将每一轮的结果入栈，如果无效就出栈。每一次操作都会影响到栈的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calPoints</span><span class="params">(ops []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(opts))</span><br><span class="line">    re := <span class="number">0</span></span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> ops&#123;</span><br><span class="line">        <span class="comment">//fmt.Println(v)</span></span><br><span class="line">        <span class="keyword">switch</span> v &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;C&quot;</span>:</span><br><span class="line">            re -= stack[top]</span><br><span class="line">            top --</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;D&quot;</span>:</span><br><span class="line">            tmp := <span class="number">2</span> * stack[top]</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = tmp</span><br><span class="line">            re += tmp</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            tmp1 := stack[top]</span><br><span class="line">            tmp2 := <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> top &gt; <span class="number">0</span> &#123;</span><br><span class="line">                top --</span><br><span class="line">                tmp2 = stack[top]</span><br><span class="line">                top ++</span><br><span class="line">            &#125;</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = tmp1 + tmp2</span><br><span class="line">            re = re + tmp1 + tmp2</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            d,_ := strconv.Atoi(v)</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = d</span><br><span class="line">            re += d</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="844-比较含退格的字符串-简单"><a href="#844-比较含退格的字符串-简单" class="headerlink" title="844. 比较含退格的字符串[简单]"></a>844. 比较含退格的字符串[简单]</h4><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>示例 1：</p>
<p>输入：S &#x3D; “ab#c”, T &#x3D; “ad#c”<br>输出：true<br>解释：S 和 T 都会变成 “ac”。<br>示例 2：</p>
<p>输入：S &#x3D; “ab##”, T &#x3D; “c#d#”<br>输出：true<br>解释：S 和 T 都会变成 “”。<br>示例 3：</p>
<p>输入：S &#x3D; “a##c”, T &#x3D; “#a#c”<br>输出：true<br>解释：S 和 T 都会变成 “c”。<br>示例 4：</p>
<p>输入：S &#x3D; “a#c”, T &#x3D; “b”<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; S.length &lt;&#x3D; 200<br>1 &lt;&#x3D; T.length &lt;&#x3D; 200<br>S 和 T 只含有小写字母以及字符 ‘#’。
 </p>
<p>进阶：</p>
<p>你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？
 </p>
<p>通过次数26,064提交次数51,129</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare">https://leetcode-cn.com/problems/backspace-string-compare</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h5><p>双栈,不是#入栈,是#出栈。最后比较两个栈的大小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backspaceCompare</span><span class="params">(S <span class="type">string</span>, T <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    stack1 := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(S))</span><br><span class="line">    stack2 := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(T))</span><br><span class="line">    top1,top2 := <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> S &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;#&#x27;</span> == v&#123;</span><br><span class="line">            <span class="keyword">if</span> top1 &gt;= <span class="number">0</span>&#123;</span><br><span class="line">                top1 --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            top1 ++</span><br><span class="line">            stack1[top1] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> T &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;#&#x27;</span> == v &#123;</span><br><span class="line">            <span class="keyword">if</span> top2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                top2 --</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            top2 ++</span><br><span class="line">            stack2[top2] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> top1 == top2 &#123;</span><br><span class="line">        <span class="keyword">for</span> ;top1 &gt;= <span class="number">0</span>;top1--&#123;</span><br><span class="line">            <span class="keyword">if</span> stack1[top1] != stack2[top1] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1021-删除最外层的括号-简单"><a href="#1021-删除最外层的括号-简单" class="headerlink" title="1021. 删除最外层的括号[简单]"></a>1021. 删除最外层的括号[简单]</h4><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S &#x3D; A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S &#x3D; P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”(()())(())”<br>输出：”()()()”<br>解释：<br>输入字符串为 “(()())(())”，原语化分解得到 “(()())” + “(())”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” &#x3D; “()()()”。<br>示例 2：</p>
<p>输入：”(()())(())(()(()))”<br>输出：”()()()()(())”<br>解释：<br>输入字符串为 “(()())(())(()(()))”，原语化分解得到 “(()())” + “(())” + “(()(()))”，<br>删除每个部分中的最外层括号后得到 “()()” + “()” + “()(())” &#x3D; “()()()()(())”。<br>示例 3：</p>
<p>输入：”()()”<br>输出：””<br>解释：<br>输入字符串为 “()()”，原语化分解得到 “()” + “()”，<br>删除每个部分中的最外层括号后得到 “” + “” &#x3D; “”。
 </p>
<p>提示：</p>
<p>S.length &lt;&#x3D; 10000<br>S[i] 为 “(“ 或 “)”<br>S 是一个有效括号字符串<br>通过次数36,402提交次数46,845<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-outermost-parentheses">https://leetcode-cn.com/problems/remove-outermost-parentheses</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h5><p>如何寻找最外层的括号对。当栈中只有一个’(‘这样匹配到’)’时。这个就是最外层。因为最外层的括号组是最垫底的。所以,将不是最外层的括号队保存起来打印便可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeOuterParentheses</span><span class="params">(S <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(S))</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(S))</span><br><span class="line">    index := <span class="number">-1</span></span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="comment">//re := &quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> S&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;(&#x27;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>  top &gt;= <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 不是最外层括号,需要打印出</span></span><br><span class="line">                <span class="comment">//re += &quot;(&quot;</span></span><br><span class="line">                index ++</span><br><span class="line">                s[index] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                <span class="comment">//是最外层括号,只要进栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = v</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> top &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 打印非最外层</span></span><br><span class="line">                <span class="comment">//re += &quot;)&quot;</span></span><br><span class="line">                index ++</span><br><span class="line">                s[index] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            top --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s[:index+<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1047-删除字符串中的所有相邻重复项-简单"><a href="#1047-删除字符串中的所有相邻重复项-简单" class="headerlink" title="1047. 删除字符串中的所有相邻重复项[简单]"></a>1047. 删除字符串中的所有相邻重复项[简单]</h4><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p> </p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; S.length &lt;&#x3D; 20000<br>S 仅由小写英文字母组成。<br>通过次数25,549提交次数37,292</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h5><p>入栈，相同出栈，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(S <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 入栈,相同出栈</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(S))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> S&#123;</span><br><span class="line">        <span class="keyword">if</span> top &lt; <span class="number">0</span>&#123;</span><br><span class="line">            top++</span><br><span class="line">            stack[top] = v</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> stack[top] == v &#123;</span><br><span class="line">                top --</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                top++</span><br><span class="line">                stack[top] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(stack[:top+<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1441-用栈操作构建数组-简单"><a href="#1441-用栈操作构建数组-简单" class="headerlink" title="1441. 用栈操作构建数组[简单]"></a>1441. 用栈操作构建数组[简单]</h4><p>给你一个目标数组 target 和一个整数 n。每次迭代，需要从  list &#x3D; {1,2,3…, n} 中依序读取一个数字。</p>
<p>请使用下述操作来构建目标数组 target ：</p>
<p>Push：从 list 中读取一个新元素， 并将其推入数组中。<br>Pop：删除数组中的最后一个元素。<br>如果目标数组构建完成，就停止读取更多元素。<br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</p>
<p>请返回构建目标数组所用的操作序列。</p>
<p>题目数据保证答案是唯一的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：target &#x3D; [1,3], n &#x3D; 3<br>输出：[“Push”,”Push”,”Pop”,”Push”]<br>解释：<br>读取 1 并自动推入数组 -&gt; [1]<br>读取 2 并自动推入数组，然后删除它 -&gt; [1]<br>读取 3 并自动推入数组 -&gt; [1,3]<br>示例 2：</p>
<p>输入：target &#x3D; [1,2,3], n &#x3D; 3<br>输出：[“Push”,”Push”,”Push”]<br>示例 3：</p>
<p>输入：target &#x3D; [1,2], n &#x3D; 4<br>输出：[“Push”,”Push”]<br>解释：只需要读取前 2 个数字就可以停止。<br>示例 4：</p>
<p>输入：target &#x3D; [2,3,4], n &#x3D; 4<br>输出：[“Push”,”Pop”,”Push”,”Push”,”Push”]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; target.length &lt;&#x3D; 100<br>1 &lt;&#x3D; target[i] &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; 100<br>target 是严格递增的<br>通过次数8,958提交次数13,851</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations">https://leetcode-cn.com/problems/build-an-array-with-stack-operations</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h5><p>将寻找target的操作入栈便可</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildArray</span><span class="params">(target []<span class="type">int</span>, n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    indexTarget := <span class="number">0</span></span><br><span class="line">    stack := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i &lt;= n;i++&#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack,<span class="string">&quot;Push&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> target[indexTarget] != i &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack,<span class="string">&quot;Pop&quot;</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            indexTarget ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> indexTarget == <span class="built_in">len</span>(target) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1544-整理字符串-简单"><a href="#1544-整理字符串-简单" class="headerlink" title="1544. 整理字符串[简单]"></a>1544. 整理字符串[简单]</h4><p>给你一个由大小写英文字母组成的字符串 s 。</p>
<p>一个整理好的字符串中，两个相邻字符 s[i] 和 s[i + 1] 不会同时满足下述条件：</p>
<p>0 &lt;&#x3D; i &lt;&#x3D; s.length - 2<br>s[i] 是小写字符，但 s[i + 1] 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。</p>
<p>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p>
<p>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “leEeetcode”<br>输出：”leetcode”<br>解释：无论你第一次选的是 i &#x3D; 1 还是 i &#x3D; 2，都会使 “leEeetcode” 缩减为 “leetcode” 。<br>示例 2：</p>
<p>输入：s &#x3D; “abBAcC”<br>输出：””<br>解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：<br>“abBAcC” –&gt; “aAcC” –&gt; “cC” –&gt; “”<br>“abBAcC” –&gt; “abBA” –&gt; “aA” –&gt; “”<br>示例 3：</p>
<p>输入：s &#x3D; “s”<br>输出：”s”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含小写和大写英文字母<br>通过次数7,811提交次数16,725</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/make-the-string-great">https://leetcode-cn.com/problems/make-the-string-great</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h5><p>大小写相邻出栈，最后留在栈中的数据便是留下来的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeGood</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 满足相邻是大小写的,去掉</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == s &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(s))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> top &lt;= <span class="number">-1</span> &#123;</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = v</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> stack[top] - v == <span class="number">32</span> || stack[top] - v == <span class="number">-32</span> &#123;</span><br><span class="line">                top --</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                top ++</span><br><span class="line">                stack[top] = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(stack[:top + <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-09-用两个栈实现队列-简单"><a href="#剑指-Offer-09-用两个栈实现队列-简单" class="headerlink" title="剑指 Offer 09. 用两个栈实现队列[简单]"></a>剑指 Offer 09. 用两个栈实现队列[简单]</h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p> </p>
<p>示例 1：</p>
<p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]<br>示例 2：</p>
<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]<br>提示：</p>
<p>1 &lt;&#x3D; values &lt;&#x3D; 10000<br>最多会对 appendTail、deleteHead 进行 10000 次调用<br>通过次数88,803提交次数121,594</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h5><p>出栈,将数据放到另一个栈中。到栈顶之后出栈,然后将临时栈放回原来的栈。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack []<span class="type">int</span></span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> CQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> CQueue&#123;stack:<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10000</span>),top:<span class="number">-1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> AppendTail(value <span class="type">int</span>)  &#123;</span><br><span class="line">    this.top ++</span><br><span class="line">    this.stack[this.top] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> DeleteHead() <span class="type">int</span> &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>,this.top + <span class="number">1</span>)</span><br><span class="line">    tmp_top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := this.top;i &gt; <span class="number">0</span>;i--&#123;</span><br><span class="line">        tmp_top ++</span><br><span class="line">        tmp[tmp_top] = this.stack[this.top]</span><br><span class="line">        this.top --</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> this.top == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ret = this.stack[this.top]</span><br><span class="line">        this.top --</span><br><span class="line">        <span class="keyword">for</span> i:=tmp_top; i &gt;= <span class="number">0</span>; i--&#123;</span><br><span class="line">            this.top ++</span><br><span class="line">            this.stack[this.top] = tmp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-30-包含min函数的栈-简单"><a href="#剑指-Offer-30-包含min函数的栈-简单" class="headerlink" title="剑指 Offer 30. 包含min函数的栈[简单]"></a>剑指 Offer 30. 包含min函数的栈[简单]</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<p> </p>
<p>示例:</p>
<p>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.
 </p>
<p>提示：</p>
<p>各函数的调用总次数不超过 20000 次
 </p>
<p>注意：本题与主站 155 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p>
<p>通过次数39,358提交次数68,616<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">    minStack []<span class="type">int</span></span><br><span class="line">    min_top <span class="type">int</span></span><br><span class="line">    stack []<span class="type">int</span></span><br><span class="line">    stack_top <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">    <span class="keyword">return</span> MinStack&#123;</span><br><span class="line">        minStack: <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">20000</span>),</span><br><span class="line">        min_top: <span class="number">-1</span>,</span><br><span class="line">        stack: <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">20000</span>),</span><br><span class="line">        stack_top: <span class="number">-1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> (this.min_top == <span class="number">-1</span>)&#123;</span><br><span class="line">        this.min_top ++</span><br><span class="line">        this.minStack[this.min_top] = x</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> x &lt; this.minStack[this.min_top] &#123;</span><br><span class="line">        this.min_top ++</span><br><span class="line">        this.minStack[this.min_top] = x</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        this.min_top ++</span><br><span class="line">        tmp := this.min_top <span class="number">-1</span></span><br><span class="line">        this.minStack[this.min_top] = this.minStack[tmp]</span><br><span class="line">    &#125;</span><br><span class="line">    this.stack_top ++</span><br><span class="line">    this.stack[this.stack_top] = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop()  &#123;</span><br><span class="line">    this.min_top --</span><br><span class="line">    this.stack_top --</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.stack[this.stack_top]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Min() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.minStack[this.min_top]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="面试题-03-04-化栈为队-简单"><a href="#面试题-03-04-化栈为队-简单" class="headerlink" title="面试题 03.04. 化栈为队[简单]"></a>面试题 03.04. 化栈为队[简单]</h4><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<p>示例：</p>
<p>MyQueue queue &#x3D; new MyQueue();</p>
<p>queue.push(1);<br>queue.push(2);<br>queue.peek();  &#x2F;&#x2F; 返回 1<br>queue.pop();   &#x2F;&#x2F; 返回 1<br>queue.empty(); &#x2F;&#x2F; 返回 false</p>
<p>说明：</p>
<p>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。<br>通过次数9,923提交次数13,970</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci">https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h5><p>双栈,互相倒腾。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    top <span class="type">int</span></span><br><span class="line">    stack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MyQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyQueue&#123;</span><br><span class="line">        top: <span class="number">-1</span>,</span><br><span class="line">        stack: <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">1000</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Push(x <span class="type">int</span>)  &#123;</span><br><span class="line">    this.top ++</span><br><span class="line">    this.stack[this.top] = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Pop() <span class="type">int</span> &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>,this.top + <span class="number">1</span>)</span><br><span class="line">    tmp_top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := this.top;i &gt; <span class="number">0</span>;i--&#123;</span><br><span class="line">        tmp_top ++</span><br><span class="line">        tmp[tmp_top] = this.stack[this.top]</span><br><span class="line">        this.top --</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> this.top == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ret = this.stack[this.top]</span><br><span class="line">        this.top --</span><br><span class="line">        <span class="keyword">for</span> i:=tmp_top; i &gt;= <span class="number">0</span>; i--&#123;</span><br><span class="line">            this.top ++</span><br><span class="line">            this.stack[this.top] = tmp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Get the front element. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Peek() <span class="type">int</span> &#123;</span><br><span class="line">    tmp := <span class="built_in">make</span>([]<span class="type">int</span>,this.top + <span class="number">1</span>)</span><br><span class="line">    tmp_top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := this.top;i &gt; <span class="number">0</span>;i--&#123;</span><br><span class="line">        tmp_top ++</span><br><span class="line">        tmp[tmp_top] = this.stack[this.top]</span><br><span class="line">        this.top --</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> this.top == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ret = this.stack[this.top]</span><br><span class="line">        <span class="comment">// this.top --</span></span><br><span class="line">        <span class="keyword">for</span> i:=tmp_top; i &gt;= <span class="number">0</span>; i--&#123;</span><br><span class="line">            this.top ++</span><br><span class="line">            this.stack[this.top] = tmp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyQueue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.top == <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Peek();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="67-二进制求和-简单"><a href="#67-二进制求和-简单" class="headerlink" title="67. 二进制求和[简单]"></a>67. 二进制求和[简单]</h4><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p>
<p>输入为 非空 字符串且只包含数字 1 和 0。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: a &#x3D; “11”, b &#x3D; “1”<br>输出: “100”<br>示例 2:</p>
<p>输入: a &#x3D; “1010”, b &#x3D; “1011”<br>输出: “10101”
 </p>
<p>提示：</p>
<p>每个字符串仅由字符 ‘0’ 或 ‘1’ 组成。<br>1 &lt;&#x3D; a.length, b.length &lt;&#x3D; 10^4<br>字符串如果不是 “0” ，就都不含前导零。<br>通过次数126,044提交次数231,699</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-binary">https://leetcode-cn.com/problems/add-binary</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h5><p>跟链表的数字求和一样,拿出数据相加之后产生进位,需要在最后面处理进位。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addBinary</span><span class="params">(a <span class="type">string</span>, b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    aBit := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(a))</span><br><span class="line">    bBit := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(b))</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="built_in">len</span>(a)+<span class="built_in">len</span>(b))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">       d,_ := strconv.Atoi(<span class="type">string</span>(v))</span><br><span class="line">       aBit[i] = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> b &#123;</span><br><span class="line">        d,_ := strconv.Atoi(<span class="type">string</span>(v))</span><br><span class="line">        bBit[i] = d</span><br><span class="line">    &#125;</span><br><span class="line">    i,j := <span class="built_in">len</span>(a)<span class="number">-1</span>,<span class="built_in">len</span>(b)<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    tmpa := aBit[<span class="number">0</span>]</span><br><span class="line">    tmpb := bBit[<span class="number">0</span>]</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> || j &gt;=<span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">            tmpa = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmpa = aBit[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line">            tmpb = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tmpb = bBit[j]</span><br><span class="line">        &#125;</span><br><span class="line">        sum := tmpa + tmpb + carry</span><br><span class="line">        carry = sum / <span class="number">2</span></span><br><span class="line">        top ++</span><br><span class="line">        stack[top] = sum % <span class="number">2</span></span><br><span class="line">        i --</span><br><span class="line">        j --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        top ++</span><br><span class="line">        stack[top] = carry</span><br><span class="line">    &#125;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="type">rune</span>,top+<span class="number">1</span>)</span><br><span class="line">    stack_size := top</span><br><span class="line">    <span class="keyword">for</span> top &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        ret[stack_size - top] = <span class="type">rune</span>(<span class="number">48</span> + stack[top])</span><br><span class="line">        top --</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ret[:stack_size + <span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="125-验证回文串-简单"><a href="#125-验证回文串-简单" class="headerlink" title="125. 验证回文串[简单]"></a>125. 验证回文串[简单]</h4><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<p>示例 1:</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出: true<br>示例 2:</p>
<p>输入: “race a car”<br>输出: false<br>通过次数162,296提交次数350,208</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome">https://leetcode-cn.com/problems/valid-palindrome</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h5><p>数字和字母入栈,出栈和顺序读取的一致(忽略大小写)<br><strong>注意</strong>:字母和数字必须分开处理,比如<code>&quot;0P&quot;</code>,两者相差绝对值也是32,和A-a相差一样。数字只需要比较大小相等与否便可。但是字母类型必须比较大小写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == s &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(s))</span><br><span class="line">    top := <span class="number">-1</span></span><br><span class="line">    </span><br><span class="line">    tmp_s := <span class="built_in">make</span>([]<span class="type">rune</span>,<span class="built_in">len</span>(s))</span><br><span class="line">    index_tmp := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>) || (v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;=<span class="string">&#x27;z&#x27;</span>) || (v &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            top ++</span><br><span class="line">            stack[top] = v</span><br><span class="line">            </span><br><span class="line">            index_tmp ++</span><br><span class="line">            tmp_s[index_tmp] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;= top;i++&#123;</span><br><span class="line">        v := tmp_s[i]</span><br><span class="line">        tmp := stack[top - i]</span><br><span class="line">        <span class="keyword">if</span> (v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;=<span class="string">&#x27;z&#x27;</span>) || (v &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">            sub := math.Abs(<span class="type">float64</span>(tmp - v))</span><br><span class="line">            <span class="keyword">if</span> sub == <span class="number">0</span> || sub == <span class="number">32</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> v == tmp &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-最长公共前缀-简单"><a href="#14-最长公共前缀-简单" class="headerlink" title="14. 最长公共前缀[简单]"></a>14. 最长公共前缀[简单]</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 “”。</p>
<p>示例 1:</p>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br>示例 2:</p>
<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。<br>说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p>通过次数360,414提交次数929,974</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h5><p>递归,如果传进来的字符串数组刚好是2个,求出这两个的公共前缀。当传进的字符串数组的元素大于2的时候。先求出前两个字符串的公共前缀,然后再和剩余的组成新的字符串数组。再次调用求最长前缀的函数。注意递归出口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    prefix := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">2</span> &#123;</span><br><span class="line">        first := strs[<span class="number">0</span>]</span><br><span class="line">        second := strs[<span class="number">1</span>][:]</span><br><span class="line">        <span class="keyword">for</span> i,v := <span class="keyword">range</span> first &#123;</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(second)&#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="type">uint8</span>(v) == second[i] &#123;</span><br><span class="line">                    prefix += <span class="type">string</span>(v)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix</span><br><span class="line">    &#125;</span><br><span class="line">    prefix = longestCommonPrefix(strs[:<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> longestCommonPrefix(<span class="built_in">append</span>([]<span class="type">string</span>&#123;prefix&#125;,strs[<span class="number">2</span>:]...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="28-实现-strStr-简单"><a href="#28-实现-strStr-简单" class="headerlink" title="28. 实现 strStr()[简单]"></a>28. 实现 strStr()[简单]</h4><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>示例 1:</p>
<p>输入: haystack &#x3D; “hello”, needle &#x3D; “ll”<br>输出: 2<br>示例 2:</p>
<p>输入: haystack &#x3D; “aaaaa”, needle &#x3D; “bba”<br>输出: -1<br>说明:</p>
<p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<p>通过次数232,332提交次数584,964</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h5><p>两个循环进行对比,效率有点低。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="type">string</span>, needle <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == needle &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 思路,for循环,比较needle。完全匹配才可以</span></span><br><span class="line">    needle_ := needle[:]</span><br><span class="line">    haystack_ := haystack[:]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(haystack);i++&#123;</span><br><span class="line">        v := haystack_[i]</span><br><span class="line">        <span class="keyword">if</span> v == needle_[<span class="number">0</span>]&#123;</span><br><span class="line">            <span class="comment">// 开始进行匹配</span></span><br><span class="line">            j := i</span><br><span class="line">            index_needle := <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> index_needle &lt; <span class="built_in">len</span>(needle) &amp;&amp; j &lt; <span class="built_in">len</span>(haystack) &#123;</span><br><span class="line">                <span class="keyword">if</span> index_needle == <span class="built_in">len</span>(needle) <span class="number">-1</span> &amp;&amp; needle_[index_needle] == haystack_[j] &#123;</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> haystack_[j] != needle_[index_needle]  &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j ++</span><br><span class="line">                    index_needle ++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-59-I-滑动窗口的最大值-简单"><a href="#剑指-Offer-59-I-滑动窗口的最大值-简单" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值[简单]"></a>剑指 Offer 59 - I. 滑动窗口的最大值[简单]</h4><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p>
<p>示例:</p>
<p>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7
 </p>
<p>提示：</p>
<p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p>
<p>注意：本题与主站 239 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p>
<p>通过次数47,099提交次数106,161</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h5><p>大小为k的队列,出队和入队完成窗口滑动。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := math.MinInt32</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;Max(nums)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    slideWindows := <span class="built_in">make</span>([]<span class="type">int</span>,k)</span><br><span class="line">    baseMax := math.MinInt32</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums) - k + <span class="number">1</span>)</span><br><span class="line">    retIndex := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k &amp;&amp; i &lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; baseMax &#123;</span><br><span class="line">            baseMax = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        slideWindows[i] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    ret[retIndex] = baseMax</span><br><span class="line">    <span class="keyword">for</span> i:=k;i&lt;<span class="built_in">len</span>(nums);i++&#123;</span><br><span class="line">        slideWindows = <span class="built_in">append</span>(slideWindows[<span class="number">1</span>:],nums[i])</span><br><span class="line">        baseMax = Max(slideWindows)</span><br><span class="line">        retIndex ++</span><br><span class="line">        ret[retIndex] = baseMax</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="202-快乐数-简单"><a href="#202-快乐数-简单" class="headerlink" title="202. 快乐数[简单]"></a>202. 快乐数[简单]</h4><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p>
<p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p>
<p> </p>
<p>示例：</p>
<p>输入：19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>通过次数99,131提交次数163,443<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h5><p>不是快乐数的数称为不快乐数（unhappy number），所有不快乐数的数位平方和计算，最後都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中。最后出现重复值的就不是快乐数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    strn := strconv.FormatInt(<span class="type">int64</span>(n),<span class="number">10</span>)</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> strn&#123;</span><br><span class="line">        tmp,_ := strconv.Atoi(<span class="type">string</span>(v))</span><br><span class="line">        result += tmp * tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> result == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isHappy(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="38-外观数列-简单"><a href="#38-外观数列-简单" class="headerlink" title="38. 外观数列[简单]"></a>38. 外观数列[简单]</h4><p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
</li>
</ol>
<p>第一项是数字 1</p>
<p>描述前一项，这个数是 1 即 “一个 1 ”，记作 11</p>
<p>描述前一项，这个数是 11 即 “两个 1 ” ，记作 21</p>
<p>描述前一项，这个数是 21 即 “一个 2 一个 1 ” ，记作 1211</p>
<p>描述前一项，这个数是 1211 即 “一个 1 一个 2 两个 1 ” ，记作 111221</p>
<p> </p>
<p>示例 1:</p>
<p>输入: 1<br>输出: “1”<br>解释：这是一个基本样例。<br>示例 2:</p>
<p>输入: 4<br>输出: “1211”<br>解释：当 n &#x3D; 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 &#x3D; 1 而 值 &#x3D; 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。<br>通过次数130,187提交次数230,716<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say">https://leetcode-cn.com/problems/count-and-say</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h5><p>当前n输出的应该是n-1字符串相同的字符个数。<br>1 &#x3D;&gt; “1”<br>2 &#x3D;&gt; 数1,”1”。有1个字符”1”,所以输出为:”11”<br>3 &#x3D;&gt; 数2,”11”。有2个字符”1”,所以输出”21”<br>4 &#x3D;&gt; 数3,”21”。有1个字符”2”,1个字符”1”。所以输出”1211”<br>就是数上一个数字字符串中各个字符的个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    result := <span class="string">&quot;&quot;</span></span><br><span class="line">    tmpStr := countAndSay(n - <span class="number">1</span>)</span><br><span class="line">    tmp := tmpStr[:]</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    tmpChar := tmp[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// 数数</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(tmp); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> tmpChar == tmp[i] &#123;</span><br><span class="line">            <span class="comment">// 相同数字继续数</span></span><br><span class="line">            count ++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 出现不同</span></span><br><span class="line">            result += strconv.Itoa(count) + <span class="type">string</span>(tmpChar)</span><br><span class="line">            tmpChar = tmp[i]</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">0</span> &#123;</span><br><span class="line">        result += strconv.Itoa(count) + <span class="type">string</span>(tmpChar)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="69-x-的平方根-简单"><a href="#69-x-的平方根-简单" class="headerlink" title="69. x 的平方根[简单]"></a>69. x 的平方根[简单]</h4><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:</p>
<p>输入: 4<br>输出: 2<br>示例 2:</p>
<p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>     由于返回类型是整数，小数部分将被舍去。<br>通过次数204,672提交次数526,469</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h5><p>牛顿迭代法,二分法<br><strong>二分法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySqrt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    half := x/<span class="number">2</span></span><br><span class="line">    start := <span class="number">1</span></span><br><span class="line">    end := half</span><br><span class="line">    mid :=  (start + end) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> start * start == x &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> end * end == x &#123;</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> start*start &lt; x &amp;&amp; end * end &gt; x &amp;&amp; end - start == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        &#125;</span><br><span class="line">        mid = (start + end) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid * mid &lt; x &#123;</span><br><span class="line">            start = mid</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> half</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="204-计数质数-简单"><a href="#204-计数质数-简单" class="headerlink" title="204. 计数质数[简单]"></a>204. 计数质数[简单]</h4><p>统计所有小于非负整数 n 的质数的数量。</p>
<p>示例:</p>
<p>输入: 10<br>输出: 4<br>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。<br>通过次数77,573提交次数220,066</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes">https://leetcode-cn.com/problems/count-primes</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>厄拉多塞筛法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        boolean[] b = <span class="keyword">new</span> boolean[n];   <span class="comment">// 初始化默认值都为 false，为质数标记</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> &lt; n) result++; <span class="comment">// 如果大于 2 则一定拥有 2 这个质数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i += <span class="number">2</span>)&#123;  <span class="comment">// 从 3 开始遍历，且只遍历奇数</span></span><br><span class="line">            <span class="keyword">if</span>(!b[i])&#123;  <span class="comment">// 是质数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">3</span>; i * j &lt; n; j += <span class="number">2</span>)&#123;</span><br><span class="line">                    b[i * j] = <span class="literal">true</span>;    <span class="comment">// 将当前质数的奇数倍都设置成非质数标记 true</span></span><br><span class="line">                &#125;</span><br><span class="line">                result++;   <span class="comment">// 质数个数 +1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作者：cang-lang-a<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/solution/ting-shuo-zhe-jiao-e-la-duo-sai-shai-fa-zhi-xing-y/">https://leetcode-cn.com/problems/count-primes/solution/ting-shuo-zhe-jiao-e-la-duo-sai-shai-fa-zhi-xing-y/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countPrimes</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    count ++</span><br><span class="line">    arr := <span class="built_in">make</span>([]<span class="type">bool</span>,n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>;i &lt; n;i += <span class="number">2</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> !arr[i] &#123;</span><br><span class="line">            <span class="keyword">for</span> j:=<span class="number">3</span>;i*j &lt;n;j+= <span class="number">2</span>&#123;</span><br><span class="line">                arr[i*j] = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            count ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5503-所有奇数长度子数组的和-简单"><a href="#5503-所有奇数长度子数组的和-简单" class="headerlink" title="5503. 所有奇数长度子数组的和[简单]"></a>5503. 所有奇数长度子数组的和[简单]</h3><p>给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。</p>
<p>子数组 定义为原数组中的一个连续子序列。</p>
<p>请你返回 arr 中 所有奇数长度子数组的和 。</p>
<p>示例 1：</p>
<p>输入：arr &#x3D; [1,4,2,5,3]<br>输出：58<br>解释：所有奇数长度子数组和它们的和为：<br>[1] &#x3D; 1<br>[4] &#x3D; 4<br>[2] &#x3D; 2<br>[5] &#x3D; 5<br>[3] &#x3D; 3<br>[1,4,2] &#x3D; 7<br>[4,2,5] &#x3D; 11<br>[2,5,3] &#x3D; 10<br>[1,4,2,5,3] &#x3D; 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 &#x3D; 58<br>示例 2：</p>
<p>输入：arr &#x3D; [1,2]<br>输出：3<br>解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。<br>示例 3：</p>
<p>输入：arr &#x3D; [10,11,12]<br>输出：66</p>
<p>提示：</p>
<p>1 &lt;&#x3D; arr.length &lt;&#x3D; 100<br>1 &lt;&#x3D; arr[i] &lt;&#x3D; 1000</p>
<h4 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h4><p>滑动窗口,求值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumArray</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr&#123;</span><br><span class="line">        result += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOddLengthSubarrays</span><span class="params">(arr []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置滑动窗口</span></span><br><span class="line">    slide_window := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">1</span>)</span><br><span class="line">    slide_index := <span class="number">0</span></span><br><span class="line">    slide_size := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ;slide_size &lt;= <span class="built_in">len</span>(arr);slide_size += <span class="number">2</span>&#123;</span><br><span class="line">        slide_index = <span class="number">0</span></span><br><span class="line">        slide_window = <span class="built_in">make</span>([]<span class="type">int</span>,slide_size)</span><br><span class="line">        <span class="keyword">for</span> _,v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">            <span class="comment">// 先填充滑动窗口</span></span><br><span class="line">            <span class="keyword">if</span> slide_index &lt;= slide_size <span class="number">-1</span> &#123;</span><br><span class="line">                slide_window[slide_index] = v</span><br><span class="line">                slide_index ++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> slide_index == slide_size &#123;</span><br><span class="line">                <span class="comment">// 填满之后计算结果</span></span><br><span class="line">                result += sumArray(slide_window)</span><br><span class="line">                slide_window = <span class="built_in">append</span>(slide_window[<span class="number">1</span>:],<span class="number">0</span>)</span><br><span class="line">                slide_index -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="687-最长同值路径-简单"><a href="#687-最长同值路径-简单" class="headerlink" title="687. 最长同值路径[简单]"></a>687. 最长同值路径[简单]</h3><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p>示例 1:</p>
<p>输入:</p>
<pre><code>          5
         / \
        4   5
       / \   \
      1   1   5
</code></pre>
<p>输出:</p>
<p>2<br>示例 2:</p>
<p>输入:</p>
<pre><code>          1
         / \
        4   5
       / \   \
      4   4   5
</code></pre>
<p>输出:</p>
<p>2<br>注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p>
<p>通过次数23,601提交次数56,484</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path">https://leetcode-cn.com/problems/longest-univalue-path</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestUnivaluePath</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	res = <span class="number">0</span></span><br><span class="line">	dfs(root, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode, f <span class="type">int</span>, path <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">		l := dfs(root.Left, root.Val, path)  <span class="comment">//左树最长路径</span></span><br><span class="line">		r := dfs(root.Right, root.Val, path) <span class="comment">//右树最长路径</span></span><br><span class="line">		res = max(r+l, res)                  <span class="comment">//路径是否变长</span></span><br><span class="line">		<span class="keyword">if</span> f == root.Val &#123;                   <span class="comment">//相等时+1，并且选择l或r中最长路径</span></span><br><span class="line">			<span class="keyword">return</span> max(l, r) + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> <span class="comment">//其他情况全部返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作者：linbingyuan</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/longest-univalue-path/solution/kuai-bu-kuai-bu-zhi-dao-fan-zheng-dai-ma-gou-duan-/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br></pre></td></tr></table></figure>


<h3 id="剑指-Offer-10-I-斐波那契数列"><a href="#剑指-Offer-10-I-斐波那契数列" class="headerlink" title="剑指 Offer 10- I. 斐波那契数列"></a>剑指 Offer 10- I. 斐波那契数列</h3><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) &#x3D; 0,   F(1) &#x3D; 1<br>F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：1<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：5
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 100</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h4><p>直接使用递归会超时，需要使用备忘录以空间换时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;= n;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[i] = nums[i<span class="number">-1</span>]%<span class="number">1000000007</span> + nums[i<span class="number">-2</span>]%<span class="number">1000000007</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[n]%<span class="number">1000000007</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相同类型有</p>
<h3 id="剑指-Offer-10-II-青蛙跳台阶问题-简单"><a href="#剑指-Offer-10-II-青蛙跳台阶问题-简单" class="headerlink" title="剑指 Offer 10- II. 青蛙跳台阶问题[简单]"></a>剑指 Offer 10- II. 青蛙跳台阶问题[简单]</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>示例 2：</p>
<p>输入：n &#x3D; 7<br>输出：21<br>示例 3：</p>
<p>输入：n &#x3D; 0<br>输出：1<br>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 100<br>注意：本题与主站 70 题相同：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">https://leetcode-cn.com/problems/climbing-stairs/</a></p>
<p> </p>
<p>通过次数63,046提交次数149,366</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>,n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++&#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span>&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">2</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 后面的情况</span></span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>]%<span class="number">1000000007</span> + dp[i - <span class="number">2</span>]%<span class="number">1000000007</span>)%<span class="number">1000000007</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]%<span class="number">1000000007</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-06-汉诺塔问题-简单"><a href="#面试题-08-06-汉诺塔问题-简单" class="headerlink" title="面试题 08.06. 汉诺塔问题[简单]"></a>面试题 08.06. 汉诺塔问题[简单]</h3><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<p>示例1:</p>
<p> 输入：A &#x3D; [2, 1, 0], B &#x3D; [], C &#x3D; []<br> 输出：C &#x3D; [2, 1, 0]<br>示例2:</p>
<p> 输入：A &#x3D; [1, 0], B &#x3D; [], C &#x3D; []<br> 输出：C &#x3D; [1, 0]<br>提示:</p>
<p>A中盘子的数目不大于14个。<br>通过次数9,584提交次数14,970</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/hanota-lcci">https://leetcode-cn.com/problems/hanota-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(n <span class="type">int</span>, A *[]<span class="type">int</span>, B *[]<span class="type">int</span>, C *[]<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">// 一个盘子,只需要从A-&gt;C</span></span><br><span class="line">        *C = <span class="built_in">append</span>(*C,(*A)[<span class="built_in">len</span>(*A)<span class="number">-1</span>])</span><br><span class="line">        (*A) = (*A)[:<span class="built_in">len</span>(*A)<span class="number">-1</span>]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 2以上个盘子 A-&gt;B A-&gt;C B-&gt;C</span></span><br><span class="line">        move(n<span class="number">-1</span>,A,C,B)</span><br><span class="line">        move(<span class="number">1</span>,A,B,C)</span><br><span class="line">        move(n<span class="number">-1</span>,B,A,C)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hanota</span><span class="params">(A []<span class="type">int</span>, B []<span class="type">int</span>, C []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> A == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    move(<span class="built_in">len</span>(A),&amp;A,&amp;B,&amp;C)</span><br><span class="line">    <span class="keyword">return</span> C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-53-II-0～n-1中缺失的数字-简单"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字-简单" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字[简单]"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字[简单]</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [0,1,3]<br>输出: 2<br>示例 2:</p>
<p>输入: [0,1,2,3,4,5,6,7,9]<br>输出: 8
 </p>
<p>限制：</p>
<p>1 &lt;&#x3D; 数组长度 &lt;&#x3D; 10000</p>
<p>通过次数57,830提交次数131,564</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h4><p>由于有序，可以使用二分法。但是也可以使用等差数列求和公式。减一下便可以直到缺什么了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">len</span>(nums)*(<span class="built_in">len</span>(nums) + <span class="number">1</span>))/<span class="number">2</span> - sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    first,last,mid := <span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>,(<span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> first &lt;= last &#123;</span><br><span class="line">        mid = (first + last)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> mid == nums[mid] &#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last = mid <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="100-相同的树-简单"><a href="#100-相同的树-简单" class="headerlink" title="100. 相同的树[简单]"></a>100. 相同的树[简单]</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<p>输入:       1         1<br>          &#x2F; \       &#x2F; <br>         2   3     2   3</p>
<pre><code>    [1,2,3],   [1,2,3]
</code></pre>
<p>输出: true<br>示例 2:</p>
<p>输入:      1          1<br>          &#x2F;           <br>         2             2</p>
<pre><code>    [1,2],     [1,null,2]
</code></pre>
<p>输出: false<br>示例 3:</p>
<p>输入:       1         1<br>          &#x2F; \       &#x2F; <br>         2   1     1   2</p>
<pre><code>    [1,2,1],   [1,1,2]
</code></pre>
<p>输出: false<br>通过次数143,280提交次数238,182</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h4><p>递归，判断根节点，再判断左右子树</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p.Val == q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.Left,q.Left) &amp;&amp; isSameTree(p.Right,q.Right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="101-对称二叉树-简单"><a href="#101-对称二叉树-简单" class="headerlink" title="101. 对称二叉树[简单]"></a>101. 对称二叉树[简单]</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p> </p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<pre><code>1
</code></pre>
<p>   &#x2F; <br>  2   2<br> &#x2F; \ &#x2F; <br>3  4 4  3
 </p>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<pre><code>1
</code></pre>
<p>   &#x2F; <br>  2   2<br>   \   <br>   3    3
 </p>
<p>进阶：</p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<p>通过次数211,090提交次数398,394</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h4><p>和上一道题一样的思路。只是需要交换左右比较。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetricTrees</span><span class="params">(p *TreeNode,q *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> p ==<span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> p!= <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>  p.Val == q.Val &#123;</span><br><span class="line">            <span class="keyword">return</span> isSymmetricTrees(p.Left,q.Right) &amp;&amp; isSymmetricTrees(p.Right,q.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSymmetricTrees(root.Left,root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="104-二叉树的最大深度-简单"><a href="#104-二叉树的最大深度-简单" class="headerlink" title="104. 二叉树的最大深度[简单]"></a>104. 二叉树的最大深度[简单]</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回它的最大深度 3 。</p>
<p>通过次数280,411提交次数373,575<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h4><p>递归，如果该节点为空，返回0。否则返回1+子节点最大深度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a,b <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(maxDepth(root.Left),maxDepth(root.Right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="107-二叉树的层次遍历-II-简单"><a href="#107-二叉树的层次遍历-II-简单" class="headerlink" title="107. 二叉树的层次遍历 II[简单]"></a>107. 二叉树的层次遍历 II[简单]</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回其自底向上的层次遍历为：</p>
<p>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]<br>通过次数101,441提交次数150,113<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h4><p>递归,找到下一层的左右子数的层数。然后将相同层数的数据相加。返回上一层。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    left := levelOrderBottom(root.Left)</span><br><span class="line">    right := levelOrderBottom(root.Right)</span><br><span class="line">    i,j := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) || j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        layout := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(left)<span class="number">-1</span> - i) == (<span class="built_in">len</span>(right)<span class="number">-1</span> - j) &#123;</span><br><span class="line">            layout = <span class="built_in">append</span>(layout,left[i]...)</span><br><span class="line">            layout = <span class="built_in">append</span>(layout,right[j]...)</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,layout)</span><br><span class="line">            i ++</span><br><span class="line">            j ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">len</span>(left)<span class="number">-1</span> - i) &gt; (<span class="built_in">len</span>(right)<span class="number">-1</span> - j)&#123;</span><br><span class="line">            layout = <span class="built_in">append</span>(layout,left[i]...)</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,layout)</span><br><span class="line">            i ++</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            layout = <span class="built_in">append</span>(layout,right[j]...)</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,layout)</span><br><span class="line">            j ++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">append</span>(ret,[]<span class="type">int</span>&#123;root.Val&#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    left := levelOrderBottom(root.Left)</span><br><span class="line">    right := levelOrderBottom(root.Right)</span><br><span class="line">    i,j := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) || j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(left)<span class="number">-1</span> - i) == (<span class="built_in">len</span>(right)<span class="number">-1</span> - j) &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,<span class="built_in">append</span>(left[i],right[j]...))</span><br><span class="line">            i ++</span><br><span class="line">            j ++</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">len</span>(left)<span class="number">-1</span> - i) &gt; (<span class="built_in">len</span>(right)<span class="number">-1</span> - j)&#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,left[i])</span><br><span class="line">            i ++</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret,right[j])</span><br><span class="line">            j ++</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">append</span>(ret,[]<span class="type">int</span>&#123;root.Val&#125;)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="112-路径总和-简单"><a href="#112-路径总和-简单" class="headerlink" title="112. 路径总和[简单]"></a>112. 路径总和[简单]</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例: <br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h4><p>经过每个非叶子节点,将sum值减去当前节点的值。如果在叶子节点中等于传进去的sum。说明,这条路径的值加起来是最开始的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, sum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == sum &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    target := sum - root.Val</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.Left,target) || hasPathSum(root.Right,target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="113-路径总和-II-中等"><a href="#113-路径总和-II-中等" class="headerlink" title="113. 路径总和 II[中等]"></a>113. 路径总和 II[中等]</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre>
<p>返回:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]<br>通过次数89,764提交次数147,351</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii">https://leetcode-cn.com/problems/path-sum-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h4><p>和上一题一样,只不过需要找出所有可能。返回多值需要将当前节点写到递归的返回的所有数组的前面。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, sum <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; root.Val == sum &#123;</span><br><span class="line">        <span class="keyword">return</span> [][]<span class="type">int</span>&#123;&#123;root.Val&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target := sum - root.Val</span><br><span class="line">    left := pathSum(root.Left,target)</span><br><span class="line">    right := pathSum(root.Right,target)</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(left);i++&#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret,<span class="built_in">append</span>([]<span class="type">int</span>&#123;root.Val&#125;,left[i]...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>;i&lt;<span class="built_in">len</span>(right);i++&#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret,<span class="built_in">append</span>([]<span class="type">int</span>&#123;root.Val&#125;,right[i]...))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树-简单"><a href="#108-将有序数组转换为二叉搜索树-简单" class="headerlink" title="108. 将有序数组转换为二叉搜索树[简单]"></a>108. 将有序数组转换为二叉搜索树[简单]</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>  0
 / \
</code></pre>
<p>   -3   9<br>   &#x2F;   &#x2F;<br> -10  5</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h4><p>每次找中间的节点作为根,分到两边的高度不会超过1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(nums,<span class="number">0</span>, <span class="built_in">len</span>(nums) <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(nums []<span class="type">int</span>, first <span class="type">int</span>, last <span class="type">int</span>)</span></span> *TreeNode&#123;</span><br><span class="line">    <span class="keyword">if</span> first &gt; last &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    mid := (first +last) / <span class="number">2</span></span><br><span class="line">    root := TreeNode&#123;Val: nums[mid]&#125;</span><br><span class="line">    root.Left = dfs(nums, first, mid <span class="number">-1</span>)</span><br><span class="line">    root.Right = dfs(nums,mid +<span class="number">1</span> ,last)</span><br><span class="line">    <span class="keyword">return</span> &amp;root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="111-二叉树的最小深度-简单"><a href="#111-二叉树的最小深度-简单" class="headerlink" title="111. 二叉树的最小深度[简单]"></a>111. 二叉树的最小深度[简单]</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回它的最小深度  2.</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h5 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h5><p>每次选择最小的深度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x,y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y&#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == root.Left &amp;&amp; <span class="literal">nil</span> == root.Right &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    minDep := math.MaxInt32</span><br><span class="line">    <span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">        minDep = min(minDepth(root.Left), minDep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Right != <span class="literal">nil</span>&#123;</span><br><span class="line">        minDep =  min(minDepth(root.Right),minDep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDep + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="884-两句话中的不常见单词-简单"><a href="#884-两句话中的不常见单词-简单" class="headerlink" title="884. 两句话中的不常见单词[简单]"></a>884. 两句话中的不常见单词[简单]</h3><p>给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）</p>
<p>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。</p>
<p>返回所有不常用单词的列表。</p>
<p>您可以按任何顺序返回列表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：A &#x3D; “this apple is sweet”, B &#x3D; “this apple is sour”<br>输出：[“sweet”,”sour”]<br>示例 2：</p>
<p>输入：A &#x3D; “apple apple”, B &#x3D; “banana”<br>输出：[“banana”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; A.length &lt;&#x3D; 200<br>0 &lt;&#x3D; B.length &lt;&#x3D; 200<br>A 和 B 都只包含空格和小写字母。<br>通过次数12,606提交次数19,838</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/uncommon-words-from-two-sentences">https://leetcode-cn.com/problems/uncommon-words-from-two-sentences</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uncommonFromSentences</span><span class="params">(A <span class="type">string</span>, B <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> strings.Split(A, <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">        m1[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> strings.Split(B, <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">        m2[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := m2[k]; !ok&#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret,k)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m2 &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := m1[k]; !ok&#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret,k)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="205-同构字符串-简单"><a href="#205-同构字符串-简单" class="headerlink" title="205. 同构字符串[简单]"></a>205. 同构字符串[简单]</h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “egg”, t &#x3D; “add”<br>输出: true<br>示例 2:</p>
<p>输入: s &#x3D; “foo”, t &#x3D; “bar”<br>输出: false<br>示例 3:</p>
<p>输入: s &#x3D; “paper”, t &#x3D; “title”<br>输出: true<br>说明:<br>你可以假设 s 和 t 具有相同的长度。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/isomorphic-strings">https://leetcode-cn.com/problems/isomorphic-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h4><p>s-&gt;t 可以映射 t-&gt;s也可以完全映射才是同构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapping</span><span class="params">(s,t <span class="type">string</span>)</span></span> <span class="type">bool</span>  &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">uint8</span>]<span class="type">uint8</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span> ;i&lt; n;i ++&#123;</span><br><span class="line">        s1 := s[i]</span><br><span class="line">        t1 := t[i]</span><br><span class="line">        <span class="keyword">if</span> _, ok := map1[s1];ok &#123;</span><br><span class="line">            <span class="keyword">if</span> v,_ := map1[s1];v != t1 &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map1[s1] = t1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isIsomorphic</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> mapping(s, t) &amp;&amp; mapping(t, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="110-平衡二叉树-简单"><a href="#110-平衡二叉树-简单" class="headerlink" title="110. 平衡二叉树[简单]"></a>110. 平衡二叉树[简单]</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<pre><code>3
</code></pre>
<p>   &#x2F; <br>  9  20<br>    &#x2F;  <br>   15   7<br>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<pre><code>   1
  / \
 2   2
/ \
</code></pre>
<p>   3   3<br>  &#x2F; <br> 4   4<br>返回 false 。</p>
<p> </p>
<p>通过次数138,833提交次数254,069<br>在真实的面试中遇到过这道题？</p>
<p>是</p>
<p>否</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree">https://leetcode-cn.com/problems/balanced-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> *x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">height</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (abs(height(root.Left) - height(root.Right)) &lt;= <span class="number">1</span>) &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a>371. 两整数之和</h3><p>不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。</p>
<p>示例 1:</p>
<p>输入: a &#x3D; 1, b &#x3D; 2<br>输出: 3<br>示例 2:</p>
<p>输入: a &#x3D; -2, b &#x3D; 3<br>输出: 1<br>通过次数37,686提交次数66,902<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers">https://leetcode-cn.com/problems/sum-of-two-integers</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-6"><a href="#解法-6" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSum</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> b != <span class="number">0</span> &#123;</span><br><span class="line">        tmp := a ^ b</span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">        a = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="374-猜数字大小-简单"><a href="#374-猜数字大小-简单" class="headerlink" title="374. 猜数字大小[简单]"></a>374. 猜数字大小[简单]</h3><p>猜数字游戏的规则如下：</p>
<p>每轮游戏，系统都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，系统会告诉你，你猜测的数字比系统选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：</p>
<p>-1 : 你猜测的数字比系统选出的数字大<br> 1 : 你猜测的数字比系统选出的数字小<br> 0 : 恭喜！你猜对了！
 </p>
<p>示例 :</p>
<p>输入: n &#x3D; 10, pick &#x3D; 6<br>输出: 6<br>通过次数32,082提交次数70,063</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/guess-number-higher-or-lower">https://leetcode-cn.com/problems/guess-number-higher-or-lower</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-7"><a href="#解法-7" class="headerlink" title="解法"></a>解法</h4><p>二分法，没啥好说的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">guessNumber</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    first,last := <span class="number">1</span>, n</span><br><span class="line">    mid := (first + last) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> first &lt; last &#123;</span><br><span class="line">        <span class="keyword">if</span> guess(mid) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> guess(mid) &gt; <span class="number">0</span>&#123;</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            last = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        mid = (first + last) / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="383-赎金信-简单"><a href="#383-赎金信-简单" class="headerlink" title="383. 赎金信[简单]"></a>383. 赎金信[简单]</h3><p>给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。</p>
<p>(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)</p>
<p> </p>
<p>注意：</p>
<p>你可以假设两个字符串均只含有小写字母。</p>
<p>canConstruct(“a”, “b”) -&gt; false<br>canConstruct(“aa”, “ab”) -&gt; false<br>canConstruct(“aa”, “aab”) -&gt; true<br>通过次数29,988提交次数54,438<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ransom-note">https://leetcode-cn.com/problems/ransom-note</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h4><p>比较字母个数,杂志中各个字母的个数大于等于信中字母的个数肯定能够表达。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="type">string</span>, magazine <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">     <span class="comment">// 两个map,记录字母个数</span></span><br><span class="line">    rMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    mMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> ransomNote &#123;</span><br><span class="line">        rMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> magazine &#123;</span><br><span class="line">        mMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> rMap&#123;</span><br><span class="line">        <span class="keyword">if</span> mV,ok := mMap[k];ok &amp;&amp; mV &gt;= v&#123;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="387-字符串中的第一个唯一字符-简单"><a href="#387-字符串中的第一个唯一字符-简单" class="headerlink" title="387. 字符串中的第一个唯一字符[简单]"></a>387. 字符串中的第一个唯一字符[简单]</h3><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p> </p>
<p>示例：</p>
<p>s &#x3D; “leetcode”<br>返回 0</p>
<p>s &#x3D; “loveleetcode”<br>返回 2
 </p>
<p>提示：你可以假定该字符串只包含小写字母。</p>
<p>通过次数103,747提交次数219,598<br>在真实的面试中遇到过这道题？</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">https://leetcode-cn.com/problems/first-unique-character-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-8"><a href="#解法-8" class="headerlink" title="解法"></a>解法</h4><p>第一次循环,使用map记录字母出现的次数。第二次循环从头开始判断字母出现的次数。只出现一次的直接返回当前的字母的位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    numMap:= <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        numMap[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">       <span class="keyword">if</span> n,_ := numMap[v]; n == <span class="number">1</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> i</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="344-反转字符串-简单"><a href="#344-反转字符串-简单" class="headerlink" title="344. 反转字符串[简单]"></a>344. 反转字符串[简单]</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]<br>通过次数213,050提交次数290,237<br>在真实的面试中遇到过这道题？</p>
<p>是</p>
<p>否</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h4><p>两个指针,一个指向末尾,一个指向头部。两个指针交换数据,并且相互靠拢。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="type">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 思路,一个指向末尾的指针，一个指向首个地址的指针。相互交换数据</span></span><br><span class="line">    firstIndex,lastIndex := <span class="number">0</span>, <span class="built_in">len</span>(s) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> firstIndex &lt; lastIndex &#123;</span><br><span class="line">        tmp := s[firstIndex]</span><br><span class="line">        s[firstIndex] = s[lastIndex]</span><br><span class="line">        s[lastIndex] = tmp</span><br><span class="line">        firstIndex ++</span><br><span class="line">        lastIndex --</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="345-反转字符串中的元音字母-简单"><a href="#345-反转字符串中的元音字母-简单" class="headerlink" title="345. 反转字符串中的元音字母[简单]"></a>345. 反转字符串中的元音字母[简单]</h3><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：”hello”<br>输出：”holle”<br>示例 2：</p>
<p>输入：”leetcode”<br>输出：”leotcede”
 </p>
<p>提示：</p>
<p>元音字母不包含字母 “y” 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string">https://leetcode-cn.com/problems/reverse-vowels-of-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-9"><a href="#解法-9" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isVowel</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> c == <span class="string">&#x27;a&#x27;</span> || c==<span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c==<span class="string">&#x27;E&#x27;</span>  || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c==<span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c==<span class="string">&#x27;U&#x27;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseVowels</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line">    firstIndex,lastIndex := <span class="number">0</span>, <span class="built_in">len</span>(sb) <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> firstIndex &lt; lastIndex &#123;</span><br><span class="line">        <span class="keyword">if</span> isVowel(sb[firstIndex]) &amp;&amp; isVowel(sb[lastIndex])&#123;</span><br><span class="line">            tmp := sb[firstIndex]</span><br><span class="line">            sb[firstIndex] = sb[lastIndex]</span><br><span class="line">            sb[lastIndex] = tmp</span><br><span class="line">            firstIndex ++</span><br><span class="line">            lastIndex --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isVowel(sb[firstIndex]) &#123;</span><br><span class="line">            firstIndex ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !isVowel(sb[lastIndex]) &#123;</span><br><span class="line">            lastIndex --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(sb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加-简单"><a href="#415-字符串相加-简单" class="headerlink" title="415. 字符串相加[简单]"></a>415. 字符串相加[简单]</h3><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p>
<p> </p>
<p>提示：</p>
<p>num1 和num2 的长度都小于 5100<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零<br>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式<br>通过次数80,882提交次数156,004</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-strings">https://leetcode-cn.com/problems/add-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-65"><a href="#思路-65" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addStrings</span><span class="params">(num1 <span class="type">string</span>, num2 <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 从个位数开始相加,保存进位,一个个相加</span></span><br><span class="line">    num1B := []<span class="type">rune</span>(num1)</span><br><span class="line">    num2B := []<span class="type">rune</span>(num2)</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    l1,l2:= <span class="built_in">len</span>(num1)<span class="number">-1</span>,<span class="built_in">len</span>(num2)<span class="number">-1</span></span><br><span class="line">    resultB := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> l1 &gt;= <span class="number">0</span> || l2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        tmp1 := <span class="number">0</span></span><br><span class="line">        tmp2 := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> l1 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            tmp1,_ = strconv.Atoi(<span class="type">string</span>(num1B[l1]))</span><br><span class="line">            l1 --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> l2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">            tmp2, _ = strconv.Atoi(<span class="type">string</span>(num2B[l2]))</span><br><span class="line">            l2 --</span><br><span class="line">        &#125;</span><br><span class="line">        result := (tmp1 + tmp2 + carry) % <span class="number">10</span></span><br><span class="line">        carry = (tmp1 + tmp2 + carry) / <span class="number">10</span></span><br><span class="line">        resultB = <span class="built_in">append</span>([]<span class="type">rune</span>&#123;<span class="type">rune</span>(result + <span class="string">&#x27;0&#x27;</span>)&#125;, resultB...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry &gt; <span class="number">0</span> &#123;</span><br><span class="line">        resultB = <span class="built_in">append</span>([]<span class="type">rune</span>&#123;<span class="type">rune</span>(carry + <span class="string">&#x27;0&#x27;</span>)&#125;, resultB...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(resultB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="434-字符串中的单词数-简单"><a href="#434-字符串中的单词数-简单" class="headerlink" title="434. 字符串中的单词数[简单]"></a>434. 字符串中的单词数[简单]</h3><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p>示例:</p>
<p>输入: “Hello, my name is John”<br>输出: 5<br>解释: 这里的单词是指连续的不是空格的字符，所以 “Hello,” 算作 1 个单词。<br>通过次数23,778提交次数65,186</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-segments-in-a-string">https://leetcode-cn.com/problems/number-of-segments-in-a-string</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-10"><a href="#解法-10" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSegments</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    num := <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">    flag := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="string">&#x27; &#x27;</span> &amp;&amp; !flag &#123;</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">            num ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="459-重复的子字符串-简单"><a href="#459-重复的子字符串-简单" class="headerlink" title="459. 重复的子字符串[简单]"></a>459. 重复的子字符串[简单]</h3><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p>
<p>示例 1:</p>
<p>输入: “abab”</p>
<p>输出: True</p>
<p>解释: 可由子字符串 “ab” 重复两次构成。<br>示例 2:</p>
<p>输入: “aba”</p>
<p>输出: False<br>示例 3:</p>
<p>输入: “abcabcabcabc”</p>
<p>输出: True</p>
<p>解释: 可由子字符串 “abc” 重复四次构成。 (或者子字符串 “abcabc” 重复两次构成。)</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/repeated-substring-pattern">https://leetcode-cn.com/problems/repeated-substring-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路解法"><a href="#思路解法" class="headerlink" title="思路解法"></a>思路解法</h4><p>如果字符串由重复子串组成,那么重复的字串可以作为一种元素重复出现。假设s &#x3D; nx,x为字串。(n+1)x组成中,含有两个s。第一个从0开始,第二次从len(x)-1开始。比如s &#x3D; “abab”。其中x&#x3D;”ab”。s &#x3D; 2x &#x3D; “abab”,(2 + 1)x&#x3D;3x&#x3D; “ababab”。这个字符串中含有2个s。”abab-ab”,”ab-abab”。</p>
<p>2s &#x3D; 2(nx)&#x3D;(n+n)x,破坏掉第一个字符,找到的字符串s的位置是后面新加进去的字符串，说明该字符串不是由子字符串重复组成。如果由字串重复组成的话,找到s的位置肯定不是新加进来的。<br>比如:<br>s &#x3D; “aba”, 2s &#x3D; “abaaba”,破坏掉第一个字符串&#x3D;&gt;”baaba”,这个字符串中找到s的位置是新加进去的字符串。<br>s &#x3D; “abab”, 2s &#x3D; “abababab”,破坏掉第一个字符&#x3D;&gt;”bababab”,这个字符串中找到s的位置是在”b-abab-ab”,在”bab-abab”新加进来的字符串前面。说明这个字符串s由重复的字串组成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">repeatedSubstringPattern</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == s &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Index(<span class="type">string</span>((s+s)[<span class="number">1</span>:]), s) &lt; <span class="built_in">len</span>(s) <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="520-检测大写字母-简单"><a href="#520-检测大写字母-简单" class="headerlink" title="520. 检测大写字母[简单]"></a>520. 检测大写字母[简单]</h3><p>给定一个单词，你需要判断单词的大写使用是否正确。</p>
<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>
<p>全部字母都是大写，比如”USA”。<br>单词中所有字母都不是大写，比如”leetcode”。<br>如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</p>
<p>示例 1:</p>
<p>输入: “USA”<br>输出: True<br>示例 2:</p>
<p>输入: “FlaG”<br>输出: False<br>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/detect-capital">https://leetcode-cn.com/problems/detect-capital</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-66"><a href="#思路-66" class="headerlink" title="思路"></a>思路</h4><p>使用一个计数器和标记从头连续出现大写的指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCapitalUse</span><span class="params">(word <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(word) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    capitalNum := <span class="number">0</span></span><br><span class="line">    index := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> word&#123;</span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="string">&#x27;a&#x27;</span> &#123;</span><br><span class="line">            capitalNum ++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大写,只有第一个或者全为大写的时候才会变更index</span></span><br><span class="line">        <span class="keyword">if</span> v &lt; <span class="string">&#x27;a&#x27;</span> &amp;&amp; (i == <span class="number">0</span> || i == index)&#123;</span><br><span class="line">            index ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全大写,全小写,第一个为大写</span></span><br><span class="line">    <span class="keyword">return</span> capitalNum == <span class="built_in">len</span>(word) || capitalNum == <span class="number">0</span> || (capitalNum == <span class="number">1</span> &amp;&amp; index == <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="521-最长特殊序列-Ⅰ-简单"><a href="#521-最长特殊序列-Ⅰ-简单" class="headerlink" title="521. 最长特殊序列 Ⅰ[简单]"></a>521. 最长特殊序列 Ⅰ[简单]</h3><p>给你两个字符串，请你从这两个字符串中找出最长的特殊序列。</p>
<p>「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “aba”, “cdc”<br>输出: 3<br>解释: 最长特殊序列可为 “aba” (或 “cdc”)，两者均为自身的子序列且不是对方的子序列。<br>示例 2：</p>
<p>输入：a &#x3D; “aaa”, b &#x3D; “bbb”<br>输出：3<br>示例 3：</p>
<p>输入：a &#x3D; “aaa”, b &#x3D; “aaa”<br>输出：-1
 </p>
<p>提示：</p>
<p>两个字符串长度均处于区间 [1 - 100] 。<br>字符串中的字符仅含有 ‘a’~’z’ 。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i">https://leetcode-cn.com/problems/longest-uncommon-subsequence-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-11"><a href="#解法-11" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLUSlength</span><span class="params">(a <span class="type">string</span>, b <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a == b &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">len</span>(a), <span class="built_in">len</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="541-反转字符串-II-简单"><a href="#541-反转字符串-II-简单" class="headerlink" title="541. 反转字符串 II[简单]"></a>541. 反转字符串 II[简单]</h3><p>给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
 </p>
<p>示例:</p>
<p>输入: s &#x3D; “abcdefg”, k &#x3D; 2<br>输出: “bacdfeg”
 </p>
<p>提示：</p>
<p>该字符串只包含小写英文字母。<br>给定字符串的长度和 k 在 [1, 10000] 范围内。<br>通过次数22,935提交次数41,100<br>在真实的面试中遇到过这道题</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string-ii">https://leetcode-cn.com/problems/reverse-string-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-12"><a href="#解法-12" class="headerlink" title="解法"></a>解法</h4><p>0k 2k 4k 6k作为起始元素,长度为k的区间进行反转。如果长度不够k的话使用剩余的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseStr</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 按k分割, 0k 2k 4k 6k 8k 10k 反转</span></span><br><span class="line">    ret := []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="comment">// ab cd ef g</span></span><br><span class="line">    <span class="comment">// 0  2  4  6</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(ret) <span class="number">-1</span>;i += <span class="number">2</span>*k &#123;</span><br><span class="line">        l,r := i, min(i + k <span class="number">-1</span>, <span class="built_in">len</span>(ret) <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            tmp := ret[l]</span><br><span class="line">            ret[l] = ret[r]</span><br><span class="line">            ret[r] = tmp</span><br><span class="line">            l ++</span><br><span class="line">            r --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="551-学生出勤记录-I-简单"><a href="#551-学生出勤记录-I-简单" class="headerlink" title="551. 学生出勤记录 I[简单]"></a>551. 学生出勤记录 I[简单]</h3><p>给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：</p>
<p>‘A’ : Absent，缺勤<br>‘L’ : Late，迟到<br>‘P’ : Present，到场<br>如果一个学生的出勤记录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。</p>
<p>你需要根据这个学生的出勤记录判断他是否会被奖赏。</p>
<p>示例 1:</p>
<p>输入: “PPALLP”<br>输出: True<br>示例 2:</p>
<p>输入: “PPALLL”<br>输出: False<br>通过次数19,765提交次数38,039</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/student-attendance-record-i">https://leetcode-cn.com/problems/student-attendance-record-i</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-13"><a href="#解法-13" class="headerlink" title="解法"></a>解法</h4><p>遍历一遍字符串如果含有两个以上的A。直接返回false<br>然后再判断后面的L个数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkRecord</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    absentNum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;A&#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> absentNum &gt;= <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            absentNum ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !strings.Contains(s,<span class="string">&quot;LLL&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5543-两个相同字符之间的最长子字符串-简单"><a href="#5543-两个相同字符之间的最长子字符串-简单" class="headerlink" title="5543. 两个相同字符之间的最长子字符串[简单]"></a>5543. 两个相同字符之间的最长子字符串[简单]</h3><p>给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。</p>
<p>子字符串 是字符串中的一个连续字符序列。</p>
<p>示例 1：</p>
<p>输入：s &#x3D; “aa”<br>输出：0<br>解释：最优的子字符串是两个 ‘a’ 之间的空子字符串。<br>示例 2：</p>
<p>输入：s &#x3D; “abca”<br>输出：2<br>解释：最优的子字符串是 “bc” 。<br>示例 3：</p>
<p>输入：s &#x3D; “cbzxy”<br>输出：-1<br>解释：s 中不存在出现出现两次的字符，所以返回 -1 。<br>示例 4：</p>
<p>输入：s &#x3D; “cabbac”<br>输出：4<br>解释：最优的子字符串是 “abba” ，其他的非最优解包括 “bb” 和 “” 。</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>s 只含小写英文字母</p>
<h4 id="解法-14"><a href="#解法-14" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxLengthBetweenEqualCharacters</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 两个循环,计算相同元素之间的长度</span></span><br><span class="line">    tmp := []<span class="type">rune</span>(s)</span><br><span class="line">    maxLength := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(tmp); i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>;j &lt; <span class="built_in">len</span>(tmp); j++&#123;</span><br><span class="line">            <span class="keyword">if</span> tmp[i] == tmp[j] &#123;</span><br><span class="line">                <span class="keyword">if</span> j - i - <span class="number">1</span> &gt; maxLength &#123;</span><br><span class="line">                    maxLength = j - i - <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="557-反转字符串中的单词-III-简单"><a href="#557-反转字符串中的单词-III-简单" class="headerlink" title="557. 反转字符串中的单词 III[简单]"></a>557. 反转字符串中的单词 III[简单]</h3><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p> </p>
<p>示例：</p>
<p>输入：”Let’s take LeetCode contest”<br>输出：”s’teL ekat edoCteeL tsetnoc”
 </p>
<p>提示：</p>
<p>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-15"><a href="#解法-15" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ret := []<span class="type">rune</span>&#123;&#125;</span><br><span class="line">    arr := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i,v := <span class="keyword">range</span> arr&#123;</span><br><span class="line">        l,r := <span class="number">0</span>, <span class="built_in">len</span>(v) <span class="number">-1</span></span><br><span class="line">        tmpV := []<span class="type">rune</span>(v)</span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            tmp := tmpV[l]</span><br><span class="line">            tmpV[l] = tmpV[r]</span><br><span class="line">            tmpV[r] = tmp</span><br><span class="line">            l ++</span><br><span class="line">            r --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">len</span>(arr) <span class="number">-1</span> &#123;</span><br><span class="line">            tmpV = <span class="built_in">append</span>(tmpV, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, tmpV...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="606-根据二叉树创建字符串-简单"><a href="#606-根据二叉树创建字符串-简单" class="headerlink" title="606. 根据二叉树创建字符串[简单]"></a>606. 根据二叉树创建字符串[简单]</h4><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<p>示例 1:</p>
<p>输入: 二叉树: [1,2,3,4]<br>       1<br>     &#x2F;   <br>    2     3<br>   &#x2F;<br>  4     </p>
<p>输出: “1(2(4))(3)”</p>
<p>解释: 原本将是“1(2(4)())(3())”，<br>在你省略所有不必要的空括号对之后，<br>它将是“1(2(4))(3)”。<br>示例 2:</p>
<p>输入: 二叉树: [1,2,3,null,4]<br>       1<br>     &#x2F;   <br>    2     3<br>     \<br>      4 </p>
<p>输出: “1(2()(4))(3)”</p>
<p>解释: 和第一个示例相似，<br>除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-string-from-binary-tree">https://leetcode-cn.com/problems/construct-string-from-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-16"><a href="#解法-16" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tree2str</span><span class="params">(t *TreeNode)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == t &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> != t.Left &amp;&amp; <span class="literal">nil</span> != t.Right &#123;</span><br><span class="line">        <span class="keyword">return</span> strconv.Itoa(t.Val) +<span class="string">&quot;(&quot;</span> + tree2str(t.Left)+<span class="string">&quot;)&quot;</span> +<span class="string">&quot;(&quot;</span>+ tree2str(t.Right)+<span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="literal">nil</span> != t.Left &amp;&amp; <span class="literal">nil</span> == t.Right &#123;</span><br><span class="line">        <span class="keyword">return</span> strconv.Itoa(t.Val) +<span class="string">&quot;(&quot;</span>+ tree2str(t.Left)+ <span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="literal">nil</span> == t.Left &amp;&amp; <span class="literal">nil</span> != t.Right &#123;</span><br><span class="line">        <span class="keyword">return</span> strconv.Itoa(t.Val) + <span class="string">&quot;()&quot;</span>+ <span class="string">&quot;(&quot;</span> + tree2str(t.Right) +<span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strconv.Itoa(t.Val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="657-机器人能否返回原点-简单"><a href="#657-机器人能否返回原点-简单" class="headerlink" title="657. 机器人能否返回原点[简单]"></a>657. 机器人能否返回原点[简单]</h3><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。</p>
<p>移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p>
<p>注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: “UD”<br>输出: true<br>解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。<br>示例 2:</p>
<p>输入: “LL”<br>输出: false<br>解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。<br>通过次数68,477提交次数87,864</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/robot-return-to-origin">https://leetcode-cn.com/problems/robot-return-to-origin</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-17"><a href="#解法-17" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judgeCircle</span><span class="params">(moves <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    x,y := <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> moves &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;U&#x27;</span> &#123;</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> v == <span class="string">&#x27;D&#x27;</span> &#123;</span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> v == <span class="string">&#x27;L&#x27;</span> &#123;</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> v == <span class="string">&#x27;R&#x27;</span>&#123;</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="680-验证回文字符串-Ⅱ-简单"><a href="#680-验证回文字符串-Ⅱ-简单" class="headerlink" title="680. 验证回文字符串 Ⅱ[简单]"></a>680. 验证回文字符串 Ⅱ[简单]</h3><p>给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</p>
<p>示例 1:</p>
<p>输入: “aba”<br>输出: True<br>示例 2:</p>
<p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。<br>注意:</p>
<p>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。<br>通过次数54,238提交次数135,917</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii">https://leetcode-cn.com/problems/valid-palindrome-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-67"><a href="#思路-67" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome3</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">    right := <span class="built_in">len</span>(s) <span class="number">-1</span></span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; right; &#123;</span><br><span class="line">        <span class="keyword">if</span> sb[i] == sb[right] &#123;</span><br><span class="line">            right --</span><br><span class="line">            i ++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针,夹逼。</span></span><br><span class="line">    <span class="comment">// 出现不一致,尝试删除左边或者右边看是否相等</span></span><br><span class="line">    right := <span class="built_in">len</span>(s) <span class="number">-1</span></span><br><span class="line">    sb := []<span class="type">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; right ;&#123;</span><br><span class="line">        <span class="keyword">if</span> sb[i] == sb[right] &#123;</span><br><span class="line">            right --</span><br><span class="line">            i ++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去除左边数据</span></span><br><span class="line">            <span class="keyword">return</span> isPalindrome3(<span class="type">string</span>(sb[i+<span class="number">1</span>: right + <span class="number">1</span>])) || isPalindrome3(<span class="type">string</span>(sb[i: right]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="面试题-01-09-字符串轮转-简单"><a href="#面试题-01-09-字符串轮转-简单" class="headerlink" title="面试题 01.09. 字符串轮转[简单]"></a>面试题 01.09. 字符串轮转[简单]</h3><p>字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。</p>
<p>示例1:</p>
<p> 输入：s1 &#x3D; “waterbottle”, s2 &#x3D; “erbottlewat”<br> 输出：True<br>示例2:</p>
<p> 输入：s1 &#x3D; “aa”, s2 &#x3D; “aba”<br> 输出：False<br>提示：</p>
<p>字符串长度在[0, 100000]范围内。<br>说明:</p>
<p>你能只调用一次检查子串的方法吗？<br>通过次数15,931提交次数29,105</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-rotation-lcci">https://leetcode-cn.com/problems/string-rotation-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>超时答案</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFlipedString</span><span class="params">(s1 <span class="type">string</span>, s2 <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> s1 == s2 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    s1bytes := []<span class="type">rune</span>(s1)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s1bytes); i++&#123;</span><br><span class="line">        <span class="comment">// 轮转</span></span><br><span class="line">        tmp := s1bytes[:i+<span class="number">1</span>]</span><br><span class="line">        ret := s1bytes[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(tmp);j++ &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, tmp[j])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">string</span>(ret) == s2 &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只查询一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isFlipedString</span><span class="params">(s1 <span class="type">string</span>, s2 <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) != <span class="built_in">len</span>(s2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strings.Contains(s2+s2, s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="696-计数二进制子串-简单"><a href="#696-计数二进制子串-简单" class="headerlink" title="696. 计数二进制子串[简单]"></a>696. 计数二进制子串[简单]</h3><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<p>示例 1 :</p>
<p>输入: “00110011”<br>输出: 6<br>解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</p>
<p>请注意，一些重复出现的子串要计算它们出现的次数。</p>
<p>另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。<br>示例 2 :</p>
<p>输入: “10101”<br>输出: 4<br>解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。<br>注意：</p>
<p>s.length 在1到50,000之间。<br>s 只包含“0”或“1”字符。<br>通过次数40,719提交次数65,356</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings">https://leetcode-cn.com/problems/count-binary-substrings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>方法一：按字符分组<br>思路与算法</p>
<p>我们可以将字符串 ss 按照 00 和 11 的连续段分组，存在 \rm countscounts 数组中，例如 s &#x3D; 00111011s&#x3D;00111011，可以得到这样的 \rm countscounts 数组：{\rm counts} &#x3D; {2, 3, 1, 2}counts&#x3D;{2,3,1,2}。</p>
<p>这里 \rm countscounts 数组中两个相邻的数一定代表的是两种不同的字符。假设 \rm countscounts 数组中两个相邻的数字为 uu 或者 vv，它们对应着 uu 个 00 和 vv 个 11，或者 uu 个 11 和 vv 个 00。它们能组成的满足条件的子串数目为 \min { u, v }min{u,v}，即一对相邻的数字对答案的贡献。</p>
<p>我们只要遍历所有相邻的数对，求它们的贡献总和，即可得到答案。</p>
<p>不难得到这样的实现：</p>
<p>C++JavaJavaScriptGolangC</p>
<p>class Solution {<br>public:<br>    int countBinarySubstrings(string s) {<br>        vector<int> counts;<br>        int ptr &#x3D; 0, n &#x3D; s.size();<br>        while (ptr &lt; n) {<br>            char c &#x3D; s[ptr];<br>            int count &#x3D; 0;<br>            while (ptr &lt; n &amp;&amp; s[ptr] &#x3D;&#x3D; c) {<br>                ++ptr;<br>                ++count;<br>            }<br>            counts.push_back(count);<br>        }<br>        int ans &#x3D; 0;<br>        for (int i &#x3D; 1; i &lt; counts.size(); ++i) {<br>            ans +&#x3D; min(counts[i], counts[i - 1]);<br>        }<br>        return ans;<br>    }<br>};<br>这个实现的时间复杂度和空间复杂度都是 O(n)O(n)。</p>
<p>对于某一个位置 ii，其实我们只关心 i - 1i−1 位置的 \rm countscounts 值是多少，所以可以用一个 \rm lastlast 变量来维护当前位置的前一个位置，这样可以省去一个 \rm countscounts 数组的空间。</p>
<p>代码如下。</p>
<p>代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countBinarySubstrings</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ptr, last, ans <span class="type">int</span></span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> ptr &lt; n &#123;</span><br><span class="line">        c := s[ptr]</span><br><span class="line">        count := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ptr &lt; n &amp;&amp; s[ptr] == c &#123;</span><br><span class="line">            ptr++</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        ans += min(count, last)</span><br><span class="line">        last = count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)。<br>空间复杂度：O(1)O(1)。</p>
<p>作者：LeetCode-Solution<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-binary-substrings/solution/ji-shu-er-jin-zhi-zi-chuan-by-leetcode-solution/">https://leetcode-cn.com/problems/count-binary-substrings/solution/ji-shu-er-jin-zhi-zi-chuan-by-leetcode-solution/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="349-两个数组的交集-简单"><a href="#349-两个数组的交集-简单" class="headerlink" title="349. 两个数组的交集[简单]"></a>349. 两个数组的交集[简单]</h3><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]
 </p>
<p>说明：</p>
<p>输出结果中的每个元素一定是唯一的。<br>我们可以不考虑输出结果的顺序。<br>通过次数99,763提交次数140,489</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays">https://leetcode-cn.com/problems/intersection-of-two-arrays</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="思路-68"><a href="#思路-68" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersection</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums1&#123;</span><br><span class="line">        map1[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">        map2[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,_ := <span class="keyword">range</span> map1&#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := map2[k];ok &#123;</span><br><span class="line">            ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="350-两个数组的交集-II-简单"><a href="#350-两个数组的交集-II-简单" class="headerlink" title="350. 两个数组的交集 II[简单]"></a>350. 两个数组的交集 II[简单]</h3><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2,2]<br>示例 2:</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[4,9]
 </p>
<p>说明：</p>
<p>输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。<br>我们可以不考虑输出结果的顺序。<br>进阶：</p>
<p>如果给定的数组已经排好序呢？你将如何优化你的算法？<br>如果 nums1 的大小比 nums2 小很多，哪种方法更优？<br>如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？<br>通过次数149,241提交次数280,995</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-18"><a href="#解法-18" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intersect</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums1&#123;</span><br><span class="line">        map1[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums2 &#123;</span><br><span class="line">        map2[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v1 := <span class="keyword">range</span> map1&#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := map2[k];ok &#123;</span><br><span class="line">            v := v1</span><br><span class="line">            <span class="keyword">if</span> v1 &gt; v2 &#123;</span><br><span class="line">                v = v2</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> i := v; i &gt; <span class="number">0</span>; i--&#123;</span><br><span class="line">                ret = <span class="built_in">append</span>(ret, k)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="389-找不同-简单"><a href="#389-找不同-简单" class="headerlink" title="389. 找不同[简单]"></a>389. 找不同[简单]</h3><p>给定两个字符串 s 和 t，它们只包含小写字母。</p>
<p>字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 t 中被添加的字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “abcd”, t &#x3D; “abcde”<br>输出：”e”<br>解释：’e’ 是那个被添加的字母。<br>示例 2：</p>
<p>输入：s &#x3D; “”, t &#x3D; “y”<br>输出：”y”<br>示例 3：</p>
<p>输入：s &#x3D; “a”, t &#x3D; “aa”<br>输出：”a”<br>示例 4：</p>
<p>输入：s &#x3D; “ae”, t &#x3D; “aea”<br>输出：”a”
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>t.length &#x3D;&#x3D; s.length + 1<br>s 和 t 只包含小写字母<br>通过次数38,112提交次数59,839</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-difference">https://leetcode-cn.com/problems/find-the-difference</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-19"><a href="#解法-19" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTheDifference</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        map1[<span class="type">byte</span>(v)] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        map2[<span class="type">byte</span>(v)] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> map2&#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := map1[k];!ok || v != v2 &#123;</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="242-有效的字母异位词-简单"><a href="#242-有效的字母异位词-简单" class="headerlink" title="242. 有效的字母异位词[简单]"></a>242. 有效的字母异位词[简单]</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false<br>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>进阶:<br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p>通过次数148,132提交次数239,770</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram">https://leetcode-cn.com/problems/valid-anagram</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-20"><a href="#解法-20" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        map1[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> t &#123;</span><br><span class="line">        map2[v] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := map2[k]; !ok || v2 != v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> map2 &#123;</span><br><span class="line">        <span class="keyword">if</span> v2,ok := map1[k]; !ok || v2 != v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算字符个数"><a href="#计算字符个数" class="headerlink" title="计算字符个数"></a>计算字符个数</h3><p>题目描述<br>写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。</p>
<p>输入描述:<br>第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。</p>
<p>输出描述:<br>输出输入字符串中含有该字符的个数。</p>
<p>示例1<br>输入<br>复制<br>ABCDEF<br>A<br>输出<br>复制<br>1</p>
<h4 id="解法-21"><a href="#解法-21" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    input,_ := in.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    target,_ := in.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> input &#123;</span><br><span class="line">        map1[<span class="type">byte</span>(v)] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    v,_ := map1[target[<span class="number">0</span>]]</span><br><span class="line">    v2,_ := map1[target[<span class="number">0</span>] + <span class="number">32</span>]</span><br><span class="line">    v3,_ := map1[target[<span class="number">0</span>] - <span class="number">32</span>]</span><br><span class="line">    fmt.Println(v + v2 + v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="明明的随机数-华为练习题"><a href="#明明的随机数-华为练习题" class="headerlink" title="明明的随机数[华为练习题]"></a>明明的随机数[华为练习题]</h3><p>题目描述<br>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。</p>
<p>Input Param</p>
<p>n               输入随机数的个数</p>
<p>inputArray      n个随机整数组成的数组</p>
<p>Return Value</p>
<p>OutputArray    输出处理后的随机整数</p>
<p>注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。</p>
<p>当没有新的输入时，说明输入结束。</p>
<p>输入描述:</p>
<blockquote>
<p>注意：输入可能有多组数据。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的”示例”。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>返回多行，处理后的结果</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">11</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">40</span><br><span class="line">32</span><br><span class="line">67</span><br><span class="line">40</span><br><span class="line">20</span><br><span class="line">89</span><br><span class="line">300</span><br><span class="line">400</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">10</span><br><span class="line">15</span><br><span class="line">20</span><br><span class="line">32</span><br><span class="line">40</span><br><span class="line">67</span><br><span class="line">89</span><br><span class="line">300</span><br><span class="line">400</span><br></pre></td></tr></table></figure>
<p>说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">样例输入解释：</span><br><span class="line">样例有两组测试</span><br><span class="line">第一组是3个数字，分别是：2，2，1。</span><br><span class="line">第二组是11个数字，分别是：10，20，40，32，67，40，20，89，300，400，15。</span><br></pre></td></tr></table></figure>
<h4 id="解法-22"><a href="#解法-22" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    inputArray := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> str,err := in.ReadString(<span class="string">&#x27;\n&#x27;</span>); err == <span class="literal">nil</span>;str,err = in.ReadString(<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        str = strings.Replace(str,<span class="string">&quot;\r\n&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        str = strings.Replace(str, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;&quot;</span> == str&#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fmt.Printf(&quot;out = %q.\n&quot;, str)</span></span><br><span class="line">        i,_ := strconv.Atoi(str)</span><br><span class="line">        inputArray = <span class="built_in">append</span>(inputArray, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 1 2 3 2 1 2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inputArray);&#123;</span><br><span class="line">        tmp := inputArray[i + <span class="number">1</span> : i + inputArray[i] + <span class="number">1</span>]</span><br><span class="line">        sort.Ints(tmp)</span><br><span class="line">        index := <span class="number">0</span></span><br><span class="line">        fmt.Println(tmp[index])</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>;j&lt;<span class="built_in">len</span>(tmp);j++&#123;</span><br><span class="line">            <span class="keyword">if</span> tmp[index] != tmp[j] &#123;</span><br><span class="line">                index ++</span><br><span class="line">                tmp[index] = tmp[j]</span><br><span class="line">                fmt.Println(tmp[index])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + inputArray[i] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="字符串分割-华为练习题"><a href="#字符串分割-华为练习题" class="headerlink" title="字符串分割[华为练习题]"></a>字符串分割[华为练习题]</h3><p>题目描述<br>•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；<br>•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。<br>输入描述:<br>连续输入字符串(输入2次,每个字符串长度小于100)</p>
<p>输出描述:<br>输出到长度为8的新字符串数组</p>
<p>示例1<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc00000</span><br><span class="line">12345678</span><br><span class="line">90000000</span><br></pre></td></tr></table></figure>
<h4 id="思路-69"><a href="#思路-69" class="headerlink" title="思路"></a>思路</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">output</span><span class="params">(s <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    padding := <span class="number">8</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">        padding -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> padding == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println()</span><br><span class="line">            padding = <span class="number">8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> padding &gt; <span class="number">0</span> &amp;&amp; padding &lt; <span class="number">8</span> &#123;</span><br><span class="line">        fmt.Print(<span class="string">&quot;0&quot;</span>)</span><br><span class="line">        padding --</span><br><span class="line">        <span class="keyword">if</span> padding == <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := bufio.NewReader(os.Stdin)</span><br><span class="line">    str1,_ := in.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    str2,_ := in.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    str1 = strings.Replace(str1,<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">    str1 = strings.Replace(str1,<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    str2 = strings.Replace(str2,<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">    str2 = strings.Replace(str2,<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fmt.Println(str1)</span></span><br><span class="line">    <span class="comment">//fmt.Println(str2)</span></span><br><span class="line">    </span><br><span class="line">    output(str1)</span><br><span class="line">    output(str2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="290-单词规律-简单"><a href="#290-单词规律-简单" class="headerlink" title="290. 单词规律[简单]"></a>290. 单词规律[简单]</h3><p>给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</p>
<p>这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>示例1:</p>
<p>输入: pattern &#x3D; “abba”, str &#x3D; “dog cat cat dog”<br>输出: true<br>示例 2:</p>
<p>输入:pattern &#x3D; “abba”, str &#x3D; “dog cat cat fish”<br>输出: false<br>示例 3:</p>
<p>输入: pattern &#x3D; “aaaa”, str &#x3D; “dog cat cat dog”<br>输出: false<br>示例 4:</p>
<p>输入: pattern &#x3D; “abba”, str &#x3D; “dog dog dog dog”<br>输出: false<br>说明:<br>你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母</p>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-pattern">https://leetcode-cn.com/problems/word-pattern</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h4 id="解法-23"><a href="#解法-23" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordPattern</span><span class="params">(pattern <span class="type">string</span>, s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 分割字符串,先建立起pattern和s的映射,然后再进行顺序判断</span></span><br><span class="line">    patternMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">string</span>)</span><br><span class="line">    sMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">rune</span>)</span><br><span class="line">    </span><br><span class="line">    arr := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) != <span class="built_in">len</span>(pattern)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pattern &#123;</span><br><span class="line">        <span class="keyword">if</span> _,ok := patternMap[v];!ok &#123;</span><br><span class="line">            patternMap[v] = arr[i]</span><br><span class="line">            sMap[arr[i]] = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> pattern &#123;</span><br><span class="line">        <span class="keyword">if</span> v2, ok := sMap[arr[i]]; !ok || v2 != v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进制转换-华为"><a href="#进制转换-华为" class="headerlink" title="进制转换[华为]"></a>进制转换[华为]</h3><p>题目描述<br>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。</p>
<p>输入描述:</p>
<blockquote>
<p>输入一个十六进制的数值字符串。注意：一个用例会同时有多组输入数据，请参考帖子<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/276%E5%A4%84%E7%90%86%E5%A4%9A%E7%BB%84%E8%BE%93%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82">https://www.nowcoder.com/discuss/276处理多组输入的问题。</a></p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出该数值的十进制字符串。不同组的测试用例用\n隔开。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xA</span><br><span class="line">0xAA</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">170</span><br></pre></td></tr></table></figure>
<h4 id="解法-24"><a href="#解法-24" class="headerlink" title="解法"></a>解法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseStr</span><span class="params">(s <span class="type">string</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> hexMap = <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="string">&#x27;1&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;2&#x27;</span>:<span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;3&#x27;</span>:<span class="number">3</span>,</span><br><span class="line">        <span class="string">&#x27;4&#x27;</span>:<span class="number">4</span>,</span><br><span class="line">        <span class="string">&#x27;5&#x27;</span>:<span class="number">5</span>,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>:<span class="number">6</span>,</span><br><span class="line">        <span class="string">&#x27;7&#x27;</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="string">&#x27;8&#x27;</span>:<span class="number">8</span>,</span><br><span class="line">        <span class="string">&#x27;9&#x27;</span>:<span class="number">9</span>,</span><br><span class="line">        <span class="string">&#x27;0&#x27;</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&#x27;c&#x27;</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>: <span class="number">13</span>,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: <span class="number">13</span>,</span><br><span class="line">        <span class="string">&#x27;e&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">        <span class="string">&#x27;E&#x27;</span>: <span class="number">14</span>,</span><br><span class="line">        <span class="string">&#x27;f&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="string">&#x27;F&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    base := <span class="built_in">len</span>(s)</span><br><span class="line">    ret := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        tmp := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; base; i++ &#123;</span><br><span class="line">            tmp *= <span class="number">16</span></span><br><span class="line">        &#125;</span><br><span class="line">        d,_ := hexMap[v]</span><br><span class="line">        ret += d * tmp</span><br><span class="line">        base --</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   in := bufio.NewReader(os.Stdin)</span><br><span class="line">   <span class="keyword">for</span> str,err := in.ReadString(<span class="string">&#x27;\n&#x27;</span>);err == <span class="literal">nil</span>;str,err = in.ReadString(<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        str = strings.Replace(str, <span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        str = strings.Replace(str, <span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> str == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        parseStr(<span class="type">string</span>(str[<span class="number">2</span>:]))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://long95288.github.io/2019/08/11/基础算法/%20风兮木落%20基础算法"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/08/11/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%952/" title="基础算法2"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 基础算法2</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/08/10/springBootAop%E4%BD%BF%E7%94%A8/" title="springBootAop使用">Next post: springBootAop使用&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>