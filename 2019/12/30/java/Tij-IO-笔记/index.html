<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Tij-IO-笔记 · 风兮木落</title><meta name="description" content="File类目录列表器  查询一个文件夹中的文件数据，使用File类的list()函数获得该目录下的文件数据,返回String数组。包括普通的文件名称和文件夹。list()接收一个FilenameFilter的实现类实例来过滤获得相应的文件。  123public interface Filename"><meta name="og:description" content="File类目录列表器  查询一个文件夹中的文件数据，使用File类的list()函数获得该目录下的文件数据,返回String数组。包括普通的文件名称和文件夹。list()接收一个FilenameFilter的实现类实例来过滤获得相应的文件。  123public interface Filename"><meta name="twitter:site" content="风兮木落"><meta name="twitter:title" content="Tij-IO-笔记"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">long blogs</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">进一步有进一步惊喜</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://long95288.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Tij-IO-笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-12-30</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/java/" title="java">java</a><span>&nbsp;</span><a class="a-tag" href="/tags/IO/" title="IO">IO</a><span>&nbsp;</span></span></p><p class="post-abstract"><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h4 id="目录列表器"><a href="#目录列表器" class="headerlink" title="目录列表器"></a>目录列表器</h4><p>  查询一个文件夹中的文件数据，使用File类的<code>list()</code>函数获得该目录下的文件数据,返回String数组。包括普通的文件名称和文件夹。<code>list()</code>接收一个<code>FilenameFilter</code>的实现类实例来过滤获得相应的文件。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FilenameFilter</span>&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  如何使用该过滤器？当调用list函数的时候会调用该接口的accept()函数来判断是否保留该文件数据返回。每个文件都会调用该函数一次，自己在accept()函数里面设置规则，就可以获得相应的文件数据。</p>
<h4 id="目录的检查及创建"><a href="#目录的检查及创建" class="headerlink" title="目录的检查及创建"></a>目录的检查及创建</h4><p>  File代表的是一个文件或目录，文件的相关信息都可以使用File中的函数来获得。下面是常用的函数。</p>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getAbsolutePath()</td>
<td align="center">获得绝对路径,不会处理.和..</td>
</tr>
<tr>
<td align="center">getCanonicalPath()</td>
<td align="center">获得标准的绝对路径。将.和..解析之后返回路径</td>
</tr>
<tr>
<td align="center">canRead()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">canWrite()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">getName()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">getParent()</td>
<td align="center">解析File文件中路径的父路径。只是对构造文件对象时输入的path字符串</td>
</tr>
<tr>
<td align="center">getPath()</td>
<td align="center">获得文件路径，构造时传进来的文件路径</td>
</tr>
<tr>
<td align="center">length()</td>
<td align="center">返回文件的字节大小,long类型</td>
</tr>
<tr>
<td align="center">lastModified()</td>
<td align="center">上一次修改时间戳,long类型</td>
</tr>
<tr>
<td align="center">isFile()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">isDirectory()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">exists()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">createNewFile</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">renameTo(File f)</td>
<td align="center">重命名</td>
</tr>
<tr>
<td align="center">delete()</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">mkdirs()</td>
<td align="center">创建文件&#x2F;目录(可以多级创建)</td>
</tr>
<tr>
<td align="center">mkdir()</td>
<td align="center">仅一级创建。路径的上一个文件夹必须存在才能创建。</td>
</tr>
</tbody></table>
<p><code>getParent()</code>、<code>getName()</code>、<code>getPath()</code>、<code>getAbsolutePath()</code>、<code>getCanonicalPath()</code>的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.\\pom.xml&quot;</span>);</span><br><span class="line">System.out.println(f.getParent());</span><br><span class="line">System.out.println(f.getName());</span><br><span class="line">System.out.println(f.getPath());</span><br><span class="line">System.out.println(f.getAbsolutePath());</span><br><span class="line">System.out.println(f.getCanonicalPath());</span><br></pre></td></tr></table></figure>
<p>ouput:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">pom.xml</span><br><span class="line">.\pom.xml</span><br><span class="line">E:\Project\Java\.\pom.xml</span><br><span class="line">E:\Project\Java\pom.xml</span><br></pre></td></tr></table></figure>
<p><code>getParent()</code>获得的只是路径中的上一层,构造对象f时传进去的是<code>.\\pom.xml</code>。是对该字符串解析。如果直接使用<code>pom.xml</code>构造f对象,该函数返回的是空值。</p>
<p><code>mkdirs()</code>和<code>mkdir()</code><br>创建”E:\test\test1\test2\test3”嵌套目录,使用mkdirs()可以顺利创建。但是使用mkdir()如果文件夹组”E:\test\test1\test2”存在,成功创建。否则创建失败。</p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><h3 id="添加属性和有用的接口"><a href="#添加属性和有用的接口" class="headerlink" title="添加属性和有用的接口"></a>添加属性和有用的接口</h3><h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a><code>Reader</code>和<code>Writer</code></h3><h3 id="自我独立类-RandomAccessFile"><a href="#自我独立类-RandomAccessFile" class="headerlink" title="自我独立类:RandomAccessFile"></a>自我独立类:<code>RandomAccessFile</code></h3><h3 id="I-O流的典型使用方式"><a href="#I-O流的典型使用方式" class="headerlink" title="I&#x2F;O流的典型使用方式"></a>I&#x2F;O流的典型使用方式</h3><ul>
<li>缓冲输入文件。使用缓冲来提高文件的输入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String</span><br><span class="line"><span class="title function_">read</span><span class="params">(String filename)</span>&#123;</span><br><span class="line">  <span class="type">BufferReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferReader</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileReader</span>(filename)</span><br><span class="line">  );</span><br><span class="line">  String s;</span><br><span class="line">  <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">  <span class="keyword">while</span>(s = in.readLine() != <span class="literal">null</span>)&#123;</span><br><span class="line">    sb.append(s+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用如下代码是否更好？</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sb.append(s);</span></span><br><span class="line"><span class="comment">    sb.append(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">  in.close();</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从内存读取文件。将文件加载进内存中，然后再从内存中读取数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringReader</span>(</span><br><span class="line">  BufferedInputFile.read(filename)</span><br><span class="line">);</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="comment">// 从内存缓冲区读取文件的字节数据。</span></span><br><span class="line"><span class="keyword">while</span>((c = in.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">  System.out.print((<span class="type">char</span>)c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>格式化的内存输入。读取格式化的数据，不需要自己进行格式化处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputSteam</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(</span><br><span class="line">    BufferedInputFile.read(filename).getBytes()</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">while</span>(in.available() != <span class="number">0</span>)&#123;</span><br><span class="line">  System.out.print((<span class="type">char</span>)in.readBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文件输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 将内容输出到文件中</span></span><br><span class="line">out.println(str);</span><br></pre></td></tr></table></figure>
<ul>
<li>最简单的创建文件输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;Hello.java&quot;</span>;</span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(filename);</span><br></pre></td></tr></table></figure>
<ul>
<li>存储和恢复数据。目标是写进去的数据能够正确的读出来。需要统一的写和读，编码统一才可以读出来。使用DataInputStream和DataOutputSteam来进行文件的读写。<br>文件数据的读写。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">写</th>
<th align="center">读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">writeUTF()</td>
<td align="center">readUTF()</td>
</tr>
<tr>
<td align="center">writeDouble()</td>
<td align="center">readDouble()</td>
</tr>
</tbody></table>
<p>更多的类型数据读写可以参考JDK.</p>
<ul>
<li>读写随机文件。<br>使用RandomAccessFile 类来随机的读写文件。其它的输入输出流就只是从头开始读写，随机读写流可以使用seek()来读写文件。这是一个类似C中指针一样的东西，可以在特定的地方读写文件。但是这需要对文件的格式很熟悉才能定位到正确的地方。</li>
</ul>
<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I&#x2F;O"></a>标准I&#x2F;O</h3><p>  标准的I&#x2F;O中含有标准输入、标准输出、标准异常。在java中对应<code>System.in</code>、<code>System.out</code>、<code>System.err</code>。out和err已经被包装成PrintStream对象。</p>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">stdin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedRead</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)</span><br><span class="line">);</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span>((s = std.readLine()) != <span class="literal">null</span> &amp;&amp; s.length() != <span class="number">0</span>)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  可以使用Scanner来读出特定的类型。</p>
<h4 id="System-out转换成PrintWriter"><a href="#System-out转换成PrintWriter" class="headerlink" title="System.out转换成PrintWriter"></a>System.out转换成PrintWriter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true 自动清空</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(System.out,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="IO重定向。"><a href="#IO重定向。" class="headerlink" title="IO重定向。"></a>IO重定向。</h4><p>  标准IO一般默认是从控制台输入和输出的，但是可以通过重定向来改变标准IO的方向。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setIn(InputStream)</span><br><span class="line">System.setOut(PrintStream)</span><br><span class="line">System.setErr(PrintStream)</span><br></pre></td></tr></table></figure><br>  经过重定向之后就可以使用System.out、System.in、System.err。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>  在java中运行其它的程序。使用Process类来运行程序。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comnands 是运行命令的String[]</span></span><br><span class="line"><span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(commands).start();</span><br><span class="line"><span class="comment">// 获得运行的输出结果</span></span><br><span class="line"><span class="type">BufferedRead</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream()));</span><br><span class="line"><span class="comment">// 获得程序运行的错误</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">errors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getErrorStream()))</span><br></pre></td></tr></table></figure></p>
<h3 id="新的I-O"><a href="#新的I-O" class="headerlink" title="新的I&#x2F;O"></a>新的I&#x2F;O</h3><p>  nio不用太过在意,旧的IO已经用nio来实现过了。</p>
<h4 id="通道和缓冲器"><a href="#通道和缓冲器" class="headerlink" title="通道和缓冲器"></a>通道和缓冲器</h4><p>  唯一和通道交互得缓冲器为ByteBuffer。原始得字节形式输出和读取,没有办法输出和读取对象。也就是存进去得是什么，拿出来得也是什么。不会包装成String或者其它得对象。</p>
<h4 id="FileChannels-文件通道"><a href="#FileChannels-文件通道" class="headerlink" title="FileChannels 文件通道"></a>FileChannels 文件通道</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用文件通道写入数据</span></span><br><span class="line"><span class="type">FileChannels</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename).getChannel();</span><br><span class="line"><span class="comment">// 写入字节数组</span></span><br><span class="line">Byte[] bytes = <span class="string">&quot;Hello&quot;</span>.getBytes();</span><br><span class="line">fc.write(ByteBuffer.wrap(bytes));</span><br><span class="line">fc.close();</span><br><span class="line"><span class="comment">// 通过文件通道读取数据</span></span><br><span class="line">fc = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename).getChannel();</span><br><span class="line"><span class="comment">// 分配缓冲区大小</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buff</span> <span class="operator">=</span> ByteBuffer.allocate(SIZE);</span><br><span class="line">fc.read(buff);</span><br><span class="line"><span class="comment">// flip()作用是告诉外部,可以读取缓冲中的字节数据了。</span></span><br><span class="line">buff.flip();</span><br><span class="line"><span class="keyword">while</span>(buff.hasRemaining())&#123;</span><br><span class="line">  <span class="comment">// 将字节数据转成字符</span></span><br><span class="line">  System.out.print((<span class="type">char</span>)buff.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过通道来复制文件"><a href="#通过通道来复制文件" class="headerlink" title="通过通道来复制文件"></a>通过通道来复制文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量缓冲区的大小</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">BSIZE</span> <span class="operator">=</span> <span class="number">1024</span>;</span><br><span class="line"><span class="type">FileChannel</span></span><br><span class="line">  <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source).getChannel(),</span><br><span class="line">  out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel();</span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(BSIZE);</span><br><span class="line"><span class="keyword">while</span>(in.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// -1标志为读取数据结束</span></span><br><span class="line">  <span class="comment">// 准备好写</span></span><br><span class="line">  buffer.flip();</span><br><span class="line">  out.write(buffer);</span><br><span class="line">  <span class="comment">// 准备好读</span></span><br><span class="line">  buffer.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flip()表示ByteBuffer已经写完数据,你从ByteBuffer可以读出来了。<br>clear()表示ByteBuffer已经清空完数据了,你现在已经可以往ByteBuffer写数据了。<br>rewind() 返回到数据开始部分。</p>
<ul>
<li>两个通道相连除了通过上述中间变量之外，使用transferTo()和transFrom()可以将两个通道连起来。这两个不常用，知道就好。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in =&gt; out</span></span><br><span class="line">in.transferTo(<span class="number">0</span>,in.size(),out);</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="comment">// out.transferFrom(in,0,in.size());</span></span><br></pre></td></tr></table></figure>
<h5 id="转换数据"><a href="#转换数据" class="headerlink" title="转换数据"></a>转换数据</h5><p>  要想ByteBuffer存储有意义的数据，比如说字符串数据。需要写入字节之前对字符串进行编码，或者在读出的时候进行解码。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获得字节数据的时候编码</span><br><span class="line">&quot;hello world&quot;.getBytes(&quot;UTF-16BE&quot;);</span><br><span class="line">// 读取数据的时候解码</span><br><span class="line">buffer.asCharBuffer();</span><br></pre></td></tr></table></figure><br>  使用java.nio.charset.Charset来实现编码和解码。</p>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>  由于通道存储的只是字节数据。不方便进行读取和管理，这时候需要一个视图缓冲器来作为中间人让使用者直接读写为整型、字符、长整型、浮点、双精度浮点型。<br>  注意: 由于通道存储的是字节数据，转换成相应的数据类型会占用不同字节大小。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">字节大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">shorts</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">chars</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">ints</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">floats</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">longs</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
</tr>
</tbody></table>
<p>转换成Chars类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asCharBuffer();</span><br><span class="line"><span class="comment">// 读取Char数据</span></span><br><span class="line"><span class="keyword">while</span>(cb.hasRemaining())&#123;</span><br><span class="line">  System.out.print(cb.position() + <span class="string">&quot;-&gt;&quot;</span> + cb.get()+ <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中bb是一个ByteBuffer的对象。<br>同理转换成其它的类型的视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FloatBuffer</span> <span class="variable">fb</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asFloatBuffer();</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">ib</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asIntBuffer();</span><br><span class="line"><span class="type">ShortBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asShortBuffer();</span><br><span class="line"><span class="type">LongBuffer</span> <span class="variable">lb</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asLongBuffer();</span><br><span class="line"><span class="type">DoubleBuffer</span> <span class="variable">db</span> <span class="operator">=</span> ((ByteBuffer)bb.rewind()).asDoubleBuffer();</span><br></pre></td></tr></table></figure>
<h4 id="字节存放次序"><a href="#字节存放次序" class="headerlink" title="字节存放次序"></a>字节存放次序</h4><p>  有些基本的数据类型需要占用两个及两个以上的字节。计算机的基本存储单位是字节，对于像字符这种占用2个字节，存放有高位优先和低位优先两种方式。java默认的是高位优先。也就是说字符‘a’在内存中存放次序是[0,97]。如果是低位优先则是[97,0]。优先次序使用order来设置。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高位优先</span></span><br><span class="line">bb.order(ByteOrder.BIG_ENDIAN);</span><br><span class="line"><span class="comment">// 低位优先</span></span><br><span class="line">bb.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure><br>  字节存放次序并无优劣之分。重要的数据的一致性，存进去的和读出来的一致便可。</p>
<h4 id="交换相邻两个字符"><a href="#交换相邻两个字符" class="headerlink" title="交换相邻两个字符"></a>交换相邻两个字符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingBuffers</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">symmetricScramble</span><span class="params">(CharBuffer buffer)</span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (buffer.hasRemaining())&#123;</span><br><span class="line">           <span class="comment">// 做标记</span></span><br><span class="line">           buffer.mark();</span><br><span class="line">           <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">           <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> buffer.get();</span><br><span class="line">           <span class="comment">// 回到标记点</span></span><br><span class="line">           buffer.reset();</span><br><span class="line">           <span class="comment">// 交换次序存储</span></span><br><span class="line">           buffer.put(c2).put(c1);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] data = <span class="string">&quot;UsingBuffers&quot;</span>.toCharArray();</span><br><span class="line">        <span class="comment">// 一个字符占有两个字节</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> ByteBuffer.allocate(data.length*<span class="number">2</span>);</span><br><span class="line">        <span class="type">CharBuffer</span> <span class="variable">cb</span> <span class="operator">=</span> bb.asCharBuffer();</span><br><span class="line">        cb.put(data);</span><br><span class="line">        System.out.println(cb.rewind());</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.println(cb.rewind());</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        symmetricScramble(cb);</span><br><span class="line">        System.out.println(cb.rewind());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UsingBuffers</span><br><span class="line">sUniBgfuefsr</span><br><span class="line">UsingBuffers</span><br></pre></td></tr></table></figure>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>  使用“映射文件访问”更好，更高效。下面是使用传统的io流和通道map的读写对比差距。使用映射速度更加显著。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream Write:73.48 </span><br><span class="line">Mapped Write:0.02 </span><br><span class="line">Stream Read:0.06 </span><br><span class="line">Mapped Read:0.01 </span><br><span class="line">Stream Read/Write:6.05 </span><br><span class="line">Mapped Read/Write:0.01 </span><br></pre></td></tr></table></figure>
<p>使用mapped写数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;temp.tmp&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel();</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">ib</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line"><span class="comment">// 使用通道写入数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numOfInts; i++) &#123;</span><br><span class="line">    ib.put(i);</span><br><span class="line">&#125;</span><br><span class="line">fc.close();</span><br></pre></td></tr></table></figure>
<p>使用mapped读数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;temp.tmp&quot;</span>)).getChannel();</span><br><span class="line"><span class="type">IntBuffer</span> <span class="variable">ib</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_ONLY,<span class="number">0</span>,fc.size()).asIntBuffer();</span><br><span class="line"><span class="keyword">while</span> (ib.hasRemaining())&#123;</span><br><span class="line">    ib.get();</span><br><span class="line">&#125;</span><br><span class="line">fc.close();</span><br></pre></td></tr></table></figure>
<h4 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h4><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><h3 id="Preferences-Api"><a href="#Preferences-Api" class="headerlink" title="Preferences Api"></a><code>Preferences</code> Api</h3></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://long95288.github.io/2019/12/30/java/Tij-IO-笔记/%20风兮木落%20Tij-IO-笔记"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2020/01/01/read/%E9%82%A3%E4%BA%9B%E5%B9%B4%E8%AF%BB%E8%BF%87%E7%9A%84%E4%B9%A6/" title="那些年读过的书"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: 那些年读过的书</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/12/21/java/TiJ-String-%E7%AC%94%E8%AE%B0/" title="TiJ String 笔记">Next post: TiJ String 笔记&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>