<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>TiJ String 笔记 · 风兮木落</title><meta name="description" content="字符串1、不可变的String  每一个String对象都是不可变的，他们在创建的时候已经在内存中固定了。String对象的改变本质是拷贝一个当前的String的值然后完成修改后，生成新的String对象。这个新的对象和原来对象在内存中没有一丁点关系。是两个独立的对象
2、重载“+” 与String"><meta name="og:description" content="字符串1、不可变的String  每一个String对象都是不可变的，他们在创建的时候已经在内存中固定了。String对象的改变本质是拷贝一个当前的String的值然后完成修改后，生成新的String对象。这个新的对象和原来对象在内存中没有一丁点关系。是两个独立的对象
2、重载“+” 与String"><meta name="twitter:site" content="风兮木落"><meta name="twitter:title" content="TiJ String 笔记"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">long blogs</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">进一步有进一步惊喜</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://long95288.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>TiJ String 笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-12-21</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/Java/" title="Java">Java</a><span>&nbsp;</span><a class="a-tag" href="/tags/String/" title="String">String</a><span>&nbsp;</span></span></p><p class="post-abstract"><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1、不可变的String"><a href="#1、不可变的String" class="headerlink" title="1、不可变的String"></a>1、不可变的String</h4><p>  每一个String对象都是不可变的，他们在创建的时候已经在内存中固定了。String对象的改变本质是拷贝一个当前的String的值然后完成修改后，生成新的String对象。这个新的对象和原来对象在内存中没有一丁点关系。是两个独立的对象</p>
<h4 id="2、重载“-”-与StringBuilder"><a href="#2、重载“-”-与StringBuilder" class="headerlink" title="2、重载“+” 与StringBuilder"></a>2、重载“+” 与StringBuilder</h4><p>  Java 不允许程序员重载任何操作符。<code>&quot;Hello&quot; + &quot;World&quot;</code>本质是在编译器编译之后，生成一个<code>StringBuilder</code> 调用两次<code>append()</code>将<code>Hello</code>和<code>World</code>添加。最后使用<code>toString()</code>返回整合之后的字符串。如果使用<code>+</code>太多的话就会产生很多的String中间量。上述的Hello和World产生两个String的中间量。<br>  使用“+”编译器会自动将代码转换成StringBuilder对象。自动转换在循环内是会出现问题的，例如<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Good&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">  result += strs[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><br>  上述的代码会对循环内的每一个<code>+=</code>操作创建新的StringBuilder对象完成字符串的拼接。使用如下的代码会更加高效<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>,<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Good&quot;</span>&#125;;</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">  result.append(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.toString();</span><br></pre></td></tr></table></figure><br>  编译器自动编译有时候可能会愚蠢的优化代码。需要自己知道如何编写更加高效的代码。避开编译器的优化陷阱。<br>  <strong>StringBuilder为什么效率更高？</strong><br>  StringBuilder 会在内存中申请一个空间。这个空间可以自己指定也可以使用默认的。使用append()操作的时候就是在自己的空间内完成操作，一次申请，随意改变。String 对象是只读的。内存的申请和释放都是有代价的！！<br>  <strong>愚蠢的便捷</strong><br>  自己创建了一个StringBuilder然后在使用如下形式的函数<br>  <code>append(a + &quot;:&quot;+ b)</code>;<br>  这个有什么问题。编译器会帮你将<code>a+ &quot;:&quot; + b</code>部分新建一个StringBuilder对象来处理。这样就会得到两个字符串了。<br>  <strong>小结</strong></p>
<ul>
<li>StringBuilder常用的操作有<code>append()</code>和<code>toString()</code>.其它的还有<code>insert()、replace()、substring()、reverse()、delete()</code></li>
<li>StringBuilder和StringBuffer。前者线程不安全、后者线程安全。</li>
</ul>
<h4 id="3、无意识的递归"><a href="#3、无意识的递归" class="headerlink" title="3、无意识的递归"></a>3、无意识的递归</h4><p>  一个类A中的<code>toString()</code>的方法如下。为了输出该类当前实例对象的地址。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Class A address:&quot;</span> + <span class="built_in">this</span>+ <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  会产生异常，自动转换类型。将A类转换成String类。<code>+ this</code>会将this转换成String类。this指向A类，然后A又调用toString()方法来转换成String.递归的无出口。this -&gt; this.toString() -&gt; this -&gt; ….<br>  想要打印当前对象的地址使用<code>Object.toString()</code>.应该使用父类的toString() <code>super.toString()</code>。这样就不会出现死递归。</p>
<h4 id="4、String上的操作"><a href="#4、String上的操作" class="headerlink" title="4、String上的操作"></a>4、String上的操作</h4><p>  String常用的操作在自己的编程至今。最多的就是字符串的更改和比较。更改使用StringBuilder更加好。String比较最多的便是相等比较。</p>
<ul>
<li><code>equals(),equalsIgnoreCase()</code> 相等比较。<br>  使用<code>&quot;String&quot;.equals(a)</code>替换<code>a.equals(&quot;String&quot;)</code>。如果<code>a</code>是个null。调用<code>equals()</code>方法会出现问题。</li>
<li><code>length()</code> 字符串的长度</li>
<li><code>trim()</code> 去掉自字符串两端的空白字符</li>
</ul>
<p>  其它的操作有<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">charAt()</span><br><span class="line">getChars()</span><br><span class="line">getBytes()</span><br><span class="line">toCharArrary()</span><br><span class="line">compareTo()</span><br><span class="line">contains()</span><br><span class="line">contentEquals()</span><br><span class="line">regionMatcher()</span><br><span class="line">startWith()</span><br><span class="line">endsWith()</span><br><span class="line">indexOf(),lastIndexOf()</span><br><span class="line">substring()</span><br><span class="line">concat()</span><br><span class="line">replace()</span><br><span class="line">toLowerCase(),toUpperCase()</span><br><span class="line">valueOf()</span><br><span class="line">intern()</span><br></pre></td></tr></table></figure><br>  用的时候再查帮助手册</p>
<h4 id="5、格式化输出"><a href="#5、格式化输出" class="headerlink" title="5、格式化输出"></a>5、格式化输出</h4><h5 id="5-1-printf"><a href="#5-1-printf" class="headerlink" title="5.1 printf()"></a>5.1 printf()</h5><p>  使用<code>System.out.printf()</code>可以输出和C语言中的占位符。格式化输出.使用System.out.format()来替代。</p>
<h5 id="5-2-System-out-format"><a href="#5-2-System-out-format" class="headerlink" title="5.2 System.out.format()"></a>5.2 System.out.format()</h5><p>  <code>Sytem.out.format()</code> 可以使用%d,%s 等占位符</p>
<h5 id="5-3-Formatter类"><a href="#5-3-Formatter类" class="headerlink" title="5.3 Formatter类"></a>5.3 Formatter类</h5><p>  在Java中，Formatter类是一个翻译器。翻译格式化字符和数据，构造Formatter类时需要传递一个输出流，说明要向什么地方输出。</p>
<p>  向控制台输出<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Formatter</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Formatter</span>(System.out);</span><br><span class="line">f.format(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><br>  还可以使用<code>OutputStream</code>和<code>File</code>输出</p>
<h5 id="5-4-格式化说明符"><a href="#5-4-格式化说明符" class="headerlink" title="5.4 格式化说明符"></a>5.4 格式化说明符</h5><p>  格式化的语法<br>  <code>%[argument_index$][flag][width][.precision]conversion</code></p>
<ul>
<li>flag 是左右对齐标志，默认为右对齐。如果flag &#x3D; ‘-’ ;变成左对齐。</li>
<li>width 宽度，整数</li>
<li>.precision 精度。保留小数点后几位。如果String类型，输出字符的最大数量。浮点数，默认打印6位，但是可以自己指定。小数位多则舍入，少就补零。整数没有精度，在整数中使用精度会触发异常。</li>
<li>conversion 需要转换成的类型</li>
</ul>
<h5 id="5-5-Formatter转换"><a href="#5-5-Formatter转换" class="headerlink" title="5.5 Formatter转换"></a>5.5 Formatter转换</h5><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">整数型(十进制)</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">Unicode字符</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">Boolean值</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">String</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">浮点数（十进制）</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">浮点数(科学计数法)</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">整数(十进制)</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">散列码(16进制)</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">字符‘%’</td>
</tr>
</tbody></table>
<p>各种类型的适用字符</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">可用转换字符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符</td>
<td align="center">c、b、h</td>
</tr>
<tr>
<td align="center">整数</td>
<td align="center">d、c、b、s、x、h</td>
</tr>
<tr>
<td align="center">浮点数</td>
<td align="center">b、s、f、e、h</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">b、s、h</td>
</tr>
<tr>
<td align="center">布尔类型</td>
<td align="center">b、s、h</td>
</tr>
</tbody></table>
<p>b转换对于Boolean和boolean会对应true和false，但是对于其他的数据类型。只要不是null。对应转换的都是true,只要是null输出的是false</p>
<h5 id="5-6-String-format"><a href="#5-6-String-format" class="headerlink" title="5.6 String.format()"></a>5.6 String.format()</h5><p>  想要获得一个格式化的字符串，可以使用”+”和StringBuilder中的append()来构建。但是还有一个更加方便的方法。使用String.format()方法获得一个格式化的字符串。</p>
<h4 id="6、正则表达式"><a href="#6、正则表达式" class="headerlink" title="6、正则表达式"></a>6、正则表达式</h4><h5 id="6-1-基础"><a href="#6-1-基础" class="headerlink" title="6.1 基础"></a>6.1 基础</h5><p>  字符表</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">B</td>
<td align="center">指定字符B,可以是其他指定字符</td>
</tr>
<tr>
<td align="center">\xhh</td>
<td align="center">十六进制为oxhh的字符串</td>
</tr>
<tr>
<td align="center">\uhhh</td>
<td align="center">十六进制表示为oxhhhh的Unicode编码</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">标识符Tab</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">换行符</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">回车</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="center">换页</td>
</tr>
<tr>
<td align="center">\e</td>
<td align="center">转义</td>
</tr>
</tbody></table>
<p>字符类，字符类是最需要掌握的。掌握字符类之后便可以显示正则表达式的威力</p>
<table>
<thead>
<tr>
<th align="center">字符类</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="center">任意字符</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="center">包含a、b和c的任何字符。等价于a|b|c</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">除了a、b和c之外的任何字符</td>
</tr>
<tr>
<td align="center">[a-zA-Z]</td>
<td align="center">从a到z或A到Z的任何字符(范围)</td>
</tr>
<tr>
<td align="center">[abc[hij]]</td>
<td align="center">任意a、b、c、h、i和j的字符。等价于a&#124;b&#124;c&#124;h&#124;i&#124;j展开合并</td>
</tr>
<tr>
<td align="center">[a-z&amp;&amp;[hij]]</td>
<td align="center">任意h,i或j(交)</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">空白符(空格、tab、换行、换页和回车)</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="center">非空白字符,等价于[^\s]</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="center">数字[0-9]</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="center">非数字[^0-9]</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">词字符[a-zA-Z0-9]</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="center">非词字符[^\w]</td>
</tr>
</tbody></table>
<p>逻辑操作表</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">XY</td>
<td align="center">Y跟在X后面</td>
</tr>
<tr>
<td align="center">X&#124;Y</td>
<td align="center">X或Y</td>
</tr>
<tr>
<td align="center">(X)</td>
<td align="center">捕获组 (capturing group).可以在表达式中用\i引用第i个捕获组</td>
</tr>
</tbody></table>
<p>边界匹配表</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">一行的起始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">一行的结束</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="center">词的边界</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="center">非词的边界</td>
</tr>
<tr>
<td align="center">\G</td>
<td align="center">前一个匹配的结束</td>
</tr>
</tbody></table>
<h5 id="6-2-创建正则表达式"><a href="#6-2-创建正则表达式" class="headerlink" title="6.2 创建正则表达式"></a>6.2 创建正则表达式</h5><h5 id="6-3-量词"><a href="#6-3-量词" class="headerlink" title="6.3 量词"></a>6.3 量词</h5><p>  量词的主要作用的确定要怎么匹配，有贪婪型、勉强型、占有型。</p>
<p>  贪婪型|勉强型|占有型|如何匹配<br>  :-:|:-:|:-:|:-:|:-:<br>  X？|X??|X?+|一个或零个X<br>  X*|X*?|X?+|零个或多个X<br>  X+|X+?|X++| 一个或多个X<br>  X{n}|X{n}?|X{n}+| 恰好n次X<br>  X{n,}|X{n,}?|X{n,}+| 至少n次X<br>  X{n,m}|X{n,m}?|X{n,m}| X至少n次,且不超过m次</p>
<h5 id="6-4-Pattern和Matcher"><a href="#6-4-Pattern和Matcher" class="headerlink" title="6.4 Pattern和Matcher"></a>6.4 Pattern和Matcher</h5><ul>
<li><p>字符串匹配正则表达式，可以使用<code>String.matches(pattern)</code>.例如<br>  <code>&quot;Rudolph&quot;.matches(pattern)</code>其中pattern为<code>String pattern = &quot;[rR]udolph&quot;</code></p>
</li>
<li><p>使用正则表达式的对象处理</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;afafafafagavawe&quot;</span>;</span><br><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> <span class="string">&quot;[af]ag&quot;</span>:</span><br><span class="line"><span class="comment">// 正则表达式对象</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.complile(str);</span><br><span class="line"><span class="comment">// 匹配对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(pattern);</span><br></pre></td></tr></table></figure>
<p>  <strong>matcher常用方法</strong></p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">boolean matches()</td>
<td align="center">整个输入字符串是否匹配正则表达式模式</td>
</tr>
<tr>
<td align="center">boolean lookAt()</td>
<td align="center">判断该字符串的始部分是否能够匹配模式</td>
</tr>
<tr>
<td align="center">boolean find()</td>
<td align="center">查找多个匹配,每调用一次就会自动向前迭代。</td>
</tr>
<tr>
<td align="center">boolean find(i)</td>
<td align="center">查找特定索引的匹配，指定开始搜索的位置</td>
</tr>
<tr>
<td align="center">int groupCount()</td>
<td align="center">该匹配器中的分组数目</td>
</tr>
<tr>
<td align="center">String group(int i)</td>
<td align="center">返回前一次匹配的指定的组号，没有返回null。没有group(0)等价于group()</td>
</tr>
<tr>
<td align="center">int start(int group)</td>
<td align="center">返回在前一次匹配操作中寻找到的组的起始索引</td>
</tr>
<tr>
<td align="center">int end(int group)</td>
<td align="center">返回在前一次匹配操作中寻找到的组的最后一个字符串索引加一的值。注意是加一!!</td>
</tr>
</tbody></table>
<p>  <strong>pattern标记</strong><br>  <code>Pattern Pattern.compile(String regex, int flag);</code><br>  标记的作用的是设定特定模式的匹配规则，.是否匹配行终结符，是否考虑字符串的大小写等。</p>
<h5 id="6-5-split"><a href="#6-5-split" class="headerlink" title="6.5 split()"></a>6.5 split()</h5><p>  和String.split()分隔字符串有相同的作用<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot;This is unusual use!!of exclamtion!!points&quot;</span>:</span><br><span class="line">Pattern.compile(<span class="string">&quot;!!&quot;</span>).split(input);</span><br><span class="line">Pattern.complie(<span class="string">&quot;!!&quot;</span>).split(input,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><br>  <code>String[] split(CharSequence input);</code><br>  &#x2F;&#x2F; limit 分成几个部分<br>  <code>String[] split(CharSequence input,int limit);</code></p>
<h5 id="6-6-替换操作"><a href="#6-6-替换操作" class="headerlink" title="6.6 替换操作"></a>6.6 替换操作</h5><ul>
<li>replaceFirst(String replacement)</li>
<li>replaceAll(String replacement)</li>
<li>appendReplacement(StringBuffer sbuf,String replacement) 渐进制替换</li>
<li>appendTail(StringBuffer sbuf);<br>  说明StringBuffer sbuf是存最后的结果的。这种编程模式将输入参数作为输出参数。</li>
</ul>
<h5 id="6-7-reset"><a href="#6-7-reset" class="headerlink" title="6.7 reset()"></a>6.7 reset()</h5><p>  通过reset() 方法，可以将现有的Matcher对象应用于一个新的字符串序列。简单来说就是替换掉找到的matcher对象的值。</p>
<h5 id="6-8-正则表达式与Java-I-O"><a href="#6-8-正则表达式与Java-I-O" class="headerlink" title="6.8 正则表达式与Java I&#x2F;O"></a>6.8 正则表达式与Java I&#x2F;O</h5><p>  核心思想,读取文件中的文件，按照行数生成一个字符串数组。然后再对这字符串数组进行正则表达式处理。先读取完成再处理会比边读取边处理效率更高。</p>
<h4 id="7、扫描输入"><a href="#7、扫描输入" class="headerlink" title="7、扫描输入"></a>7、扫描输入</h4><p>  Scanner 的构造器可以接收File对象，InputStream,String或者Readable对象。除了char类型外，其它的基本数据类型都有相应的next方法。hasNext方法判断下一个输入分词是否有相应的数据类型。</p>
<h5 id="7-1-Scanner定界符"><a href="#7-1-Scanner定界符" class="headerlink" title="7.1 Scanner定界符"></a>7.1 Scanner定界符</h5><p>  默认情况下，Scanner的是使用空白字符作为定界符的。也可以使用正则表达式指定自己的所需的定界符。需要使用useDelimiter(),例如:<br>  <code>scanner.useDelimiter(&quot;\\s*,\\s*&quot;);</code><br>  使用逗号作为分界符。</p>
<h5 id="7-2-用正则表达式扫描"><a href="#7-2-用正则表达式扫描" class="headerlink" title="7.2 用正则表达式扫描"></a>7.2 用正则表达式扫描</h5><p>  使用scanner的next()方法可以使用正则表达式来获得相应的匹配，使用<code>scanner.match()</code>获得匹配的数据。<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scanner.next(pattern);</span><br><span class="line"><span class="type">MatcherResult</span> <span class="variable">match</span> <span class="operator">=</span> scanner.match();</span><br><span class="line"><span class="comment">// 获得匹配的第一个数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data1</span> <span class="operator">=</span> match.group(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获得匹配的第二个数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">data2</span> <span class="operator">=</span> match.group(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>  配合使用正则表达式扫描时，仅仅针对下一个输入分词进行匹配。如果正则表达式中含有定界符，那永远都不可能匹配成功。&#x2F;&#x2F;因为扫描分词的时候已经将定界符处理了,已经按照定界符处理过了，得到的数据里面一定没有定界符。在得到的数据里面使用定界符进行匹配一定找不到数据。</p>
<h4 id="8、StringTokenizer"><a href="#8、StringTokenizer" class="headerlink" title="8、StringTokenizer"></a>8、StringTokenizer</h4><p>  这是是没有引入Scanner类的时候对字符串的处理，但是现在已经有Scanner类了，StringTokenizer可以认为废弃了。功能什么的都不比Scanner+正则表达式强大。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://long95288.github.io/2019/12/21/TiJ-String-笔记/%20风兮木落%20TiJ String 笔记"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/12/30/Tij-IO-%E7%AC%94%E8%AE%B0/" title="Tij-IO-笔记"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Tij-IO-笔记</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/11/23/PyQt5-QSS-%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8/" title="PyQt5 QSS 样式的使用">Next post: PyQt5 QSS 样式的使用&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>