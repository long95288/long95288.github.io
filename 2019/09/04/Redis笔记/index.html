<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Redis笔记 · 风兮木落</title><meta name="description" content="Redis拿来干什么？ redis是运行在内存的软件。速度快，完全基于内存。使用C语言实现，网络层使用epoll解决高并发问题。单线程模型，避免不必要的上下文切换和竞争条件浪费资源。Redis可以用在下面的场景。1、缓存。常用的功能2、数据排序 使用Redis的SortSet数据结构能够非常方便搞定"><meta name="og:description" content="Redis拿来干什么？ redis是运行在内存的软件。速度快，完全基于内存。使用C语言实现，网络层使用epoll解决高并发问题。单线程模型，避免不必要的上下文切换和竞争条件浪费资源。Redis可以用在下面的场景。1、缓存。常用的功能2、数据排序 使用Redis的SortSet数据结构能够非常方便搞定"><meta name="twitter:site" content="风兮木落"><meta name="twitter:title" content="Redis笔记"><meta name="twitter:card" content="summary"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/">long blogs</a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">进一步有进一步惊喜</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://long95288.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Redis笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2019-09-04</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/笔记/" title="笔记">笔记</a><span>&nbsp;</span><a class="a-tag" href="/tags/spring/" title="spring">spring</a><span>&nbsp;</span></span></p><p class="post-abstract"><h3 id="Redis拿来干什么？"><a href="#Redis拿来干什么？" class="headerlink" title="Redis拿来干什么？"></a>Redis拿来干什么？</h3><p> redis是运行在内存的软件。速度快，完全基于内存。使用C语言实现，网络层使用epoll解决高并发问题。单线程模型，避免不必要的上下文切换和竞争条件浪费资源。Redis可以用在下面的场景。<br>1、缓存。常用的功能<br>2、数据排序 使用Redis的SortSet数据结构能够非常方便搞定<br>3、计算器&#x2F;请求限流 秒杀的时候,将数据缓存在Redis中。减少数据库的频繁读写。<br>4、使用集合的命令获得相关的数据<br>5、简单的消息队列。使用Redis的list实现消息队列<br>6、Session共享、token实现单点验证</p>
<h3 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h3><p>Redis提供8种数据类型，常用的主要是String、Hash、List、Set、SortSet这5种类型。另外还有BitMap-位图、HyperLogLog、GEO-地理信息定位。<br>存储的为Key-Value的值。</p>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><p>  <a target="_blank" rel="noopener" href="http://doc.redisfans.com/index.html">中文Redis命令翻译网址</a></p>
<h4 id="1、基本操作"><a href="#1、基本操作" class="headerlink" title="1、基本操作"></a>1、基本操作</h4><ul>
<li>启动Redis<br><code>./redis-server ../redis.conf</code></li>
<li>启动Redis的脚本工具<br><code>./redis-cli</code></li>
<li>存储数据的命令<br><code>&gt; set mykey myvalue</code><br>使用set语句 后面加上key值和value值</li>
<li>查看是否含有某个key值<br><code>&gt; exists mykey</code><br>如果存在返回1 如果不存在返回0</li>
<li>获得key值对应的value<br><code>&gt; get mykey</code></li>
<li>查看key值对应的数据类型<br><code>&gt; type mykey</code><br>如果是字符型返回string</li>
<li>使用正则匹配查找对应的数据<br><code>&gt; keys my*</code><br>查找含有my开头的key。查到返回对应的key列表。找不到返回empty list or set</li>
<li>删除对应的key值<br><code>&gt; del key</code><br>也可以使用正则匹配来删除<br><code>&gt; del key*</code></li>
<li>随机获得一个key<br><code>&gt; randomkey</code></li>
<li>清除所有的key值<br><code>&gt; clear</code></li>
<li>重命名key值<br><code>&gt; rename newkey oldkey</code></li>
<li>查看当前的数据库的大小<br><code>&gt; dbsize</code></li>
</ul>
<h4 id="2、Redis时间过期相关的命令"><a href="#2、Redis时间过期相关的命令" class="headerlink" title="2、Redis时间过期相关的命令"></a>2、Redis时间过期相关的命令</h4><ul>
<li>限定key的生存时间<br><code>&gt; expire key 20</code>设置key值20秒后过期</li>
<li>查看过期时间<br><code>&gt; ttl key</code> 查看key的值还有多少秒过期<br>过期后会返回-2</li>
<li>清除整个db<br><code>&gt; flushdb</code><br><code>&gt; flushall</code></li>
</ul>
<h4 id="3、配置Redis的命令"><a href="#3、配置Redis的命令" class="headerlink" title="3、配置Redis的命令"></a>3、配置Redis的命令</h4><ul>
<li>配置requirepass<br>获得账号名<br><code>&gt; config get requirepass</code><br>设置密码<br><code>&gt; config set requirepass test123</code></li>
<li>使用密码验证<br><code>&gt; auth test123</code><br>重新查看账号<br><code>&gt; config get requirepass</code><br>返回值如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;test123&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得实体存储的相关命令<br><code>&gt; config get *max-*-entries*</code><br>返回的数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;hash-max-ziplist-entries&quot;</span><br><span class="line">2) &quot;512&quot;</span><br><span class="line">3) &quot;set-max-intset-entries&quot;</span><br><span class="line">4) &quot;512&quot;</span><br><span class="line">6) &quot;zset-max-ziplist-entries&quot;</span><br><span class="line">7) &quot;128&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>重置配置<br><code>&gt; config resetstat</code></li>
<li>服务器的信息<br><code>&gt; info server</code></li>
<li>连接客户端的信息<br><code>&gt; info client</code></li>
<li>内存的信息<br><code>&gt; info memory</code></li>
<li>持久层数据<br><code>&gt; info persistence</code></li>
<li>状态的数据<br><code>&gt; info stats</code></li>
<li>从节点的信息<br><code>&gt; info replication</code></li>
<li>cpu的信息<br><code>&gt; info cpu</code></li>
</ul>
<h4 id="4、配置文件配置账号"><a href="#4、配置文件配置账号" class="headerlink" title="4、配置文件配置账号"></a>4、配置文件配置账号</h4><p>在配置文件redis.conf的文件中。在<code>requirepass</code>后面加上需要验证的密码<br>如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass test1234</span><br></pre></td></tr></table></figure>
<p>重启redis服务器之后进入命令行就要使用<br><code>auth test1234</code> 来验证了</p>
<h4 id="5、事务的处理"><a href="#5、事务的处理" class="headerlink" title="5、事务的处理"></a>5、事务的处理</h4><p>使用<code>multi</code>命令开启一个事务<br>然后接下来可以进行一些命令的操作<br>使用<code>exec</code>命令批量执行操作</p>
<h4 id="6、持久化的操作"><a href="#6、持久化的操作" class="headerlink" title="6、持久化的操作"></a>6、持久化的操作</h4><p>将内存中的数据存储到磁盘文件中<br>使用<code>save</code>命令</p>
<h3 id="Redis五大数据类型以及简单使用"><a href="#Redis五大数据类型以及简单使用" class="headerlink" title="Redis五大数据类型以及简单使用"></a>Redis五大数据类型以及简单使用</h3><h4 id="String字符串类型"><a href="#String字符串类型" class="headerlink" title="String字符串类型"></a>String字符串类型</h4><h5 id="1、添加数据"><a href="#1、添加数据" class="headerlink" title="1、添加数据"></a>1、添加数据</h5><p>  <code>set key-name value</code><br>  如果key存在则修改里面的值，如果不存在就添加</p>
<h5 id="2、查询数据"><a href="#2、查询数据" class="headerlink" title="2、查询数据"></a>2、查询数据</h5><p><code>get key-name</code></p>
<h5 id="3、删除数据"><a href="#3、删除数据" class="headerlink" title="3、删除数据"></a>3、删除数据</h5><p><code>del key-name</code></p>
<h5 id="4、设置key的过期时间"><a href="#4、设置key的过期时间" class="headerlink" title="4、设置key的过期时间"></a>4、设置key的过期时间</h5><p><code>setex key-name 10 value</code><br>设置key的过期时间为10秒</p>
<h5 id="5、设置多组值"><a href="#5、设置多组值" class="headerlink" title="5、设置多组值"></a>5、设置多组值</h5><p><code>mset key-name1 value1 key-name2 value2</code></p>
<h5 id="6、获得多组值"><a href="#6、获得多组值" class="headerlink" title="6、获得多组值"></a>6、获得多组值</h5><p><code>mget key-name1 key-name2</code></p>
<h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><h5 id="1、添加Hash表数据"><a href="#1、添加Hash表数据" class="headerlink" title="1、添加Hash表数据"></a>1、添加Hash表数据</h5><p><code>hset key-name hash-key hash-value</code><br>例如:<br><code>hset user name &quot;smith&quot;</code><br>添加一个hash表的名字为user,其中user中有[name&#x3D;”smith”]的键值对</p>
<h5 id="2、查询数据-1"><a href="#2、查询数据-1" class="headerlink" title="2、查询数据"></a>2、查询数据</h5><p><code>hget key-name hash-key</code><br>例如:<br><code>hget user name</code><br>查询user中key为name的值</p>
<h5 id="3、获得全部的键值对"><a href="#3、获得全部的键值对" class="headerlink" title="3、获得全部的键值对"></a>3、获得全部的键值对</h5><p><code>hgetall key-name</code></p>
<h5 id="4、一次设置多个键值对"><a href="#4、一次设置多个键值对" class="headerlink" title="4、一次设置多个键值对"></a>4、一次设置多个键值对</h5><p><code>hmset key-name hash-key1 hash-value1 hash-key2 hash-value2</code></p>
<h5 id="5、查看数据长度"><a href="#5、查看数据长度" class="headerlink" title="5、查看数据长度"></a>5、查看数据长度</h5><p><code>hlen key-name</code><br>返回该Hash表的键值对数量</p>
<h5 id="6、查询是否存在某个hash-key"><a href="#6、查询是否存在某个hash-key" class="headerlink" title="6、查询是否存在某个hash-key"></a>6、查询是否存在某个hash-key</h5><p><code>hexist key-name hash-key</code></p>
<h4 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h4><h5 id="1、添加数据-1"><a href="#1、添加数据-1" class="headerlink" title="1、添加数据"></a>1、添加数据</h5><p><code>lpush/rpush key-name value1 value2 value3</code><br>其中lpush从左边插入数据，rpush从右边插入数据</p>
<h5 id="2、获得数据"><a href="#2、获得数据" class="headerlink" title="2、获得数据"></a>2、获得数据</h5><p><code>lpop/rpop key-name</code><br>弹出列表最左边&#x2F;右边的值。</p>
<h5 id="3、遍历数据"><a href="#3、遍历数据" class="headerlink" title="3、遍历数据"></a>3、遍历数据</h5><p><code>lrange key-name start stop</code><br>遍历下标为[start,stop]的数据<br>例如:<br><code>lrange city 0 -1</code><br>遍历全部数据</p>
<h5 id="4、获得列表长度"><a href="#4、获得列表长度" class="headerlink" title="4、获得列表长度"></a>4、获得列表长度</h5><p><code>llen key-name</code></p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>  Set是String类型的无序集合,元素值不能重复</p>
<h5 id="1、添加数据-2"><a href="#1、添加数据-2" class="headerlink" title="1、添加数据"></a>1、添加数据</h5><p><code>sadd key-name value1 value2</code></p>
<h5 id="2、获得数据-1"><a href="#2、获得数据-1" class="headerlink" title="2、获得数据"></a>2、获得数据</h5><p><code>smembers key-name</code><br>获得所有数据</p>
<h5 id="3、查询是否存在某个成员"><a href="#3、查询是否存在某个成员" class="headerlink" title="3、查询是否存在某个成员"></a>3、查询是否存在某个成员</h5><p><code>sisexist key-name member</code></p>
<h5 id="4、移除某个成员"><a href="#4、移除某个成员" class="headerlink" title="4、移除某个成员"></a>4、移除某个成员</h5><p><code>srem key-name member</code></p>
<h4 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h4><p>  zset类型可以排序，每个值都有对应的score,可以进行集合间的操作</p>
<h5 id="1、添加数据-3"><a href="#1、添加数据-3" class="headerlink" title="1、添加数据"></a>1、添加数据</h5><p><code>zadd key-name score1 member1 score2 member2</code></p>
<h5 id="2、移除数据"><a href="#2、移除数据" class="headerlink" title="2、移除数据"></a>2、移除数据</h5><p><code>zrem key-name member [member2...]</code><br>使用[]来标识里面的内容为可选内容</p>
<h5 id="3、查询成员数量"><a href="#3、查询成员数量" class="headerlink" title="3、查询成员数量"></a>3、查询成员数量</h5><p><code>zcard key-name</code></p>
<h5 id="4、查询成员的分值"><a href="#4、查询成员的分值" class="headerlink" title="4、查询成员的分值"></a>4、查询成员的分值</h5><p><code>zscore key-name member</code></p>
<h5 id="5、修改成员的分值"><a href="#5、修改成员的分值" class="headerlink" title="5、修改成员的分值"></a>5、修改成员的分值</h5><p><code>zincrby key-name increase-num member</code><br>给成员的分值加上increase-num的值,可为正，可为负。</p>
<h5 id="6、根据score区间查询成员"><a href="#6、根据score区间查询成员" class="headerlink" title="6、根据score区间查询成员"></a>6、根据score区间查询成员</h5><p><code>zcount key-name min max</code><br>返回分值介于[min,max]区间的成员</p>
<h5 id="7、查询成员的排名"><a href="#7、查询成员的排名" class="headerlink" title="7、查询成员的排名"></a>7、查询成员的排名</h5><p>（1） <code>zrank key-name member</code><br>返回成员在集合中的排名,按照分值从小到大排<br>（2）<code>zrevrank key-name member</code><br>返回成员的排名，按照分值从大到小排</p>
<h5 id="8、根据排名区间获得成员"><a href="#8、根据排名区间获得成员" class="headerlink" title="8、根据排名区间获得成员"></a>8、根据排名区间获得成员</h5><p>(1) <code>zrange key-name start stop [WITHSCORES]</code><br>返回<strong>排名</strong>处于[start stop]区间内的成员,withscores选项会返回成员的分值。成员按照分值<strong>从小到大</strong>排序<br>(2) <code>zrevrange key-name start stop [WITHSCORES]</code><br>和<code>zrange</code>一致，区别是按照分值<strong>从大到小</strong>排序</p>
<h5 id="9、根据分数区间获得成员"><a href="#9、根据分数区间获得成员" class="headerlink" title="9、根据分数区间获得成员"></a>9、根据分数区间获得成员</h5><p>（1）<code>zrangebyscore key-name min max [WITHSCORES] [LIMIT offset count]</code><br>返回分数处于[min,max]区间的成员，按照分数<strong>从小到大</strong>排列<br>（2）<code>zrevrangebyscore key-name min max [WITHSCORES] [LIMIT offset count]</code><br>和(1)中的作用一致，不同的是成员按照分数<strong>从大到小</strong>排列</p>
<h5 id="10、多个ZSet进行交集运算"><a href="#10、多个ZSet进行交集运算" class="headerlink" title="10、多个ZSet进行交集运算"></a>10、多个ZSet进行交集运算</h5><p><code>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code><br>例子：<br><code>zset zkey3 2 zkey1 zkey2</code><br>zkey3放置zkey1和zkey2进行交运算之后的结果。其中2表示有两个集合。</p>
<h5 id="11、多个ZSet进行并集运算"><a href="#11、多个ZSet进行并集运算" class="headerlink" title="11、多个ZSet进行并集运算"></a>11、多个ZSet进行并集运算</h5><p><code>ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</code><br>相同的成员分数相加。</p>
<h4 id="使用Jedis来访问redis"><a href="#使用Jedis来访问redis" class="headerlink" title="使用Jedis来访问redis"></a>使用Jedis来访问redis</h4><h5 id="1、maven添加依赖"><a href="#1、maven添加依赖" class="headerlink" title="1、maven添加依赖"></a>1、maven添加依赖</h5><p>引入redis的依赖</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="2、连接和配置redis"><a href="#2、连接和配置redis" class="headerlink" title="2、连接和配置redis"></a>2、连接和配置redis</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Redis 配置</span><br><span class="line">spring.redis.jedis.pool.max-idle=<span class="number">10</span></span><br><span class="line">spring.redis.jedis.pool.max-active=<span class="number">10</span></span><br><span class="line">spring.redis.jedis.pool.min-idle=<span class="number">5</span></span><br><span class="line">spring.redis.jedis.pool.max-wait=<span class="number">2000</span></span><br><span class="line">#配置Redis服务器属性</span><br><span class="line">spring.redis.port=<span class="number">6379</span></span><br><span class="line">spring.redis.host=localhost</span><br><span class="line"># 连接的密码</span><br><span class="line">spring.redis.password=password</span><br><span class="line"># 连接超时设置</span><br><span class="line">spring.redis.timeout=<span class="number">1000</span></span><br><span class="line"></span><br><span class="line"># 缓存配置</span><br><span class="line">spring.cache.type=redis</span><br><span class="line">spring.cache.cache-names=redisCache</span><br></pre></td></tr></table></figure>
<h5 id="3、java中配置Redis的操作对象"><a href="#3、java中配置Redis的操作对象" class="headerlink" title="3、java中配置Redis的操作对象"></a>3、java中配置Redis的操作对象</h5><p>1、在启用类的类头哪里使用<code>@EnableCaching</code>注解开启redis<br>2、获得redis的模板对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 注入RedisTemplate对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>3、在bean的构造函数中初始化模板。主要是用来设置序列化的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    initRedisTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置RedisTemplate的序列化器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRedisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> redisTemplate.getStringSerializer();</span><br><span class="line">    redisTemplate.setKeySerializer(stringSerializer);</span><br><span class="line">    redisTemplate.setHashKeySerializer(stringSerializer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、使用redis的模板来操作redis<br>涉及到的函数为</p>
<ul>
<li><code>boolean hashKey = redisTemplate.hasKey(key)</code> 判断redis中是否含有key值</li>
<li>获得操作Redis对象的函数，其中的Dictionary是放进去的对象，redis会自动完成ORM的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ValueOperations&lt;String,Dictionary&gt; operations = redisTemplate.opsForValue();</span><br></pre></td></tr></table></figure>
<p>设置key对应的值<br><code>operations.set(key,dictionary,timeout,TimeUnit.HOURS);</code><br>key为对应的String类型的key值。<br><code>dictionary</code>为设置到缓存的对象。会被序列化为stirng类型。<br><code>timeout</code>为过期时间,long类型<br><code>TimeUnit.HOURS</code>是timeout的单位.可以设置纳秒、微秒、分钟、小时、天等。</p>
<h4 id="缓存穿透和缓存雪崩"><a href="#缓存穿透和缓存雪崩" class="headerlink" title="缓存穿透和缓存雪崩"></a>缓存穿透和缓存雪崩</h4><h5 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h5><p>  如何理解缓存穿透，缓存原本是放在数据库读写之前的一层缓存。用来减少数据库的io。穿透就是数据直接穿透缓存访问数据库，可以理解为缓存被穿透了。什么时候会导致缓存穿透？为什么会出现缓存穿透？读写数据的时候没有在redis中命中数据。导致访问数据库。没有命中数据 -&gt; 访问数据库。缓存的命中率太低了,导致缓存不起作用。这样就出现缓存穿透</p>
<h5 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h5><p>  什么是缓存雪崩?在某一时间段，缓存中的数据集体失效，导致大量的数据库出现大量的io请求。缓存中数据在同一时间失效。这就是缓存的雪崩，缓存雪崩可能会导致数据库的崩溃。如何避免缓存雪崩？雪崩的原因是同一时间失效，设置随机失效时间。</p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=https://long95288.github.io/2019/09/04/Redis笔记/%20风兮木落%20Redis笔记"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2019/09/07/java/javaScanner%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE/" title="javaScanner输入数据"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: javaScanner输入数据</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2019/09/02/java/Spring-%E4%BA%8B%E5%8A%A1/" title="Spring 事务">Next post: Spring 事务&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2025&nbsp;<a target="_blank" href="https://long95288.github.io" rel="noopener noreferrer">long</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>